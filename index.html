<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manuale Definitivo per Colloqui Tecnici 2026</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-primary: #58a6ff;
            --accent-secondary: #238636;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --border-color: #30363d;
            --code-bg: #1a1f26;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Layout */
        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .sidebar-header h1 {
            font-size: 1.2rem;
            color: var(--accent-primary);
            margin-bottom: 5px;
        }

        .sidebar-header span {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .nav-section {
            padding: 10px 20px;
        }

        .nav-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .nav-link {
            display: block;
            padding: 8px 12px;
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .nav-link:hover {
            background-color: var(--bg-tertiary);
        }

        .nav-link.active {
            background-color: var(--bg-tertiary);
            color: var(--accent-primary);
            font-weight: 500;
        }

        .nav-sublink {
            padding-left: 24px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            flex: 1;
            padding: 40px 60px;
            max-width: 900px;
        }

        .module-header {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .module-tag {
            display: inline-block;
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .module-header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .module-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Content Sections */
        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2::before {
            content: "►";
            font-size: 0.8rem;
        }

        .section h3 {
            font-size: 1.2rem;
            margin: 25px 0 15px;
            color: var(--text-primary);
        }

        .section p {
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        /* Info Box */
        .info-box {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-primary);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box.warning {
            border-left-color: var(--accent-warning);
        }

        .info-box.success {
            border-left-color: var(--accent-secondary);
        }

        .info-box h4 {
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-box.warning h4 {
            color: var(--accent-warning);
        }

        .info-box.success h4 {
            color: var(--accent-secondary);
        }

        /* Code Blocks */
        pre {
            background-color: var(--code-bg) !important;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px !important;
            margin: 20px 0 !important;
            overflow-x: auto;
        }

        code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        :not(pre) > code {
            background-color: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--accent-primary);
        }

        /* Lists */
        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 8px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-secondary);
            color: var(--accent-primary);
            font-weight: 600;
        }

        td {
            color: var(--text-secondary);
        }

        tr:hover td {
            background-color: var(--bg-secondary);
        }

        /* Quiz Section */
        .quiz-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-top: 50px;
        }

        .quiz-section h2 {
            color: var(--accent-warning);
            margin-bottom: 25px;
        }

        .quiz-section h2::before {
            content: "⚡";
        }

        .quiz-question {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .quiz-question:last-of-type {
            border-bottom: none;
        }

        .quiz-question h4 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .quiz-question h4 span {
            color: var(--accent-warning);
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .quiz-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 15px;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-option:hover {
            border-color: var(--accent-primary);
        }

        .quiz-option input {
            margin-top: 3px;
            accent-color: var(--accent-primary);
        }

        .quiz-option label {
            cursor: pointer;
            color: var(--text-secondary);
            flex: 1;
        }

        .quiz-option.correct {
            border-color: var(--accent-secondary);
            background-color: rgba(35, 134, 54, 0.1);
        }

        .quiz-option.incorrect {
            border-color: var(--accent-danger);
            background-color: rgba(248, 81, 73, 0.1);
        }

        .feedback {
            display: none;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
        }

        .feedback.correct {
            display: block;
            background-color: rgba(35, 134, 54, 0.15);
            border: 1px solid var(--accent-secondary);
            color: var(--accent-secondary);
        }

        .feedback.incorrect {
            display: block;
            background-color: rgba(248, 81, 73, 0.15);
            border: 1px solid var(--accent-danger);
            color: var(--text-primary);
        }

        .feedback strong {
            display: block;
            margin-bottom: 8px;
        }

        .check-btn {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: opacity 0.2s;
        }

        .check-btn:hover {
            opacity: 0.9;
        }

        .check-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Diagram */
        .diagram {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            margin: 25px 0;
            text-align: center;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
        }

        .diagram pre {
            background: transparent !important;
            border: none;
            padding: 0 !important;
            margin: 0 !important;
            text-align: left;
            display: inline-block;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 60px;
                padding: 15px 5px;
            }

            .sidebar-header, .nav-section h3, .nav-link span {
                display: none;
            }

            .nav-link {
                text-align: center;
                padding: 12px;
            }

            .main-content {
                margin-left: 60px;
                padding: 30px;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }

            .main-content {
                margin-left: 0;
                padding: 20px;
            }

            .module-header h1 {
                font-size: 1.8rem;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>Tech Interview 2026</h1>
                <span>Manuale Definitivo</span>
            </div>

            <div class="nav-section">
                <h3>Moduli</h3>
                <a href="#modulo1" class="nav-link active">
                    <span>1. Java & Spring Boot</span>
                </a>
                <a href="#modulo1-ioc" class="nav-link nav-sublink">IoC & Bean Lifecycle</a>
                <a href="#modulo1-annotations" class="nav-link nav-sublink">Spring Annotations</a>
                <a href="#modulo1-proxy" class="nav-link nav-sublink">Proxy Pattern</a>
                <a href="#modulo1-transactional" class="nav-link nav-sublink">@Transactional</a>
                <a href="#modulo1-security" class="nav-link nav-sublink">Spring Security</a>
                <a href="#modulo1-jpa" class="nav-link nav-sublink">JPA & N+1</a>
                <a href="#modulo1-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo2" class="nav-link"><span>2. Testing Strategy</span></a>
                <a href="#modulo2-pyramid" class="nav-link nav-sublink">Test Pyramid</a>
                <a href="#modulo2-types" class="nav-link nav-sublink">Unit vs Integration vs E2E</a>
                <a href="#modulo2-mocking" class="nav-link nav-sublink">Mocking vs Stubbing</a>
                <a href="#modulo2-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo3" class="nav-link"><span>3. Architettura & Scalabilità</span></a>
                <a href="#modulo3-monolith-micro" class="nav-link nav-sublink">Monoliti vs Microservizi</a>
                <a href="#modulo3-resilience" class="nav-link nav-sublink">Resilience Patterns</a>
                <a href="#modulo3-cap" class="nav-link nav-sublink">CAP Theorem</a>
                <a href="#modulo3-loadbalancing" class="nav-link nav-sublink">Load Balancing</a>
                <a href="#modulo3-caching" class="nav-link nav-sublink">Caching Strategies</a>
                <a href="#modulo3-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo4" class="nav-link"><span>4. Database & Messaging</span></a>
                <a href="#modulo4-sql-nosql" class="nav-link nav-sublink">SQL vs NoSQL</a>
                <a href="#modulo4-kafka" class="nav-link nav-sublink">Apache Kafka</a>
                <a href="#modulo4-rabbitmq" class="nav-link nav-sublink">RabbitMQ</a>
                <a href="#modulo4-comparison" class="nav-link nav-sublink">Kafka vs RabbitMQ</a>
                <a href="#modulo4-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo5" class="nav-link"><span>5. Cloud & DevOps</span></a>
                <a href="#modulo5-docker" class="nav-link nav-sublink">Docker</a>
                <a href="#modulo5-kubernetes" class="nav-link nav-sublink">Kubernetes</a>
                <a href="#modulo5-cicd" class="nav-link nav-sublink">CI/CD Pipelines</a>
                <a href="#modulo5-deployment" class="nav-link nav-sublink">Deployment Strategies</a>
                <a href="#modulo5-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo6" class="nav-link"><span>6. Advanced Topics 2026</span></a>
                <a href="#modulo7" class="nav-link"><span>7. Coding Challenges</span></a>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <header class="module-header" id="modulo1">
                <span class="module-tag">Modulo 1</span>
                <h1>Java & Spring Boot Deep Dive</h1>
                <p>Comprensione avanzata del framework Spring, dal container IoC alla gestione delle transazioni</p>
            </header>

            <!-- IoC Section -->
            <section class="section" id="modulo1-ioc">
                <h2>Inversion of Control & Dependency Injection</h2>

                <p>L'<strong>Inversion of Control</strong> (IoC) è un principio di design in cui il controllo del flusso di un programma viene invertito rispetto alla programmazione tradizionale. Invece di essere il nostro codice a creare e gestire le dipendenze, deleghiamo questa responsabilità a un <em>container</em>.</p>

                <div class="info-box">
                    <h4>Differenza chiave</h4>
                    <p>Nella programmazione tradizionale, la classe A crea direttamente un'istanza di B (<code>new B()</code>). Con IoC, la classe A dichiara di aver bisogno di B, e il container si occupa di fornirla (<strong>Dependency Injection</strong>).</p>
                </div>

                <h3>Tipi di Dependency Injection in Spring</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Constructor Injection</code></td>
                            <td>Immutabilità, dipendenze obbligatorie esplicite, testabilità</td>
                            <td>Costruttori verbosi con molte dipendenze</td>
                        </tr>
                        <tr>
                            <td><code>Setter Injection</code></td>
                            <td>Dipendenze opzionali, riconfigurabilità</td>
                            <td>Oggetti potenzialmente in stato incompleto</td>
                        </tr>
                        <tr>
                            <td><code>Field Injection</code></td>
                            <td>Codice conciso</td>
                            <td>Difficile da testare, nasconde le dipendenze</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <p>Preferisci sempre <strong>Constructor Injection</strong>. È l'approccio raccomandato dal team Spring perché garantisce l'immutabilità del bean e rende le dipendenze esplicite. Con Lombok, puoi usare <code>@RequiredArgsConstructor</code> per evitare boilerplate.</p>
                </div>

                <pre><code class="language-java">// ❌ Field Injection - da evitare
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
}

// ✅ Constructor Injection - approccio consigliato
@Service
@RequiredArgsConstructor
public class OrderService {
    private final PaymentService paymentService;
    private final InventoryService inventoryService;

    // Lombok genera il costruttore automaticamente
}</code></pre>

                <h3>Bean Lifecycle</h3>

                <p>Comprendere il ciclo di vita di un Bean è fondamentale per gestire correttamente l'inizializzazione delle risorse e il cleanup. Ecco le fasi principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SPRING BEAN LIFECYCLE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. INSTANTIATION                                                          │
│      └── Spring crea l'istanza del bean (new o reflection)                  │
│                           │                                                 │
│                           ▼                                                 │
│   2. POPULATE PROPERTIES                                                    │
│      └── Dependency Injection (constructor, setter, field)                  │
│                           │                                                 │
│                           ▼                                                 │
│   3. BEAN NAME AWARE                                                        │
│      └── setBeanName() se implementa BeanNameAware                          │
│                           │                                                 │
│                           ▼                                                 │
│   4. BEAN FACTORY AWARE                                                     │
│      └── setBeanFactory() se implementa BeanFactoryAware                    │
│                           │                                                 │
│                           ▼                                                 │
│   5. PRE-INITIALIZATION (BeanPostProcessor)                                 │
│      └── postProcessBeforeInitialization()                                  │
│                           │                                                 │
│                           ▼                                                 │
│   6. INITIALIZATION                                                         │
│      ├── @PostConstruct                                                     │
│      ├── InitializingBean.afterPropertiesSet()                              │
│      └── Custom init-method                                                 │
│                           │                                                 │
│                           ▼                                                 │
│   7. POST-INITIALIZATION (BeanPostProcessor)                                │
│      └── postProcessAfterInitialization()                                   │
│          ⚠️  Qui vengono creati i PROXY (AOP, @Transactional)               │
│                           │                                                 │
│                           ▼                                                 │
│   8. BEAN READY                                                             │
│      └── Il bean è pronto per l'uso                                         │
│                           │                                                 │
│                           ▼                                                 │
│   9. DESTRUCTION (alla chiusura del context)                                │
│      ├── @PreDestroy                                                        │
│      ├── DisposableBean.destroy()                                           │
│      └── Custom destroy-method                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">@Component
public class DatabaseConnectionPool implements InitializingBean, DisposableBean {

    private Connection connection;

    @PostConstruct
    public void init() {
        // Eseguito DOPO la dependency injection
        // Ideale per logica di inizializzazione leggera
        log.info("PostConstruct: inizializzazione risorse");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        // Eseguito DOPO @PostConstruct
        // Usato quando si ha bisogno di accesso al BeanFactory
        this.connection = dataSource.getConnection();
    }

    @PreDestroy
    public void cleanup() {
        // Eseguito durante lo shutdown del context
        // Rilascia risorse, chiudi connessioni
        if (connection != null) {
            connection.close();
        }
    }

    @Override
    public void destroy() throws Exception {
        // Eseguito DOPO @PreDestroy
        log.info("Bean destroyed");
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda frequente ai colloqui</h4>
                    <p>"Qual è la differenza tra <code>@PostConstruct</code> e il costruttore?"<br><br>
                    <strong>Risposta:</strong> Il costruttore viene chiamato <em>prima</em> che le dipendenze vengano iniettate (nel caso di setter/field injection). <code>@PostConstruct</code> viene chiamato <em>dopo</em> che tutte le dipendenze sono state iniettate, quindi è il posto sicuro per usare le dipendenze iniettate.</p>
                </div>
            </section>

            <!-- Spring Annotations Section -->
            <section class="section" id="modulo1-annotations">
                <h2>Spring Annotations - Le più richieste ai colloqui</h2>

                <p>Le annotation sono il cuore di Spring Boot. Conoscere le differenze sottili tra annotation simili è spesso oggetto di domande nei colloqui tecnici.</p>

                <h3>Core Stereotype Annotations</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Annotation</th>
                            <th>Descrizione</th>
                            <th>Layer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>@Component</code></td>
                            <td>Annotation generica per qualsiasi bean Spring</td>
                            <td>Generico</td>
                        </tr>
                        <tr>
                            <td><code>@Service</code></td>
                            <td>Specializzazione di @Component per la business logic</td>
                            <td>Service Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Repository</code></td>
                            <td>Specializzazione per DAO/persistence. Abilita la traduzione delle eccezioni DB</td>
                            <td>Data Access Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Controller</code></td>
                            <td>Per MVC controllers che ritornano views</td>
                            <td>Web Layer</td>
                        </tr>
                        <tr>
                            <td><code>@RestController</code></td>
                            <td><code>@Controller</code> + <code>@ResponseBody</code> su ogni metodo</td>
                            <td>Web Layer (REST)</td>
                        </tr>
                        <tr>
                            <td><code>@Configuration</code></td>
                            <td>Classe che contiene definizioni di bean (<code>@Bean</code> methods)</td>
                            <td>Configuration</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Domanda da colloquio</h4>
                    <p>"Qual è la differenza funzionale tra <code>@Service</code> e <code>@Component</code>?"<br><br>
                    <strong>Risposta:</strong> A livello funzionale, nessuna. Entrambi registrano un bean nel container. La differenza è <em>semantica</em>: <code>@Service</code> comunica l'intento (business logic), facilita la lettura del codice, e permette l'applicazione di AOP specifici per layer (es: logging solo sui service).</p>
                </div>

                <h3>Dependency Injection Annotations</h3>

                <pre><code class="language-java">// @Autowired - Injection automatica per tipo
@Service
public class OrderService {
    @Autowired  // Field injection (sconsigliato)
    private PaymentService paymentService;

    @Autowired  // Setter injection
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Autowired  // Constructor injection (consigliato)
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// @Qualifier - Disambigua quando ci sono più bean dello stesso tipo
@Service
public class NotificationService {
    @Autowired
    @Qualifier("emailSender")  // Specifica quale implementazione usare
    private MessageSender sender;
}

// @Primary - Indica il bean preferito quando ce ne sono multipli
@Configuration
public class SenderConfig {
    @Bean
    @Primary  // Questo sarà iniettato di default
    public MessageSender emailSender() {
        return new EmailSender();
    }

    @Bean
    public MessageSender smsSender() {
        return new SmsSender();
    }
}

// @Value - Inietta valori da properties
@Component
public class AppConfig {
    @Value("${app.name}")
    private String appName;

    @Value("${app.timeout:30}")  // Con valore di default
    private int timeout;

    @Value("#{systemProperties['user.home']}")  // SpEL expression
    private String userHome;
}</code></pre>

                <h3>Bean Scope Annotations</h3>

                <pre><code class="language-java">// @Scope - Definisce il lifecycle del bean
@Component
@Scope("singleton")  // Default: una sola istanza per ApplicationContext
public class SingletonBean { }

@Component
@Scope("prototype")  // Nuova istanza ad ogni injection/richiesta
public class PrototypeBean { }

@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean { }  // Una istanza per HTTP request

@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionScopedBean { }  // Una istanza per HTTP session</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione: Prototype in Singleton</h4>
                    <p>Se inietti un bean <code>prototype</code> in un <code>singleton</code>, il prototype viene creato UNA sola volta (al momento dell'injection nel singleton). Per ottenere una nuova istanza ogni volta, usa <code>ObjectFactory&lt;T&gt;</code>, <code>Provider&lt;T&gt;</code>, o <code>@Lookup</code>.</p>
                </div>

                <pre><code class="language-java">// Soluzione con Provider per prototype injection
@Service
public class OrderService {
    private final Provider&lt;ShoppingCart&gt; cartProvider;

    public OrderService(Provider&lt;ShoppingCart&gt; cartProvider) {
        this.cartProvider = cartProvider;
    }

    public void processOrder() {
        ShoppingCart cart = cartProvider.get();  // Nuova istanza ogni volta
    }
}

// Soluzione con @Lookup
@Service
public abstract class OrderService {
    @Lookup
    protected abstract ShoppingCart getShoppingCart();  // Spring sovrascrive questo metodo

    public void processOrder() {
        ShoppingCart cart = getShoppingCart();  // Nuova istanza ogni volta
    }
}</code></pre>

                <h3>Conditional Annotations</h3>

                <pre><code class="language-java">// @Conditional - Registra bean solo se la condizione è vera
@Configuration
public class DatabaseConfig {

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "mysql")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "postgres")
    public DataSource postgresDataSource() {
        return new PostgresDataSource();
    }

    @Bean
    @ConditionalOnMissingBean(DataSource.class)  // Solo se nessun DataSource è già definito
    public DataSource defaultDataSource() {
        return new H2DataSource();
    }
}

// @Profile - Attiva bean solo per profili specifici
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public EmailService emailService() {
        return new MockEmailService();  // Non invia email vere in dev
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public EmailService emailService() {
        return new SmtpEmailService();
    }
}

// Attivare profili: --spring.profiles.active=dev,local</code></pre>

                <h3>Web Layer Annotations</h3>

                <pre><code class="language-java">@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    // @GetMapping - HTTP GET
    @GetMapping("/{id}")
    public ResponseEntity&lt;User&gt; getUser(@PathVariable Long id) {
        return ResponseEntity.ok(userService.findById(id));
    }

    // @PostMapping - HTTP POST
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public User createUser(@RequestBody @Valid CreateUserRequest request) {
        return userService.create(request);
    }

    // @PutMapping - HTTP PUT (replace)
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) {
        return userService.update(id, request);
    }

    // @PatchMapping - HTTP PATCH (partial update)
    @PatchMapping("/{id}")
    public User patchUser(@PathVariable Long id, @RequestBody Map&lt;String, Object&gt; updates) {
        return userService.patch(id, updates);
    }

    // @DeleteMapping - HTTP DELETE
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);
    }

    // Query parameters
    @GetMapping
    public Page&lt;User&gt; searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return userService.search(name, PageRequest.of(page, size));
    }

    // Headers
    @GetMapping("/me")
    public User getCurrentUser(@RequestHeader("Authorization") String token) {
        return userService.fromToken(token);
    }
}</code></pre>

                <h3>Validation Annotations</h3>

                <pre><code class="language-java">public class CreateUserRequest {

    @NotNull(message = "Il nome è obbligatorio")
    @Size(min = 2, max = 50, message = "Il nome deve essere tra 2 e 50 caratteri")
    private String name;

    @NotBlank
    @Email(message = "Email non valida")
    private String email;

    @NotNull
    @Min(value = 18, message = "Devi avere almeno 18 anni")
    @Max(value = 120)
    private Integer age;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Numero di telefono non valido")
    private String phone;

    @Valid  // Valida anche l'oggetto nested
    @NotNull
    private Address address;
}

public class Address {
    @NotBlank
    private String street;

    @NotBlank
    @Size(min = 5, max = 5, message = "CAP deve essere di 5 cifre")
    private String zipCode;
}

// Nel controller
@PostMapping
public User createUser(@RequestBody @Valid CreateUserRequest request) {
    // Se la validazione fallisce, viene lanciata MethodArgumentNotValidException
    return userService.create(request);
}

// Custom validator
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    String message() default "Email già registrata";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class UniqueEmailValidator implements ConstraintValidator&lt;UniqueEmail, String&gt; {
    @Autowired
    private UserRepository userRepository;

    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        return !userRepository.existsByEmail(email);
    }
}</code></pre>

                <h3>JPA Annotations</h3>

                <pre><code class="language-java">@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email", unique = true)
})
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(unique = true, nullable = false)
    private String email;

    @Enumerated(EnumType.STRING)  // Salva il nome dell'enum, non l'ordinale
    private UserStatus status;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();

    @ManyToMany
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Version  // Optimistic locking
    private Long version;

    @Transient  // Non persistito nel DB
    private String temporaryToken;
}

@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
}</code></pre>

                <h3>Caching Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableCaching
public class CacheConfig { }

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        // Chiamato solo se non in cache
        return productRepository.findById(id).orElseThrow();
    }

    @Cacheable(value = "products", key = "#root.method.name + #category")
    public List&lt;Product&gt; findByCategory(String category) {
        return productRepository.findByCategory(category);
    }

    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        // Aggiorna sempre la cache con il risultato
        return productRepository.save(product);
    }

    @CacheEvict(value = "products", key = "#id")
    public void delete(Long id) {
        // Rimuove dalla cache
        productRepository.deleteById(id);
    }

    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Svuota tutta la cache "products"
    }

    @Caching(evict = {
        @CacheEvict(value = "products", key = "#product.id"),
        @CacheEvict(value = "categories", key = "#product.category")
    })
    public void updateWithCategoryChange(Product product) {
        productRepository.save(product);
    }
}</code></pre>

                <h3>Async & Scheduling Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableAsync
@EnableScheduling
public class AsyncConfig {

    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("Async-");
        return executor;
    }
}

@Service
public class NotificationService {

    @Async  // Eseguito in un thread separato
    public void sendEmailAsync(String to, String message) {
        // Non blocca il chiamante
        emailClient.send(to, message);
    }

    @Async
    public CompletableFuture&lt;Report&gt; generateReportAsync(Long userId) {
        Report report = reportGenerator.generate(userId);
        return CompletableFuture.completedFuture(report);
    }
}

@Component
public class ScheduledTasks {

    @Scheduled(fixedRate = 60000)  // Ogni 60 secondi
    public void checkHealth() {
        healthChecker.check();
    }

    @Scheduled(fixedDelay = 30000)  // 30 sec dopo la fine dell'esecuzione precedente
    public void processQueue() {
        queueProcessor.process();
    }

    @Scheduled(cron = "0 0 2 * * ?")  // Ogni giorno alle 2:00 AM
    public void nightlyCleanup() {
        cleanupService.run();
    }

    @Scheduled(cron = "0 */15 9-17 * * MON-FRI")  // Ogni 15 min, 9-17, Lun-Ven
    public void businessHoursTask() {
        // ...
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione con @Async</h4>
                    <p>Come <code>@Transactional</code>, anche <code>@Async</code> usa i proxy. La self-invocation non funziona! Inoltre, le eccezioni nei metodi async non vengono propagate al chiamante - usa un <code>AsyncUncaughtExceptionHandler</code> per gestirle.</p>
                </div>
            </section>

            <!-- Proxy Pattern Section -->
            <section class="section" id="modulo1-proxy">
                <h2>Proxy Pattern in Spring</h2>

                <p>Il <strong>Proxy Pattern</strong> è il meccanismo fondamentale attraverso cui Spring implementa l'<strong>Aspect-Oriented Programming</strong> (AOP). Quando annoti un bean con <code>@Transactional</code>, <code>@Cacheable</code>, <code>@Async</code>, o qualsiasi altro aspetto, Spring non usa direttamente la tua classe, ma crea un <em>proxy</em> che la avvolge.</p>

                <h3>JDK Dynamic Proxy vs CGLIB</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>JDK Dynamic Proxy</th>
                            <th>CGLIB Proxy</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Requisito</td>
                            <td>La classe deve implementare un'interfaccia</td>
                            <td>Nessun requisito (estende la classe)</td>
                        </tr>
                        <tr>
                            <td>Meccanismo</td>
                            <td>Implementa l'interfaccia a runtime</td>
                            <td>Crea una sottoclasse a runtime</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Leggermente più veloce nella creazione</td>
                            <td>Leggermente più veloce nell'invocazione</td>
                        </tr>
                        <tr>
                            <td>Limitazioni</td>
                            <td>Solo metodi dell'interfaccia</td>
                            <td>No classi/metodi <code>final</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Spring Boot Default</h4>
                    <p>A partire da Spring Boot 2.0, il default è <code>proxyTargetClass=true</code>, quindi viene usato CGLIB anche quando la classe implementa un'interfaccia. Questo evita sorprese quando si fa cast della classe concreta.</p>
                </div>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                    PROXY PATTERN IN SPRING                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   Client Code                                                           │
│       │                                                                 │
│       │ orderService.placeOrder()                                       │
│       ▼                                                                 │
│   ┌─────────────────────────────────────────────────┐                   │
│   │              PROXY (CGLIB/JDK)                  │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  1. Before Advice                         │  │                   │
│   │  │     - Apri transazione                    │  │                   │
│   │  │     - Log                                 │  │                   │
│   │  │     - Security check                      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  2. Target Method Invocation              │  │                   │
│   │  │     orderService.placeOrder() [REAL]      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  3. After Advice                          │  │                   │
│   │  │     - Commit/Rollback transazione         │  │                   │
│   │  │     - Log risultato                       │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   └─────────────────────────────────────────────────┘                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Il problema della Self-Invocation</h3>

                <p>Uno degli errori più comuni e insidiosi in Spring è la <strong>self-invocation</strong>: quando un metodo di un bean chiama un altro metodo dello stesso bean, il proxy viene bypassato.</p>

                <pre><code class="language-java">@Service
public class OrderService {

    @Transactional
    public void placeOrder(Order order) {
        // Logica di business
        validateOrder(order);  // ⚠️ SELF-INVOCATION!
        orderRepository.save(order);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void validateOrder(Order order) {
        // Questa transazione NON verrà creata!
        // Il metodo viene chiamato direttamente, senza passare dal proxy
        auditRepository.save(new AuditLog(order));
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Perché accade?</h4>
                    <p>Quando chiami <code>this.validateOrder()</code> (anche implicitamente), stai chiamando il metodo sulla <em>classe reale</em>, non sul proxy. Il proxy non ha modo di intercettare chiamate interne.</p>
                </div>

                <h3>Soluzioni alla Self-Invocation</h3>

                <pre><code class="language-java">// Soluzione 1: Estrarre in un altro service
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderValidationService validationService;

    @Transactional
    public void placeOrder(Order order) {
        validationService.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 2: Self-injection (meno elegante, ma funziona)
@Service
public class OrderService {
    @Autowired
    private OrderService self;  // Inietta il proxy di se stesso

    @Transactional
    public void placeOrder(Order order) {
        self.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 3: ApplicationContext (più verbosa)
@Service
public class OrderService implements ApplicationContextAware {
    private ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }

    @Transactional
    public void placeOrder(Order order) {
        context.getBean(OrderService.class).validateOrder(order);
    }
}</code></pre>
            </section>

            <!-- Transactional Section -->
            <section class="section" id="modulo1-transactional">
                <h2>Gestione delle Transazioni con @Transactional</h2>

                <p>La gestione dichiarativa delle transazioni è una delle feature più potenti di Spring. L'annotazione <code>@Transactional</code> permette di definire i confini transazionali in modo elegante, ma nasconde complessità che è fondamentale comprendere.</p>

                <h3>Attributi chiave di @Transactional</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Attributo</th>
                            <th>Default</th>
                            <th>Descrizione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>propagation</code></td>
                            <td><code>REQUIRED</code></td>
                            <td>Come la transazione si propaga</td>
                        </tr>
                        <tr>
                            <td><code>isolation</code></td>
                            <td><code>DEFAULT</code></td>
                            <td>Livello di isolamento (dal DB)</td>
                        </tr>
                        <tr>
                            <td><code>readOnly</code></td>
                            <td><code>false</code></td>
                            <td>Ottimizzazione per query read-only</td>
                        </tr>
                        <tr>
                            <td><code>timeout</code></td>
                            <td><code>-1</code></td>
                            <td>Timeout in secondi</td>
                        </tr>
                        <tr>
                            <td><code>rollbackFor</code></td>
                            <td>RuntimeException</td>
                            <td>Eccezioni che causano rollback</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Propagation Levels</h3>

                <pre><code class="language-java">// REQUIRED (default): usa la transazione esistente o ne crea una nuova
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // Se c'è una transazione attiva, la usa
    // Altrimenti ne crea una nuova
}

// REQUIRES_NEW: sospende la transazione corrente e ne crea una nuova
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void auditLog() {
    // Crea SEMPRE una nuova transazione
    // Se methodA() fa rollback, questo commit rimane
    auditRepository.save(log);
}

// NESTED: crea un savepoint nella transazione corrente
@Transactional(propagation = Propagation.NESTED)
public void nestedOperation() {
    // Se fallisce, rollback solo fino al savepoint
    // La transazione padre può decidere se continuare
}

// MANDATORY: DEVE esistere una transazione, altrimenti exception
@Transactional(propagation = Propagation.MANDATORY)
public void mustBeInTransaction() {
    // Lancia IllegalTransactionStateException se non c'è transazione
}

// NEVER: NON deve esistere una transazione
@Transactional(propagation = Propagation.NEVER)
public void mustNotBeInTransaction() {
    // Lancia exception se c'è una transazione attiva
}</code></pre>

                <div class="info-box warning">
                    <h4>Errore comune: Rollback su Checked Exception</h4>
                    <p>Per default, Spring fa rollback <strong>solo su RuntimeException</strong> e <code>Error</code>. Le checked exception (es: <code>IOException</code>) <strong>NON</strong> causano rollback automatico!</p>
                </div>

                <pre><code class="language-java">// ❌ Questa eccezione NON causa rollback!
@Transactional
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // La transazione fa COMMIT!
}

// ✅ Soluzione: specificare rollbackFor
@Transactional(rollbackFor = Exception.class)
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // Ora fa ROLLBACK
}</code></pre>

                <h3>Isolation Levels</h3>

                <p>I livelli di isolamento definiscono come le transazioni interagiscono tra loro e quali anomalie sono permesse:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Isolation Level</th>
                            <th>Dirty Read</th>
                            <th>Non-Repeatable Read</th>
                            <th>Phantom Read</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>READ_UNCOMMITTED</code></td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>READ_COMMITTED</code></td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>REPEATABLE_READ</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>SERIALIZABLE</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Glossario</h4>
                    <ul>
                        <li><strong>Dirty Read:</strong> leggere dati non ancora committati da un'altra transazione</li>
                        <li><strong>Non-Repeatable Read:</strong> leggere lo stesso record due volte e ottenere valori diversi</li>
                        <li><strong>Phantom Read:</strong> una query restituisce righe diverse se eseguita due volte (insert/delete da altre tx)</li>
                    </ul>
                </div>
            </section>

            <!-- Spring Security Section -->
            <section class="section" id="modulo1-security">
                <h2>Spring Security: OAuth2 & JWT</h2>

                <p>Spring Security è il framework de-facto per la sicurezza nelle applicazioni Spring. Nel contesto moderno, la maggior parte delle architetture utilizza <strong>OAuth2</strong> per l'autorizzazione e <strong>JWT</strong> (JSON Web Tokens) come formato per i token.</p>

                <h3>OAuth2 Flows</h3>

                <div class="diagram">
                    <pre>
┌──────────────────────────────────────────────────────────────────────────────┐
│                    AUTHORIZATION CODE FLOW (più sicuro)                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│    ┌────────┐          ┌───────────────┐         ┌──────────────────┐        │
│    │ Client │          │ Authorization │         │ Resource Server  │        │
│    │ (App)  │          │    Server     │         │     (API)        │        │
│    └───┬────┘          └───────┬───────┘         └────────┬─────────┘        │
│        │                       │                          │                  │
│        │  1. Redirect to       │                          │                  │
│        │     /authorize        │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  2. User logs in      │                          │                  │
│        │     & consents        │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  3. Authorization     │                          │                  │
│        │     Code (via         │                          │                  │
│        │     redirect)         │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  4. Exchange code     │                          │                  │
│        │     for tokens        │                          │                  │
│        │     (backend only)    │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  5. Access Token      │                          │                  │
│        │     + Refresh Token   │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  6. API Request                                  │                  │
│        │     with Bearer Token ─────────────────────────▶│                  │
│        │                                                  │                  │
│        │  7. Protected Resource ◀─────────────────────────│                  │
│        │                                                  │                  │
└──────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>JWT Structure</h3>

                <p>Un JWT è composto da tre parti separate da punti: <code>header.payload.signature</code></p>

                <pre><code class="language-json">// Header (Base64)
{
  "alg": "RS256",
  "typ": "JWT"
}

// Payload (Base64) - CLAIMS
{
  "sub": "1234567890",           // Subject (user ID)
  "name": "Mario Rossi",
  "email": "mario@example.com",
  "roles": ["ROLE_USER", "ROLE_ADMIN"],
  "iat": 1699900000,             // Issued At
  "exp": 1699903600,             // Expiration
  "iss": "https://auth.myapp.com" // Issuer
}

// Signature
RSASHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  privateKey
)</code></pre>

                <h3>Configurazione Spring Security con JWT</h3>

                <pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())  // Disabilitato per API stateless
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/**").authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            )
            .build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authoritiesConverter =
            new JwtGrantedAuthoritiesConverter();
        authoritiesConverter.setAuthoritiesClaimName("roles");
        authoritiesConverter.setAuthorityPrefix("ROLE_");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
        return converter;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Security Best Practices</h4>
                    <ul>
                        <li>Usa <strong>RS256</strong> (asimmetrico) invece di HS256 per ambienti distribuiti</li>
                        <li>Mantieni i token di accesso con <strong>breve durata</strong> (15-30 min)</li>
                        <li>Usa <strong>Refresh Tokens</strong> con rotazione per sessioni lunghe</li>
                        <li><strong>Mai</strong> memorizzare dati sensibili nel payload JWT (è solo encoded, non encrypted)</li>
                        <li>Valida sempre <code>iss</code>, <code>aud</code>, <code>exp</code> claims</li>
                    </ul>
                </div>
            </section>

            <!-- JPA Section -->
            <section class="section" id="modulo1-jpa">
                <h2>Spring Data JPA & il Problema N+1</h2>

                <p>Il problema <strong>N+1</strong> è uno dei problemi di performance più comuni nelle applicazioni che usano un ORM. Si verifica quando il framework esegue una query per recuperare N entità, e poi N query aggiuntive per recuperare le relazioni di ciascuna.</p>

                <h3>Esempio del Problema N+1</h3>

                <pre><code class="language-java">@Entity
public class Order {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;

    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List&lt;OrderItem&gt; items;
}

// Repository
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Service - PROBLEMA N+1
@Service
public class OrderService {
    public List&lt;OrderDTO&gt; getActiveOrders() {
        List&lt;Order&gt; orders = orderRepository.findByStatus(ACTIVE);
        // Query 1: SELECT * FROM orders WHERE status = 'ACTIVE'

        return orders.stream()
            .map(order -> new OrderDTO(
                order.getId(),
                order.getCustomer().getName(),  // Query 2, 3, 4... N+1!
                order.getItems().size()          // Ancora N query!
            ))
            .toList();
    }
}</code></pre>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PROBLEMA N+1 QUERIES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Scenario: 100 ordini attivi, ognuno con customer e items                   │
│                                                                             │
│  Query 1:   SELECT * FROM orders WHERE status = 'ACTIVE'                    │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 2:   SELECT * FROM customers WHERE id = 1                            │
│  Query 3:   SELECT * FROM customers WHERE id = 2                            │
│  ...                                                                        │
│  Query 101: SELECT * FROM customers WHERE id = 100                          │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 102: SELECT * FROM order_items WHERE order_id = 1                    │
│  Query 103: SELECT * FROM order_items WHERE order_id = 2                    │
│  ...                                                                        │
│  Query 201: SELECT * FROM order_items WHERE order_id = 100                  │
│                                                                             │
│  TOTALE: 1 + 100 + 100 = 201 QUERY! (invece di 1-3 ottimali)                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Soluzioni al Problema N+1</h3>

                <pre><code class="language-java">// Soluzione 1: JOIN FETCH (JPQL)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @Query("""
        SELECT DISTINCT o FROM Order o
        LEFT JOIN FETCH o.customer
        LEFT JOIN FETCH o.items
        WHERE o.status = :status
        """)
    List&lt;Order&gt; findByStatusWithDetails(@Param("status") OrderStatus status);
}

// Soluzione 2: @EntityGraph (più dichiarativo)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @EntityGraph(attributePaths = {"customer", "items"})
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Soluzione 3: @BatchSize (per lazy loading ottimizzato)
@Entity
public class Order {
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    @BatchSize(size = 25)  // Carica 25 collezioni alla volta
    private List&lt;OrderItem&gt; items;
}

// Soluzione 4: Projection (quando servono pochi campi)
public interface OrderSummary {
    Long getId();
    String getCustomerName();
    Integer getItemCount();
}

@Query("""
    SELECT o.id as id,
           c.name as customerName,
           SIZE(o.items) as itemCount
    FROM Order o
    JOIN o.customer c
    WHERE o.status = :status
    """)
List&lt;OrderSummary&gt; findOrderSummaries(@Param("status") OrderStatus status);</code></pre>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <ul>
                        <li>Usa sempre <code>FetchType.LAZY</code> come default</li>
                        <li>Usa <code>JOIN FETCH</code> o <code>@EntityGraph</code> nelle query che necessitano delle relazioni</li>
                        <li>Attiva il logging delle query in sviluppo: <code>spring.jpa.show-sql=true</code></li>
                        <li>Usa strumenti come <strong>Hibernate Statistics</strong> o <strong>p6spy</strong> per monitorare</li>
                        <li>Considera <strong>Projections</strong> per DTOs read-only (migliore performance)</li>
                    </ul>
                </div>

                <div class="info-box warning">
                    <h4>Attenzione: MultipleBagFetchException</h4>
                    <p>Non puoi fare JOIN FETCH di due <code>List</code> contemporaneamente (Cartesian Product problem). Soluzioni:</p>
                    <ul>
                        <li>Cambia una delle collection in <code>Set</code></li>
                        <li>Usa due query separate con <code>@BatchSize</code></li>
                        <li>Usa <code>@Fetch(FetchMode.SUBSELECT)</code></li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section -->
            <section class="quiz-section" id="modulo1-quiz">
                <h2>Interactive Challenge Quiz</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Metti alla prova la tua comprensione di Spring. Queste domande riflettono il livello di difficoltà dei colloqui nelle Big Tech.</p>

                <!-- Question 1 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Nel seguente codice, cosa succede quando viene chiamato <code>serviceA.methodA()</code>?</h4>
                    <pre><code class="language-java">@Service
public class ServiceA {
    @Transactional
    public void methodA() {
        // ... database operations ...
        methodB();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // ... more database operations ...
        throw new RuntimeException("Error!");
    }
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q1" id="q1a" value="a">
                            <label for="q1a">Solo methodB fa rollback, methodA fa commit (perché REQUIRES_NEW crea una nuova transazione)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q1" id="q1b" value="b">
                            <label for="q1b">Entrambi i metodi fanno rollback perché l'eccezione si propaga</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q1" id="q1c" value="c">
                            <label for="q1c">Entrambi i metodi fanno rollback, ma NON perché REQUIRES_NEW funziona: il problema è la self-invocation</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q1" id="q1d" value="d">
                            <label for="q1d">L'applicazione non compila perché non si possono avere due @Transactional nello stesso service</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q1')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q1"></div>
                </div>

                <!-- Question 2 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sul JWT è <strong>FALSA</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q2" id="q2a" value="a">
                            <label for="q2a">Il payload del JWT è visibile a chiunque intercetti il token (è solo Base64 encoded)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q2" id="q2b" value="b">
                            <label for="q2b">Un JWT con algoritmo RS256 può essere validato solo dal server che possiede la chiave privata</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q2" id="q2c" value="c">
                            <label for="q2c">Una volta emesso, un JWT non può essere revocato senza meccanismi aggiuntivi (come una blacklist)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q2" id="q2d" value="d">
                            <label for="q2d">La signature del JWT garantisce che il payload non sia stato modificato dopo l'emissione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q2')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q2"></div>
                </div>

                <!-- Question 3 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Quale combinazione di strategie risolve il problema N+1 per questa entity?</h4>
                    <pre><code class="language-java">@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Employee&gt; employees;

    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Project&gt; projects;
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q3" id="q3a" value="a">
                            <label for="q3a">Un singolo JOIN FETCH di entrambe le collection: <code>JOIN FETCH d.employees JOIN FETCH d.projects</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q3" id="q3b" value="b">
                            <label for="q3b">Cambiare entrambe le collection in <code>FetchType.EAGER</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q3" id="q3c" value="c">
                            <label for="q3c">Usare <code>@EntityGraph(attributePaths = {"employees", "projects"})</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q3" id="q3d" value="d">
                            <label for="q3d">Cambiare una collection in Set, oppure usare due query separate con @BatchSize su entrambe</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q3')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q3"></div>
                </div>

                <!-- Question 4 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In quale fase del Bean Lifecycle vengono creati i proxy AOP?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q4a" value="a">
                            <label for="q4a">Durante <code>postProcessAfterInitialization()</code> del BeanPostProcessor</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q4" id="q4b" value="b">
                            <label for="q4b">Durante l'instantiation del bean (fase 1)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q4" id="q4c" value="c">
                            <label for="q4c">Durante <code>@PostConstruct</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q4" id="q4d" value="d">
                            <label for="q4d">Durante <code>postProcessBeforeInitialization()</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q4')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q4"></div>
                </div>

                <!-- Question 5 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Quale livello di isolamento previene i <strong>Phantom Reads</strong> ma permette i <strong>Non-Repeatable Reads</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q5a" value="a">
                            <label for="q5a"><code>READ_COMMITTED</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q5" id="q5b" value="b">
                            <label for="q5b"><code>REPEATABLE_READ</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q5" id="q5c" value="c">
                            <label for="q5c">Nessuno: è impossibile prevenire Phantom Reads senza prevenire prima Non-Repeatable Reads</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q5" id="q5d" value="d">
                            <label for="q5d"><code>SERIALIZABLE</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q5')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q5"></div>
                </div>
            </section>

            <!-- ==================== MODULO 2: TESTING STRATEGY ==================== -->

            <header class="module-header" id="modulo2" style="margin-top: 80px;">
                <span class="module-tag">Modulo 2</span>
                <h1>Testing Strategy</h1>
                <p>Dalla Test Pyramid al TDD: strategie e best practices per scrivere test efficaci e mantenibili</p>
            </header>

            <!-- Test Pyramid Section -->
            <section class="section" id="modulo2-pyramid">
                <h2>The Test Pyramid</h2>

                <p>La <strong>Test Pyramid</strong> è un modello concettuale introdotto da Mike Cohn che illustra come dovrebbe essere distribuito lo sforzo di testing in un progetto software. La forma piramidale indica che dovresti avere molti più test alla base (unit) e progressivamente meno salendo verso l'alto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                           THE TEST PYRAMID                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ▲                                              │
│                             ╱ ╲            E2E / UI Tests                   │
│                            ╱   ╲           ─────────────────                │
│                           ╱     ╲          • Pochi (5-10%)                  │
│                          ╱  E2E  ╲         • Lenti (minuti)                 │
│                         ╱─────────╲        • Fragili                        │
│                        ╱           ╲       • Alto costo manutenzione        │
│                       ╱             ╲                                       │
│                      ╱───────────────╲                                      │
│                     ╱                 ╲    Integration Tests                │
│                    ╱    INTEGRATION    ╲   ──────────────────               │
│                   ╱                     ╲  • Moderati (15-25%)              │
│                  ╱───────────────────────╲ • Velocità media (secondi)       │
│                 ╱                         ╲• Testano interazioni            │
│                ╱                           ╲                                │
│               ╱─────────────────────────────╲                               │
│              ╱                               ╲  Unit Tests                  │
│             ╱            UNIT                 ╲ ────────────                │
│            ╱                                   ╲• Molti (70-80%)            │
│           ╱─────────────────────────────────────╲ Velocissimi (ms)         │
│          ╱                                       ╲• Isolati                 │
│         ╱                                         ╲• Facili da mantenere    │
│        ╱───────────────────────────────────────────╲                        │
│                                                                             │
│   COSTO ←──────────────────────────────────────────────────────────→ BASSO  │
│   ALTO                                                                      │
│                                                                             │
│   VELOCITÀ ←────────────────────────────────────────────────────────→ ALTA  │
│   BASSA                                                                     │
│                                                                             │
│   FEEDBACK ←────────────────────────────────────────────────────────→ RAPIDO│
│   LENTO                                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box">
                    <h4>Perché questa forma?</h4>
                    <p>I test alla base (unit) sono <strong>veloci</strong>, <strong>economici</strong> da scrivere e mantenere, e forniscono <strong>feedback immediato</strong>. Salendo nella piramide, i test diventano più costosi, più lenti, e più fragili (prone a fallire per ragioni non legate al codice testato). L'obiettivo è massimizzare la copertura con i test più economici.</p>
                </div>

                <h3>Anti-Pattern: Ice Cream Cone</h3>

                <p>Molti team cadono nel pattern "Ice Cream Cone" (piramide invertita): troppi test E2E, pochi unit test. Questo porta a:</p>

                <ul>
                    <li><strong>Build lente</strong>: la CI impiega ore invece di minuti</li>
                    <li><strong>Feedback tardivo</strong>: scopri i bug solo alla fine della pipeline</li>
                    <li><strong>Flaky tests</strong>: test che falliscono in modo intermittente per timeout, race condition, o dipendenze esterne</li>
                    <li><strong>Paralisi del refactoring</strong>: paura di modificare il codice perché i test si rompono continuamente</li>
                </ul>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una codebase con 500 test E2E e solo 50 unit test?"<br><br>
                    <strong>Risposta:</strong> Inizierei identificando i test E2E che verificano logica di business pura e li convertirei in unit test. Userei i test E2E esistenti come "safety net" temporanea mentre costruisco la copertura unit. Introdurrei metriche di code coverage per guidare le priorità e stabilirei una policy "no new E2E tests" per funzionalità testabili a livello unit.</p>
                </div>
            </section>

            <!-- Test Types Section -->
            <section class="section" id="modulo2-types">
                <h2>Unit vs Integration vs E2E Tests</h2>

                <h3>Unit Tests</h3>

                <p>Gli <strong>Unit Tests</strong> verificano il comportamento di una singola unità di codice (classe, metodo, funzione) in <strong>completo isolamento</strong>. Tutte le dipendenze esterne vengono sostituite con test doubles (mock, stub, fake).</p>

                <pre><code class="language-java">// Classe da testare
public class PriceCalculator {
    private final DiscountService discountService;
    private final TaxService taxService;

    public PriceCalculator(DiscountService discountService, TaxService taxService) {
        this.discountService = discountService;
        this.taxService = taxService;
    }

    public BigDecimal calculateFinalPrice(Product product, Customer customer) {
        BigDecimal basePrice = product.getPrice();
        BigDecimal discount = discountService.getDiscount(customer);
        BigDecimal discountedPrice = basePrice.multiply(BigDecimal.ONE.subtract(discount));
        BigDecimal tax = taxService.calculateTax(discountedPrice, customer.getCountry());
        return discountedPrice.add(tax);
    }
}

// Unit Test - isolato con mock
@ExtendWith(MockitoExtension.class)
class PriceCalculatorTest {

    @Mock
    private DiscountService discountService;

    @Mock
    private TaxService taxService;

    @InjectMocks
    private PriceCalculator calculator;

    @Test
    void shouldApplyDiscountBeforeTax() {
        // Given
        Product product = new Product("Laptop", new BigDecimal("1000.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer))
            .thenReturn(new BigDecimal("0.10")); // 10% discount

        when(taxService.calculateTax(eq(new BigDecimal("900.00")), eq("IT")))
            .thenReturn(new BigDecimal("198.00")); // 22% IVA

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("1098.00"));

        // Verify interaction order
        InOrder inOrder = inOrder(discountService, taxService);
        inOrder.verify(discountService).getDiscount(customer);
        inOrder.verify(taxService).calculateTax(any(), any());
    }

    @Test
    void shouldHandleZeroDiscount() {
        // Given
        Product product = new Product("Mouse", new BigDecimal("50.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer)).thenReturn(BigDecimal.ZERO);
        when(taxService.calculateTax(any(), any())).thenReturn(new BigDecimal("11.00"));

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("61.00"));
    }
}</code></pre>

                <h3>Integration Tests</h3>

                <p>Gli <strong>Integration Tests</strong> verificano che più componenti funzionino correttamente <strong>insieme</strong>. Tipicamente testano l'interazione tra il codice applicativo e sistemi esterni (database, message broker, API esterne).</p>

                <pre><code class="language-java">// Integration Test con Spring Boot e database reale (H2/TestContainers)
@SpringBootTest
@Transactional  // Rollback automatico dopo ogni test
class OrderServiceIntegrationTest {

    @Autowired
    private OrderService orderService;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Test
    void shouldPersistOrderWithItems() {
        // Given
        Customer customer = customerRepository.save(
            new Customer("Mario Rossi", "mario@example.com")
        );

        CreateOrderRequest request = CreateOrderRequest.builder()
            .customerId(customer.getId())
            .items(List.of(
                new OrderItemRequest("PROD-001", 2),
                new OrderItemRequest("PROD-002", 1)
            ))
            .build();

        // When
        Order order = orderService.createOrder(request);

        // Then
        assertThat(order.getId()).isNotNull();
        assertThat(order.getItems()).hasSize(2);

        // Verify persistence
        Order persistedOrder = orderRepository.findById(order.getId()).orElseThrow();
        assertThat(persistedOrder.getCustomer().getName()).isEqualTo("Mario Rossi");
        assertThat(persistedOrder.getStatus()).isEqualTo(OrderStatus.CREATED);
    }

    @Test
    void shouldPublishEventWhenOrderCreated() {
        // Test che verifica l'integrazione con il message broker
        // ...
    }
}

// Integration Test con TestContainers (database reale)
@SpringBootTest
@Testcontainers
class OrderRepositoryIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private OrderRepository orderRepository;

    @Test
    void shouldFindOrdersByCustomerWithNativeQuery() {
        // Test di query complesse con database reale PostgreSQL
        // ...
    }
}</code></pre>

                <h3>E2E (End-to-End) Tests</h3>

                <p>I test <strong>E2E</strong> verificano l'intero flusso applicativo dal punto di vista dell'utente, attraversando tutti i layer (UI → API → Database → External Services).</p>

                <pre><code class="language-java">// E2E Test con REST Assured
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderApiE2ETest {

    @LocalServerPort
    private int port;

    @Autowired
    private CustomerRepository customerRepository;

    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/api/v1";
    }

    @Test
    void completeOrderFlow() {
        // 1. Create customer
        String customerId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "name": "Mario Rossi",
                    "email": "mario@example.com"
                }
                """)
            .when()
            .post("/customers")
            .then()
            .statusCode(201)
            .extract()
            .path("id");

        // 2. Create order
        String orderId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "customerId": "%s",
                    "items": [
                        {"productId": "PROD-001", "quantity": 2}
                    ]
                }
                """.formatted(customerId))
            .when()
            .post("/orders")
            .then()
            .statusCode(201)
            .body("status", equalTo("CREATED"))
            .extract()
            .path("id");

        // 3. Pay order
        given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "paymentMethod": "CREDIT_CARD",
                    "cardToken": "tok_visa_success"
                }
                """)
            .when()
            .post("/orders/{orderId}/pay", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"));

        // 4. Verify final state
        given()
            .when()
            .get("/orders/{orderId}", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"))
            .body("paymentDate", notNullValue());
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Unit Test</th>
                            <th>Integration Test</th>
                            <th>E2E Test</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Singola classe/metodo</td>
                            <td>Più componenti insieme</td>
                            <td>Intero sistema</td>
                        </tr>
                        <tr>
                            <td><strong>Dipendenze</strong></td>
                            <td>Tutte mockate</td>
                            <td>Alcune reali (DB, broker)</td>
                            <td>Tutte reali</td>
                        </tr>
                        <tr>
                            <td><strong>Velocità</strong></td>
                            <td>Millisecondi</td>
                            <td>Secondi</td>
                            <td>Minuti</td>
                        </tr>
                        <tr>
                            <td><strong>Feedback</strong></td>
                            <td>Specifico (quale metodo fallisce)</td>
                            <td>Moderato</td>
                            <td>Generico (qualcosa è rotto)</td>
                        </tr>
                        <tr>
                            <td><strong>Flakiness</strong></td>
                            <td>Quasi zero</td>
                            <td>Bassa</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Quando usare</strong></td>
                            <td>Logica di business</td>
                            <td>Interazioni con DB/broker</td>
                            <td>Critical user journeys</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Mocking vs Stubbing Section -->
            <section class="section" id="modulo2-mocking">
                <h2>Mocking vs Stubbing</h2>

                <p>Questa distinzione è fondamentale e spesso confusa. <strong>Mock</strong> e <strong>Stub</strong> sono entrambi "Test Doubles" (sostituti di dipendenze reali), ma hanno scopi diversi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TEST DOUBLES TAXONOMY                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                           Test Double                                       │
│                               │                                             │
│         ┌─────────┬───────────┼───────────┬─────────┐                       │
│         │         │           │           │         │                       │
│         ▼         ▼           ▼           ▼         ▼                       │
│      ┌──────┐ ┌──────┐   ┌────────┐  ┌───────┐ ┌───────┐                    │
│      │ Dummy│ │ Fake │   │  Stub  │  │  Spy  │ │  Mock │                    │
│      └──────┘ └──────┘   └────────┘  └───────┘ └───────┘                    │
│         │         │           │           │         │                       │
│         │         │           │           │         │                       │
│    Placeholder  Working   Returns     Records   Verifies                    │
│    (never used) implem.   canned      calls +   behavior                    │
│                 (in-mem   answers     delegates (expectations)              │
│                  DB)                  to real                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│                   STATE VERIFICATION                                        │
│                   ──────────────────                                        │
│                   Stub, Fake                                                │
│                   "Given this input, return this output"                    │
│                   Test verifica il RISULTATO                                │
│                                                                             │
│                   BEHAVIOR VERIFICATION                                     │
│                   ────────────────────                                      │
│                   Mock, Spy                                                 │
│                   "Verify this method was called with these args"           │
│                   Test verifica le INTERAZIONI                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Stub: State Verification</h3>

                <p>Uno <strong>Stub</strong> fornisce risposte predefinite alle chiamate. Non verifica come viene usato, solo che il sistema under test produca il risultato corretto dato quell'input.</p>

                <pre><code class="language-java">// STUB - Fornisce risposte predefinite
@Test
void shouldCalculateTotalWithDiscount_usingStub() {
    // Stub: definiamo solo COSA ritorna, non ci interessa COME viene chiamato
    DiscountService discountStub = new DiscountService() {
        @Override
        public BigDecimal getDiscount(Customer customer) {
            return new BigDecimal("0.15"); // Sempre 15%
        }
    };

    PriceCalculator calculator = new PriceCalculator(discountStub, taxService);

    // State verification: verifico solo il RISULTATO finale
    BigDecimal result = calculator.calculateFinalPrice(product, customer);
    assertThat(result).isEqualByComparingTo(expectedPrice);

    // NON verifichiamo se/come getDiscount() è stato chiamato
}

// Con Mockito: when() crea uno STUB
@Test
void shouldCalculateTotalWithDiscount_usingMockitoStub() {
    // Questo è tecnicamente uno STUB, anche se usiamo @Mock
    when(discountService.getDiscount(any())).thenReturn(new BigDecimal("0.15"));

    BigDecimal result = calculator.calculateFinalPrice(product, customer);

    assertThat(result).isEqualByComparingTo(expectedPrice);
    // Nessun verify() = state verification
}</code></pre>

                <h3>Mock: Behavior Verification</h3>

                <p>Un <strong>Mock</strong> è un oggetto pre-programmato con aspettative sulle chiamate che riceverà. Il test fallisce se le aspettative non vengono soddisfatte.</p>

                <pre><code class="language-java">// MOCK - Verifica il comportamento/interazioni
@Test
void shouldNotifyWarehouseWhenOrderPlaced_usingMock() {
    // Given
    Order order = new Order(customer, List.of(item1, item2));

    // Mock: ci interessa verificare CHE venga chiamato e COME
    WarehouseService warehouseMock = mock(WarehouseService.class);
    OrderService orderService = new OrderService(warehouseMock);

    // When
    orderService.placeOrder(order);

    // Behavior verification: verifichiamo le INTERAZIONI
    verify(warehouseMock).reserveStock(order.getItems());
    verify(warehouseMock, times(1)).scheduleShipment(order);
    verify(warehouseMock, never()).cancelReservation(any());

    // Verifica dell'ordine delle chiamate
    InOrder inOrder = inOrder(warehouseMock);
    inOrder.verify(warehouseMock).reserveStock(any());
    inOrder.verify(warehouseMock).scheduleShipment(any());
}

// Argument Captor per verifiche più sofisticate
@Test
void shouldSendCorrectEmailContent() {
    // Given
    ArgumentCaptor&lt;Email&gt; emailCaptor = ArgumentCaptor.forClass(Email.class);

    // When
    userService.registerUser(newUser);

    // Then - cattura l'argomento passato al mock
    verify(emailService).send(emailCaptor.capture());

    Email sentEmail = emailCaptor.getValue();
    assertThat(sentEmail.getTo()).isEqualTo(newUser.getEmail());
    assertThat(sentEmail.getSubject()).contains("Welcome");
    assertThat(sentEmail.getBody()).contains(newUser.getName());
}</code></pre>

                <div class="info-box warning">
                    <h4>Quando usare Mock vs Stub?</h4>
                    <ul>
                        <li><strong>Usa Stub</strong> quando ti interessa solo il risultato (es: calcoli, trasformazioni, query)</li>
                        <li><strong>Usa Mock</strong> quando ti interessa verificare che un side-effect avvenga (es: email inviata, evento pubblicato, audit log scritto)</li>
                        <li><strong>Evita over-mocking</strong>: se ti trovi a verificare ogni singola chiamata, probabilmente stai testando l'implementazione invece del comportamento</li>
                    </ul>
                </div>

                <h3>Spy: Il meglio di entrambi i mondi</h3>

                <p>Uno <strong>Spy</strong> avvolge un oggetto reale, permettendo di tracciare le chiamate e opzionalmente sovrascrivere alcuni metodi.</p>

                <pre><code class="language-java">@Test
void shouldUseRealImplementationButTrackCalls() {
    // Spy su implementazione reale
    List&lt;String&gt; realList = new ArrayList&lt;&gt;();
    List&lt;String&gt; spyList = spy(realList);

    // Usa implementazione reale
    spyList.add("one");
    spyList.add("two");

    // Ma possiamo verificare le chiamate
    verify(spyList).add("one");
    verify(spyList, times(2)).add(anyString());

    // E sovrascrivere comportamenti specifici
    doReturn(100).when(spyList).size();
    assertThat(spyList.size()).isEqualTo(100); // Stubbed
    assertThat(spyList.get(0)).isEqualTo("one"); // Real
}</code></pre>
            </section>

            <!-- Quiz Section Module 2 -->
            <section class="quiz-section" id="modulo2-quiz">
                <h2>Interactive Challenge Quiz - Testing</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione delle strategie di testing.</p>

                <!-- Question 6 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Un test verifica che quando un utente si registra, viene inviata un'email di conferma. Quale tipo di test double è più appropriato per <code>EmailService</code>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q6" id="q6a" value="a">
                            <label for="q6a"><strong>Stub</strong> - configuro EmailService per ritornare <code>true</code> quando chiamato</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q6" id="q6b" value="b">
                            <label for="q6b"><strong>Mock</strong> - verifico che <code>emailService.send()</code> sia stato chiamato con i parametri corretti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q6" id="q6c" value="c">
                            <label for="q6c"><strong>Fake</strong> - uso un'implementazione in-memory che salva le email in una lista</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q6" id="q6d" value="d">
                            <label for="q6d"><strong>Spy</strong> - avvolgo il vero EmailService per tracciare le chiamate senza mockare</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q6')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q6"></div>
                </div>

                <!-- Question 7 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sulla Test Pyramid è CORRETTA?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q7" id="q7a" value="a">
                            <label for="q7a">I test E2E dovrebbero coprire il 70-80% della codebase perché verificano il comportamento reale dell'utente</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q7" id="q7b" value="b">
                            <label for="q7b">Gli Integration Test sono più affidabili degli Unit Test perché non usano mock</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q7" id="q7c" value="c">
                            <label for="q7c">I test E2E sono più "flaky" (instabili) perché dipendono da più componenti e fattori esterni</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q7" id="q7d" value="d">
                            <label for="q7d">Nel TDD, tutti i test devono essere scritti prima di iniziare a scrivere codice di produzione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q7')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q7"></div>
                </div>

                <!-- Question 8 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Stai testando un <code>PaymentService</code> che chiama un gateway esterno. Il test deve verificare che venga applicato un retry in caso di fallimento temporaneo. Qual è l'approccio migliore?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q9" id="q9a" value="a">
                            <label for="q9a">Uso un Mock del gateway che fallisce le prime 2 chiamate e poi succede, verificando che <code>process()</code> sia chiamato 3 volte</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q9" id="q9b" value="b">
                            <label for="q9b">Uso un test E2E con un gateway di staging che simula fallimenti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q9" id="q9c" value="c">
                            <label for="q9c">Uso uno Stub che ritorna sempre successo, verificando solo il risultato finale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q9" id="q9d" value="d">
                            <label for="q9d">Non è possibile testare la retry logic in modo isolato, serve sempre un Integration Test</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q9')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q9"></div>
                </div>

                <!-- Question 10 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q4.</span> Quale test ha la maggior probabilità di essere "flaky" (fallire in modo intermittente)?</h4>
                    <pre><code class="language-java">// Test A
@Test void testA() {
    when(repo.findById(1L)).thenReturn(Optional.of(user));
    assertThat(service.getUser(1L)).isEqualTo(user);
}

// Test B
@Test void testB() {
    User saved = userRepository.save(new User("test@mail.com"));
    await().atMost(5, SECONDS).until(() ->
        searchService.findByEmail("test@mail.com") != null);
}

// Test C
@Test void testC() {
    assertThat(calculator.add(2, 3)).isEqualTo(5);
}

// Test D
@Test void testD() {
    User user = userRepository.save(new User("mario"));
    assertThat(userRepository.findById(user.getId())).isPresent();
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q10" id="q10a" value="a">
                            <label for="q10a">Test A - perché usa mock che potrebbero non corrispondere alla realtà</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q10" id="q10b" value="b">
                            <label for="q10b">Test B - perché dipende da timing/eventual consistency con <code>await()</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q10" id="q10c" value="c">
                            <label for="q10c">Test C - perché i calcoli matematici possono avere problemi di floating point</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q10" id="q10d" value="d">
                            <label for="q10d">Test D - perché l'ID generato potrebbe collidere con dati esistenti</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q10')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q10"></div>
                </div>
            </section>

            <!-- ==================== MODULO 3: ARCHITETTURA & SCALABILITÀ ==================== -->

            <header class="module-header" id="modulo3" style="margin-top: 80px;">
                <span class="module-tag">Modulo 3</span>
                <h1>Architettura & Scalabilità</h1>
                <p>Pattern architetturali, resilienza e strategie per sistemi distribuiti ad alta disponibilità</p>
            </header>

            <!-- Monolith vs Microservices Section -->
            <section class="section" id="modulo3-monolith-micro">
                <h2>Monoliti vs Microservizi</h2>

                <p>La scelta tra architettura monolitica e microservizi è una delle decisioni più importanti nella progettazione di un sistema. Non esiste una risposta universale: dipende dal contesto, dal team e dalla fase del prodotto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MONOLITH vs MICROSERVICES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   MONOLITH                              MICROSERVICES                       │
│   ────────                              ─────────────                       │
│                                                                             │
│   ┌─────────────────────┐               ┌───────┐ ┌───────┐ ┌───────┐      │
│   │                     │               │ User  │ │ Order │ │ Pay   │      │
│   │   ┌─────────────┐   │               │Service│ │Service│ │Service│      │
│   │   │   Web UI    │   │               └───┬───┘ └───┬───┘ └───┬───┘      │
│   │   └─────────────┘   │                   │         │         │          │
│   │   ┌─────────────┐   │                   │    ┌────┴────┐    │          │
│   │   │  Business   │   │                   └────┤ Message ├────┘          │
│   │   │   Logic     │   │                        │  Broker │               │
│   │   └─────────────┘   │                        └────┬────┘               │
│   │   ┌─────────────┐   │               ┌───────┐ ┌───┴───┐ ┌───────┐      │
│   │   │  Data Layer │   │               │  DB   │ │  DB   │ │  DB   │      │
│   │   └─────────────┘   │               │ User  │ │ Order │ │ Pay   │      │
│   │                     │               └───────┘ └───────┘ └───────┘      │
│   └──────────┬──────────┘                                                  │
│              │                                                             │
│        ┌─────┴─────┐                                                       │
│        │    DB     │                                                       │
│        └───────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Monolith: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Semplicità di sviluppo e deploy</td>
                            <td>Scaling solo verticale (o replica intera)</td>
                        </tr>
                        <tr>
                            <td>Transazioni ACID semplici</td>
                            <td>Codebase che cresce e diventa ingestibile</td>
                        </tr>
                        <tr>
                            <td>Debugging e tracing più facile</td>
                            <td>Un bug può bloccare tutto il sistema</td>
                        </tr>
                        <tr>
                            <td>Nessun overhead di rete interno</td>
                            <td>Technology lock-in (un solo stack)</td>
                        </tr>
                        <tr>
                            <td>Team piccoli, startup, MVP</td>
                            <td>Deploy richiede rilascio di tutto</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Microservices: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Scaling indipendente per servizio</td>
                            <td>Complessità operativa elevata</td>
                        </tr>
                        <tr>
                            <td>Deploy indipendenti</td>
                            <td>Latenza di rete tra servizi</td>
                        </tr>
                        <tr>
                            <td>Fault isolation (un servizio fallisce, altri continuano)</td>
                            <td>Transazioni distribuite complesse (Saga pattern)</td>
                        </tr>
                        <tr>
                            <td>Team autonomi, ownership chiara</td>
                            <td>Debugging distribuito difficile</td>
                        </tr>
                        <tr>
                            <td>Polyglot (linguaggi/DB diversi)</td>
                            <td>Overhead: service discovery, API gateway, observability</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box warning">
                    <h4>Domanda trabocchetto ai colloqui</h4>
                    <p>"Quando useresti i microservizi?"<br><br>
                    <strong>Risposta NON banale:</strong> Non "quando l'applicazione è grande". I microservizi sono giustificati quando hai: (1) team multipli che devono lavorare indipendentemente, (2) parti del sistema con requisiti di scaling molto diversi, (3) necessità di deploy frequenti e indipendenti, (4) volontà di investire in infrastruttura (CI/CD, monitoring, service mesh). Per una startup o un MVP, un monolite ben strutturato è quasi sempre la scelta migliore.</p>
                </div>

                <h3>Modular Monolith: Il compromesso</h3>

                <p>Un <strong>Modular Monolith</strong> combina i vantaggi di entrambi: deploy singolo ma con boundaries chiari tra moduli, preparando una futura migrazione a microservizi se necessario.</p>

                <pre><code class="language-java">// Struttura Modular Monolith
com.myapp/
├── user/
│   ├── api/           // Interfacce pubbliche del modulo
│   │   └── UserApi.java
│   ├── internal/      // Implementazione (package-private)
│   │   ├── UserService.java
│   │   └── UserRepository.java
│   └── UserModule.java
├── order/
│   ├── api/
│   │   └── OrderApi.java
│   ├── internal/
│   │   ├── OrderService.java
│   │   └── OrderRepository.java
│   └── OrderModule.java
└── payment/
    └── ...

// Regola: i moduli comunicano SOLO tramite API pubbliche
// MAI accesso diretto a classi internal di altri moduli

// ArchUnit test per enforcare i boundaries
@Test
void modulesShouldNotDependOnInternalPackages() {
    classes()
        .that().resideInAPackage("..order..")
        .should().onlyAccessClassesThat()
        .resideOutsideOfPackage("..user.internal..")
        .check(importedClasses);
}</code></pre>
            </section>

            <!-- Resilience Patterns Section -->
            <section class="section" id="modulo3-resilience">
                <h2>Resilience Patterns</h2>

                <p>Nei sistemi distribuiti, i fallimenti sono inevitabili. I pattern di resilienza permettono al sistema di degradare gracefully invece di fallire completamente.</p>

                <h3>Circuit Breaker Pattern</h3>

                <p>Il <strong>Circuit Breaker</strong> previene chiamate ripetute a un servizio che sta fallendo, permettendogli di recuperare e proteggendo il sistema da cascade failures.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      CIRCUIT BREAKER STATE MACHINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌─────────────────┐                                 │
│                         │                 │                                 │
│     Failure threshold   │     CLOSED      │   Normal operation              │
│     reached             │   (allowing)    │   Requests pass through         │
│          ┌──────────────│                 │                                 │
│          │              └────────┬────────┘                                 │
│          │                       │                                          │
│          │                       │ Success                                  │
│          │                       │ (reset counter)                          │
│          │                       │                                          │
│          ▼                       │                                          │
│   ┌──────────────┐               │                                          │
│   │              │               │                                          │
│   │    OPEN      │───────────────┘                                          │
│   │  (blocking)  │                                                          │
│   │              │   Timeout expires                                        │
│   └──────┬───────┘   (e.g., 30 seconds)                                     │
│          │                                                                  │
│          │                                                                  │
│          ▼                                                                  │
│   ┌──────────────┐                                                          │
│   │              │                                                          │
│   │  HALF-OPEN   │   Allow limited requests                                 │
│   │  (testing)   │   to test if service recovered                           │
│   │              │                                                          │
│   └──────┬───────┘                                                          │
│          │                                                                  │
│    ┌─────┴─────┐                                                            │
│    │           │                                                            │
│    ▼           ▼                                                            │
│ Success     Failure                                                         │
│    │           │                                                            │
│    │           └──────► Back to OPEN                                        │
│    │                                                                        │
│    └──────────────────► Back to CLOSED                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Implementazione con Resilience4j
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)           // Apre se 50% fallimenti
            .slowCallRateThreshold(50)          // Apre se 50% chiamate lente
            .slowCallDurationThreshold(Duration.ofSeconds(2))
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .permittedNumberOfCallsInHalfOpenState(5)
            .slidingWindowSize(10)              // Ultimi 10 risultati
            .slidingWindowType(SlidingWindowType.COUNT_BASED)
            .build();

        return CircuitBreakerRegistry.of(config);
    }
}

@Service
public class PaymentService {

    private final CircuitBreaker circuitBreaker;
    private final PaymentGateway paymentGateway;

    public PaymentService(CircuitBreakerRegistry registry, PaymentGateway gateway) {
        this.circuitBreaker = registry.circuitBreaker("paymentGateway");
        this.paymentGateway = gateway;
    }

    public PaymentResult processPayment(PaymentRequest request) {
        return circuitBreaker.executeSupplier(() ->
            paymentGateway.process(request)
        );

        // Oppure con fallback
        return CircuitBreaker.decorateSupplier(circuitBreaker,
            () -> paymentGateway.process(request))
            .recover(CallNotPermittedException.class,
                e -> PaymentResult.serviceUnavailable())
            .recover(TimeoutException.class,
                e -> PaymentResult.timeout())
            .get();
    }
}

// Con annotation (Spring Boot + resilience4j-spring-boot2)
@Service
public class PaymentService {

    @CircuitBreaker(name = "paymentGateway", fallbackMethod = "fallbackPayment")
    public PaymentResult processPayment(PaymentRequest request) {
        return paymentGateway.process(request);
    }

    private PaymentResult fallbackPayment(PaymentRequest request, Exception e) {
        log.warn("Payment gateway unavailable, using fallback", e);
        return PaymentResult.queued(); // Metti in coda per retry successivo
    }
}</code></pre>

                <h3>Bulkhead Pattern</h3>

                <p>Il <strong>Bulkhead</strong> (paratia) isola le risorse tra diversi tipi di chiamate, prevenendo che un singolo servizio lento esaurisca tutte le risorse.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         BULKHEAD PATTERN                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SENZA BULKHEAD                    CON BULKHEAD                            │
│   ──────────────                    ────────────                            │
│                                                                             │
│   ┌─────────────────────┐           ┌─────────────────────┐                 │
│   │   Thread Pool (20)  │           │    Order Service    │                 │
│   │                     │           │   Thread Pool (10)  │                 │
│   │ ████████████████████│           │   ██████████        │                 │
│   │ (all used by slow   │           └─────────────────────┘                 │
│   │  Payment service)   │                                                   │
│   │                     │           ┌─────────────────────┐                 │
│   │ Other services      │           │   Payment Service   │                 │
│   │ BLOCKED! ⛔         │           │   Thread Pool (5)   │                 │
│   └─────────────────────┘           │   █████ (saturated) │                 │
│                                     └─────────────────────┘                 │
│   Se Payment è lento,                                                       │
│   TUTTO si blocca                   ┌─────────────────────┐                 │
│                                     │   User Service      │                 │
│                                     │   Thread Pool (5)   │                 │
│                                     │   ██                │ ← Still works!  │
│                                     └─────────────────────┘                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Bulkhead con Resilience4j
@Service
public class OrderService {

    @Bulkhead(name = "orderService", type = Bulkhead.Type.THREADPOOL)
    public CompletableFuture&lt;Order&gt; createOrderAsync(OrderRequest request) {
        return CompletableFuture.supplyAsync(() -> processOrder(request));
    }

    @Bulkhead(name = "orderService", type = Bulkhead.Type.SEMAPHORE,
              fallbackMethod = "fallbackCreateOrder")
    public Order createOrder(OrderRequest request) {
        return processOrder(request);
    }

    private Order fallbackCreateOrder(OrderRequest request, BulkheadFullException e) {
        throw new ServiceOverloadedException("Order service is overloaded, try again later");
    }
}

// application.yml
resilience4j:
  bulkhead:
    instances:
      orderService:
        maxConcurrentCalls: 20          # Semaphore bulkhead
        maxWaitDuration: 500ms
  thread-pool-bulkhead:
    instances:
      orderService:
        maxThreadPoolSize: 10           # Thread pool bulkhead
        coreThreadPoolSize: 5
        queueCapacity: 20</code></pre>

                <h3>Retry Pattern con Exponential Backoff</h3>

                <pre><code class="language-java">// Retry con Resilience4j
@Service
public class ExternalApiService {

    @Retry(name = "externalApi", fallbackMethod = "fallback")
    public Response callExternalApi(Request request) {
        return externalClient.call(request);
    }

    private Response fallback(Request request, Exception e) {
        log.error("All retries failed for request: {}", request, e);
        throw new ExternalServiceException("Service unavailable after retries", e);
    }
}

// application.yml
resilience4j:
  retry:
    instances:
      externalApi:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2    # 1s, 2s, 4s
        retryExceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:
          - com.myapp.BusinessException     # Non ritentare errori business</code></pre>

                <h3>Timeout Pattern</h3>

                <pre><code class="language-java">// Timeout con Resilience4j
@Service
public class SlowService {

    @TimeLimiter(name = "slowService", fallbackMethod = "timeoutFallback")
    public CompletableFuture&lt;Result&gt; slowOperation() {
        return CompletableFuture.supplyAsync(() -> {
            // Operazione potenzialmente lenta
            return performSlowOperation();
        });
    }

    private CompletableFuture&lt;Result&gt; timeoutFallback(TimeoutException e) {
        return CompletableFuture.completedFuture(Result.timeout());
    }
}

// application.yml
resilience4j:
  timelimiter:
    instances:
      slowService:
        timeoutDuration: 5s
        cancelRunningFuture: true</code></pre>

                <div class="info-box success">
                    <h4>Combinare i pattern</h4>
                    <p>I pattern di resilienza si combinano spesso insieme. L'ordine tipico è:<br>
                    <code>Retry → CircuitBreaker → Bulkhead → TimeLimiter</code><br><br>
                    Con Resilience4j puoi stackare le annotation:</p>
                </div>

                <pre><code class="language-java">@CircuitBreaker(name = "backend")
@Bulkhead(name = "backend")
@Retry(name = "backend")
@TimeLimiter(name = "backend")
public CompletableFuture&lt;Response&gt; callBackend(Request request) {
    return CompletableFuture.supplyAsync(() -> backendClient.call(request));
}</code></pre>
            </section>

            <!-- CAP Theorem Section -->
            <section class="section" id="modulo3-cap">
                <h2>CAP Theorem</h2>

                <p>Il <strong>CAP Theorem</strong> (Brewer's Theorem) afferma che un sistema distribuito può garantire al massimo <strong>due</strong> delle seguenti tre proprietà contemporaneamente.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                            CAP THEOREM                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          CONSISTENCY                                        │
│                              (C)                                            │
│                               ▲                                             │
│                              ╱ ╲                                            │
│                             ╱   ╲                                           │
│                            ╱     ╲                                          │
│                           ╱       ╲                                         │
│                          ╱   CA    ╲                                        │
│                         ╱  (RDBMS)  ╲                                       │
│                        ╱  Single node╲                                      │
│                       ╱───────────────╲                                     │
│                      ╱                 ╲                                    │
│                     ╱        CP         ╲                                   │
│                    ╱    (MongoDB,        ╲                                  │
│                   ╱      HBase,           ╲                                 │
│                  ╱       Redis Cluster)    ╲                                │
│                 ╱─────────────────────────────╲                             │
│                ╱                               ╲                            │
│               ╱             AP                  ╲                           │
│              ╱        (Cassandra,                ╲                          │
│             ╱          DynamoDB,                  ╲                         │
│            ╱           CouchDB)                    ╲                        │
│           ▼─────────────────────────────────────────▼                       │
│     AVAILABILITY                              PARTITION                     │
│         (A)                                   TOLERANCE                     │
│                                                  (P)                        │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   C - Consistency: Ogni lettura riceve la scrittura più recente             │
│                    (o un errore)                                            │
│                                                                             │
│   A - Availability: Ogni richiesta riceve una risposta                      │
│                     (non necessariamente i dati più recenti)                │
│                                                                             │
│   P - Partition Tolerance: Il sistema continua a funzionare                 │
│                            nonostante perdita di messaggi tra nodi          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box warning">
                    <h4>Interpretazione corretta del CAP</h4>
                    <p>Il CAP theorem è spesso frainteso. In un sistema distribuito reale, le <strong>partition</strong> (network failure) ACCADONO. Quindi la vera scelta è tra <strong>CP</strong> e <strong>AP</strong> durante una partition:<br><br>
                    <strong>CP</strong>: Durante una partition, rifiuta le richieste per garantire consistency<br>
                    <strong>AP</strong>: Durante una partition, continua a servire richieste (possibilmente dati stale)</p>
                </div>

                <h3>PACELC: Estensione del CAP</h3>

                <p>Il modello <strong>PACELC</strong> estende il CAP: se c'è una Partition (P), scegli tra Availability e Consistency (AC); Else (E), quando il sistema funziona normalmente, scegli tra Latency e Consistency (LC).</p>

                <table>
                    <thead>
                        <tr>
                            <th>Sistema</th>
                            <th>Durante Partition (PAC)</th>
                            <th>Else (ELC)</th>
                            <th>Classificazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>DynamoDB, Cassandra</td>
                            <td>Availability</td>
                            <td>Latency</td>
                            <td>PA/EL</td>
                        </tr>
                        <tr>
                            <td>MongoDB, HBase</td>
                            <td>Consistency</td>
                            <td>Consistency</td>
                            <td>PC/EC</td>
                        </tr>
                        <tr>
                            <td>PNUTS (Yahoo)</td>
                            <td>Consistency</td>
                            <td>Latency</td>
                            <td>PC/EL</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Consistency Models</h3>

                <pre><code class="language-java">// Strong Consistency (CP systems)
// Ogni lettura vede l'ultima scrittura
// Esempio: transazione bancaria
public void transfer(Account from, Account to, BigDecimal amount) {
    // DEVE essere consistente - non possiamo avere soldi "persi"
    transactionTemplate.execute(status -> {
        from.debit(amount);
        to.credit(amount);
        return null;
    });
}

// Eventual Consistency (AP systems)
// Le letture potrebbero vedere dati stale, ma convergeranno
// Esempio: contatore like su un social network
public void incrementLikes(String postId) {
    // Okay se per qualche secondo utenti diversi vedono conteggi diversi
    cassandraTemplate.update(
        Query.query(where("id").is(postId)),
        Update.update("likes", QueryBuilder.incr())
    );
}

// Read-your-writes Consistency
// Garantisce che TU veda le TUE scritture
// Esempio: aggiornamento profilo utente
@Service
public class ProfileService {
    public Profile updateProfile(String userId, ProfileUpdate update) {
        Profile updated = repository.save(update);
        // Forza la lettura dal primary per questo utente
        sessionCache.put(userId, updated);
        return updated;
    }

    public Profile getProfile(String userId, String requestingUserId) {
        if (userId.equals(requestingUserId)) {
            // Utente che legge il proprio profilo - usa cache/primary
            return sessionCache.getOrDefault(userId,
                () -> repository.findByIdFromPrimary(userId));
        }
        // Altri utenti - eventual consistency ok
        return repository.findById(userId);
    }
}</code></pre>
            </section>

            <!-- Load Balancing Section -->
            <section class="section" id="modulo3-loadbalancing">
                <h2>Load Balancing</h2>

                <p>Il <strong>Load Balancing</strong> distribuisce il traffico tra multiple istanze di un servizio per migliorare availability, throughput e latenza.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                       LOAD BALANCING STRATEGIES                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. ROUND ROBIN                                                            │
│   ──────────────                                                            │
│                                                                             │
│   Request 1 ──────► Server A                                                │
│   Request 2 ──────► Server B                                                │
│   Request 3 ──────► Server C                                                │
│   Request 4 ──────► Server A  (ricomincia)                                  │
│                                                                             │
│   Pro: Semplice, distribuzione equa                                         │
│   Contro: Non considera il carico effettivo dei server                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. LEAST CONNECTIONS                                                      │
│   ────────────────────                                                      │
│                                                                             │
│   Server A: 5 connections  ◄────── Request (va qui, meno connessioni)       │
│   Server B: 12 connections                                                  │
│   Server C: 8 connections                                                   │
│                                                                             │
│   Pro: Adatta al carico reale                                               │
│   Contro: Non considera la "pesantezza" delle connessioni                   │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WEIGHTED ROUND ROBIN                                                   │
│   ────────────────────────                                                  │
│                                                                             │
│   Server A (weight=5): riceve 5 richieste                                   │
│   Server B (weight=3): riceve 3 richieste  } ogni 10 richieste              │
│   Server C (weight=2): riceve 2 richieste                                   │
│                                                                             │
│   Pro: Server più potenti ricevono più traffico                             │
│   Contro: Richiede configurazione manuale dei pesi                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   4. CONSISTENT HASHING                                                     │
│   ──────────────────────                                                    │
│                                                                             │
│                    ┌───────────────────┐                                    │
│                   ╱                     ╲                                   │
│                  ╱    Hash Ring          ╲                                  │
│                 │                         │                                 │
│                 │  A ●         ● B        │                                 │
│                 │       user123           │                                 │
│                 │          ↓              │                                 │
│                 │      ● C    ● D         │                                 │
│                  ╲                       ╱                                  │
│                   ╲                     ╱                                   │
│                    └───────────────────┘                                    │
│                                                                             │
│   user123 → hash → posizione sul ring → server più vicino (in senso orario)│
│                                                                             │
│   Pro: Aggiunta/rimozione server sposta solo 1/n delle chiavi              │
│   Contro: Possibile distribuzione non uniforme (risolto con virtual nodes) │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>L4 vs L7 Load Balancing</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>L4 (Transport Layer)</th>
                            <th>L7 (Application Layer)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Opera su</strong></td>
                            <td>TCP/UDP (IP + porta)</td>
                            <td>HTTP/HTTPS (headers, path, cookies)</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Molto alta (no parsing)</td>
                            <td>Più bassa (deve parsare HTTP)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Solo per IP/porta</td>
                            <td>Per path, header, cookie, ecc.</td>
                        </tr>
                        <tr>
                            <td><strong>SSL Termination</strong></td>
                            <td>No (passa attraverso)</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><strong>Esempi</strong></td>
                            <td>AWS NLB, HAProxy (TCP mode)</td>
                            <td>AWS ALB, Nginx, HAProxy (HTTP mode)</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Client-side load balancing con Spring Cloud LoadBalancer
@Configuration
public class LoadBalancerConfig {

    @Bean
    @LoadBalanced  // Abilita load balancing su RestTemplate
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    private final RestTemplate restTemplate;

    public User getUser(Long userId) {
        // "user-service" è il nome del servizio in service discovery
        // Spring risolve automaticamente a un'istanza disponibile
        return restTemplate.getForObject(
            "http://user-service/api/users/{id}",
            User.class,
            userId
        );
    }
}

// Custom load balancer con Spring Cloud LoadBalancer
@Configuration
public class CustomLoadBalancerConfig {

    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; customLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new RoundRobinLoadBalancer(supplier, "user-service");
    }

    // Oppure implementazione custom
    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; weightedLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new ReactorServiceInstanceLoadBalancer() {
            @Override
            public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) {
                return supplier.get()
                    .next()
                    .map(instances -> {
                        // Logica custom: scegli in base a weight nei metadata
                        ServiceInstance chosen = selectByWeight(instances);
                        return new DefaultResponse(chosen);
                    });
            }
        };
    }
}</code></pre>
            </section>

            <!-- Caching Section -->
            <section class="section" id="modulo3-caching">
                <h2>Caching Strategies</h2>

                <p>Il <strong>Caching</strong> è fondamentale per la scalabilità. Una cache ben progettata può ridurre il carico sul database di ordini di grandezza e migliorare drasticamente la latency.</p>

                <h3>Caching Patterns</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CACHING PATTERNS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. CACHE-ASIDE (Lazy Loading)                                             │
│   ─────────────────────────────                                             │
│                                                                             │
│   ┌─────────┐      1. Get        ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      2. Miss       └─────────┘                                │
│   │         │                                                               │
│   │         │      3. Get        ┌─────────┐                                │
│   │         │─────────────────►│   DB    │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      4. Return     └─────────┘                                │
│   │         │                                                               │
│   │         │      5. Put        ┌─────────┐                                │
│   │         │─────────────────►│  Cache  │                                 │
│   └─────────┘                    └─────────┘                                │
│                                                                             │
│   Pro: Solo dati richiesti in cache, resiliente a cache failure             │
│   Contro: Cache miss penalty, possibile stale data                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. WRITE-THROUGH                                                          │
│   ────────────────                                                          │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐      2. Write   ┌─────────┐   │
│   │   App   │─────────────────►│  Cache  │───────────────►│   DB    │    │
│   │         │◄─────────────────│         │◄───────────────│         │    │
│   └─────────┘      4. ACK        └─────────┘      3. ACK     └─────────┘   │
│                                                                             │
│   Pro: Cache sempre consistente con DB                                      │
│   Contro: Latenza scrittura alta (2 write sincrone)                         │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WRITE-BEHIND (Write-Back)                                              │
│   ────────────────────────────                                              │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   └─────────┘      2. ACK        │         │                                │
│                     (immediato)  │         │      3. Async    ┌─────────┐   │
│                                  │         │      batch write │   DB    │   │
│                                  │         │─────────────────►│         │   │
│                                  └─────────┘                  └─────────┘   │
│                                                                             │
│   Pro: Latenza scrittura bassa, batch writes                                │
│   Contro: Rischio perdita dati se cache crasha prima del flush              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Cache Invalidation Strategies</h3>

                <pre><code class="language-java">// 1. TTL-based expiration
@Cacheable(value = "users", key = "#userId")
@CacheConfig(cacheNames = "users")
public User getUser(Long userId) {
    return userRepository.findById(userId).orElseThrow();
}

// application.yml - TTL configuration
spring:
  cache:
    type: redis
    redis:
      time-to-live: 3600000  # 1 ora in millisecondi

// 2. Event-driven invalidation
@Service
public class UserService {

    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        User updated = userRepository.save(user);
        // Pubblica evento per invalidare cache su altri nodi
        eventPublisher.publish(new UserUpdatedEvent(user.getId()));
        return updated;
    }
}

@Component
public class CacheInvalidationListener {

    @EventListener
    public void onUserUpdated(UserUpdatedEvent event) {
        cacheManager.getCache("users").evict(event.getUserId());
    }
}

// 3. Cache versioning (per invalidazione di massa)
@Service
public class ProductCatalogService {

    private final AtomicLong catalogVersion = new AtomicLong(0);

    @Cacheable(value = "products", key = "#productId + '-' + @productCatalogService.catalogVersion")
    public Product getProduct(Long productId) {
        return productRepository.findById(productId).orElseThrow();
    }

    public void refreshCatalog() {
        catalogVersion.incrementAndGet();  // Invalida tutte le entry
    }

    public long getCatalogVersion() {
        return catalogVersion.get();
    }
}</code></pre>

                <h3>Redis vs Memcached</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Redis</th>
                            <th>Memcached</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data structures</strong></td>
                            <td>String, List, Set, Hash, Sorted Set, Stream</td>
                            <td>Solo String (key-value)</td>
                        </tr>
                        <tr>
                            <td><strong>Persistence</strong></td>
                            <td>RDB snapshots, AOF log</td>
                            <td>No (solo in-memory)</td>
                        </tr>
                        <tr>
                            <td><strong>Replication</strong></td>
                            <td>Master-replica, Redis Cluster</td>
                            <td>No built-in</td>
                        </tr>
                        <tr>
                            <td><strong>Pub/Sub</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Lua scripting</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Memory efficiency</strong></td>
                            <td>Moderata (overhead strutture dati)</td>
                            <td>Alta (slab allocator ottimizzato)</td>
                        </tr>
                        <tr>
                            <td><strong>Use case ideale</strong></td>
                            <td>Cache + session + queue + leaderboard</td>
                            <td>Simple caching ad alto throughput</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Distributed locking con Redis (Redisson)
@Service
public class InventoryService {

    private final RedissonClient redisson;

    public boolean reserveStock(String productId, int quantity) {
        RLock lock = redisson.getLock("inventory:" + productId);

        try {
            // Acquisisce lock con timeout
            if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                try {
                    int currentStock = getStock(productId);
                    if (currentStock >= quantity) {
                        updateStock(productId, currentStock - quantity);
                        return true;
                    }
                    return false;
                } finally {
                    lock.unlock();
                }
            }
            throw new LockAcquisitionException("Could not acquire lock");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}

// Rate limiting con Redis
@Service
public class RateLimiter {

    private final StringRedisTemplate redis;

    public boolean isAllowed(String userId, int maxRequests, Duration window) {
        String key = "ratelimit:" + userId;
        long now = System.currentTimeMillis();
        long windowStart = now - window.toMillis();

        // Sliding window log algorithm
        redis.opsForZSet().removeRangeByScore(key, 0, windowStart);

        Long count = redis.opsForZSet().zCard(key);
        if (count != null && count >= maxRequests) {
            return false;
        }

        redis.opsForZSet().add(key, String.valueOf(now), now);
        redis.expire(key, window);
        return true;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Cache Stampede (Thundering Herd)</h4>
                    <p>Quando una chiave popolare scade, molte richieste simultanee potrebbero tutte andare al DB. Soluzioni:<br><br>
                    1. <strong>Locking</strong>: Solo una richiesta rigenera la cache<br>
                    2. <strong>Probabilistic early expiration</strong>: Rigenera prima della scadenza<br>
                    3. <strong>Background refresh</strong>: Thread separato che aggiorna la cache</p>
                </div>
            </section>

            <!-- Quiz Section Module 3 -->
            <section class="quiz-section" id="modulo3-quiz">
                <h2>Interactive Challenge Quiz - Architettura</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di architettura e scalabilità.</p>

                <!-- Question 11 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un Circuit Breaker è nello stato HALF-OPEN. Cosa succede se la prossima richiesta fallisce?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q11" id="q11a" value="a">
                            <label for="q11a">Rimane in HALF-OPEN e permette un'altra richiesta di test</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q11" id="q11b" value="b">
                            <label for="q11b">Torna in CLOSED perché ha già aspettato abbastanza</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q11" id="q11c" value="c">
                            <label for="q11c">Torna in OPEN e ricomincia il timeout</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q11" id="q11d" value="d">
                            <label for="q11d">Entra in uno stato DISABLED permanente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q11')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q11"></div>
                </div>

                <!-- Question 12 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Secondo il CAP theorem, durante una network partition, un sistema che sceglie <strong>Availability</strong> su <strong>Consistency</strong>...</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q12" id="q12a" value="a">
                            <label for="q12a">Rifiuta tutte le scritture ma permette le letture</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q12" id="q12b" value="b">
                            <label for="q12b">Continua a servire richieste, anche se i dati potrebbero essere stale o divergenti tra nodi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q12" id="q12c" value="c">
                            <label for="q12c">Blocca tutte le richieste finché la partition non si risolve</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q12" id="q12d" value="d">
                            <label for="q12d">Elegge automaticamente un nuovo leader per mantenere consistency</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q12')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q12"></div>
                </div>

                <!-- Question 13 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Quale caching pattern è più appropriato per un sistema dove la latenza di scrittura è critica e una piccola perdita di dati in caso di crash è accettabile?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q13" id="q13a" value="a">
                            <label for="q13a"><strong>Write-Behind</strong> - scrive in cache e poi asincronamente al DB</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q13" id="q13b" value="b">
                            <label for="q13b"><strong>Write-Through</strong> - scrive sincronamente sia in cache che DB</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q13" id="q13c" value="c">
                            <label for="q13c"><strong>Cache-Aside</strong> - l'applicazione gestisce manualmente cache e DB</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q13" id="q13d" value="d">
                            <label for="q13d"><strong>Read-Through</strong> - la cache carica automaticamente dal DB</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q13')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q13"></div>
                </div>

                <!-- Question 14 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Perché il Consistent Hashing è preferito al semplice hash modulo N per il load balancing di cache distribuite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q14" id="q14a" value="a">
                            <label for="q14a">Perché è più veloce da calcolare</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q14" id="q14b" value="b">
                            <label for="q14b">Perché garantisce una distribuzione perfettamente uniforme</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q14" id="q14c" value="c">
                            <label for="q14c">Perché supporta più tipi di dati rispetto all'hash tradizionale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q14" id="q14d" value="d">
                            <label for="q14d">Perché quando si aggiunge/rimuove un nodo, solo una frazione delle chiavi deve essere rimappata</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q14')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q14"></div>
                </div>

                <!-- Question 15 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Un team sta decidendo tra microservizi e monolite per una nuova startup. Quale fattore dovrebbe pesare di PIÙ verso la scelta del monolite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q15" id="q15a" value="a">
                            <label for="q15a">L'applicazione avrà milioni di utenti</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q15" id="q15b" value="b">
                            <label for="q15b">Il team ha esperienza con Kubernetes</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q15" id="q15c" value="c">
                            <label for="q15c">Il dominio di business non è ancora ben definito e cambierà frequentemente</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q15" id="q15d" value="d">
                            <label for="q15d">Diverse parti del sistema avranno requisiti di scaling molto diversi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q15')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q15"></div>
                </div>
            </section>

            <!-- ==================== MODULO 4: DATABASE & MESSAGING ==================== -->

            <header class="module-header" id="modulo4" style="margin-top: 80px;">
                <span class="module-tag">Modulo 4</span>
                <h1>Database & Messaging</h1>
                <p>SQL vs NoSQL, event streaming con Kafka, message broker con RabbitMQ</p>
            </header>

            <!-- SQL vs NoSQL Section -->
            <section class="section" id="modulo4-sql-nosql">
                <h2>SQL vs NoSQL</h2>

                <p>La scelta tra database relazionali (SQL) e non relazionali (NoSQL) dipende dai requisiti specifici dell'applicazione. Non esiste una soluzione universalmente migliore.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         DATABASE LANDSCAPE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SQL (Relational)                  NoSQL                                   │
│   ────────────────                  ─────                                   │
│                                                                             │
│   ┌─────────────────┐               ┌─────────────────┐                     │
│   │   PostgreSQL    │               │   Document DB   │                     │
│   │   MySQL         │               │   ─────────────  │                     │
│   │   Oracle        │               │   MongoDB       │                     │
│   │   SQL Server    │               │   CouchDB       │                     │
│   └─────────────────┘               └─────────────────┘                     │
│                                                                             │
│   Structured data                   ┌─────────────────┐                     │
│   ACID transactions                 │   Key-Value     │                     │
│   Complex queries/joins             │   ───────────   │                     │
│   Strong consistency                │   Redis         │                     │
│                                     │   DynamoDB      │                     │
│                                     │   Memcached     │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Wide-Column   │                     │
│                                     │   ────────────  │                     │
│                                     │   Cassandra     │                     │
│                                     │   HBase         │                     │
│                                     │   ScyllaDB      │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Graph DB      │                     │
│                                     │   ────────────  │                     │
│                                     │   Neo4j         │                     │
│                                     │   Amazon Neptune│                     │
│                                     └─────────────────┘                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Confronto dettagliato</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>SQL</th>
                            <th>NoSQL</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Schema</strong></td>
                            <td>Rigido, predefinito</td>
                            <td>Flessibile, schema-on-read</td>
                        </tr>
                        <tr>
                            <td><strong>Scaling</strong></td>
                            <td>Verticale (scale-up)</td>
                            <td>Orizzontale (scale-out)</td>
                        </tr>
                        <tr>
                            <td><strong>Transactions</strong></td>
                            <td>ACID garantito</td>
                            <td>BASE (eventual consistency) o ACID limitato</td>
                        </tr>
                        <tr>
                            <td><strong>Query</strong></td>
                            <td>SQL standard, JOIN potenti</td>
                            <td>Query language specifico, no JOIN (o limitati)</td>
                        </tr>
                        <tr>
                            <td><strong>Data model</strong></td>
                            <td>Tabelle normalizzate</td>
                            <td>Denormalizzato, ottimizzato per access pattern</td>
                        </tr>
                        <tr>
                            <td><strong>Use cases</strong></td>
                            <td>OLTP, dati strutturati, relazioni complesse</td>
                            <td>Big data, real-time, dati semi-strutturati</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>ACID vs BASE</h4>
                    <p><strong>ACID</strong>: Atomicity, Consistency, Isolation, Durability - garanzie forti, tipiche dei database SQL.<br><br>
                    <strong>BASE</strong>: Basically Available, Soft state, Eventually consistent - modello più rilassato dei database NoSQL distribuiti, che privilegia availability e partition tolerance.</p>
                </div>

                <h3>Quando usare cosa</h3>

                <pre><code class="language-java">// SQL - Ideale per:
// 1. Transazioni finanziarie (ACID critico)
@Transactional
public void transferMoney(Long fromAccount, Long toAccount, BigDecimal amount) {
    Account from = accountRepository.findById(fromAccount).orElseThrow();
    Account to = accountRepository.findById(toAccount).orElseThrow();

    from.debit(amount);
    to.credit(amount);

    accountRepository.save(from);
    accountRepository.save(to);
    // Se qualcosa fallisce, TUTTO viene rollbackato
}

// 2. Query complesse con JOIN
@Query("""
    SELECT new com.example.OrderSummary(
        o.id, c.name, p.name, oi.quantity, oi.price
    )
    FROM Order o
    JOIN o.customer c
    JOIN o.items oi
    JOIN oi.product p
    WHERE o.createdAt > :since
    AND c.tier = 'PREMIUM'
    ORDER BY o.total DESC
    """)
List&lt;OrderSummary&gt; findPremiumOrdersSince(@Param("since") LocalDateTime since);

// 3. Dati altamente relazionali
// User -> Orders -> OrderItems -> Products -> Categories -> ...


// NoSQL (MongoDB) - Ideale per:
// 1. Documenti con struttura variabile
@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private Map&lt;String, Object&gt; attributes;  // Schema flessibile!
    // Un laptop ha: cpu, ram, storage
    // Una maglietta ha: size, color, material
}

// 2. Dati denormalizzati per read performance
@Document(collection = "orders")
public class Order {
    @Id
    private String id;

    // Embedded, non riferimento - evita JOIN
    private CustomerSnapshot customer;
    private List&lt;OrderItemSnapshot&gt; items;

    // Tutto ciò che serve per visualizzare l'ordine in un solo read
}

// 3. High write throughput (time-series, logging)
@Document(collection = "events")
public class AnalyticsEvent {
    private Instant timestamp;
    private String eventType;
    private Map&lt;String, Object&gt; payload;
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una relazione many-to-many in MongoDB?"<br><br>
                    <strong>Risposta:</strong> Dipende dall'access pattern! (1) Se leggo sempre gli utenti con i loro ruoli: embed array di ruoli nel documento utente. (2) Se leggo spesso i ruoli per vedere quali utenti li hanno: array di userId nel documento ruolo. (3) Se entrambi: duplicazione (denormalizzazione) con gestione manuale della consistency, oppure collection separata di "link" e aggregation pipeline.</p>
                </div>

                <h3>Polyglot Persistence</h3>

                <p>I sistemi moderni spesso usano <strong>più database</strong> per scopi diversi:</p>

                <pre><code class="language-java">// Esempio di architettura polyglot
@Service
public class EcommerceService {

    // PostgreSQL - Ordini, transazioni (ACID)
    private final OrderRepository orderRepository;  // JPA

    // MongoDB - Catalogo prodotti (schema flessibile)
    private final ProductRepository productRepository;  // Spring Data MongoDB

    // Redis - Sessioni, cache, rate limiting
    private final StringRedisTemplate redisTemplate;

    // Elasticsearch - Ricerca full-text
    private final ElasticsearchOperations elasticOps;

    // Neo4j - Raccomandazioni (grafi)
    private final RecommendationRepository recommendationRepo;

    public SearchResult search(String query) {
        // Elasticsearch per ricerca
        return elasticOps.search(query, Product.class);
    }

    public List&lt;Product&gt; getRecommendations(Long userId) {
        // Neo4j: "utenti che hanno comprato X hanno anche comprato Y"
        return recommendationRepo.findRecommendationsFor(userId);
    }

    @Transactional
    public Order placeOrder(OrderRequest request) {
        // PostgreSQL per transazione ACID
        return orderRepository.save(createOrder(request));
    }
}</code></pre>
            </section>

            <!-- Kafka Section -->
            <section class="section" id="modulo4-kafka">
                <h2>Apache Kafka - Event Streaming</h2>

                <p><strong>Apache Kafka</strong> è una piattaforma di event streaming distribuita, progettata per gestire flussi di dati in tempo reale con alto throughput, durabilità e fault tolerance.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         KAFKA ARCHITECTURE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producers                    Kafka Cluster                   Consumers   │
│   ─────────                    ─────────────                   ─────────   │
│                                                                             │
│   ┌─────────┐                  ┌─────────────────────────┐                  │
│   │Producer │──publish──►     │     Topic: orders        │                  │
│   │   A     │                  │  ┌─────┬─────┬─────┐    │                  │
│   └─────────┘                  │  │ P0  │ P1  │ P2  │    │    ┌──────────┐ │
│                                │  ├─────┼─────┼─────┤    │───►│Consumer  │ │
│   ┌─────────┐                  │  │msg1 │msg2 │msg4 │    │    │Group A   │ │
│   │Producer │──publish──►     │  │msg3 │msg5 │msg7 │    │    │┌────────┐│ │
│   │   B     │                  │  │msg6 │msg8 │     │    │    ││C1 (P0) ││ │
│   └─────────┘                  │  └─────┴─────┴─────┘    │    ││C2 (P1) ││ │
│                                │                         │    ││C3 (P2) ││ │
│                                │  Partitions             │    │└────────┘│ │
│                                │  (parallelism unit)     │    └──────────┘ │
│                                │                         │                  │
│                                │  Broker 1   Broker 2    │    ┌──────────┐ │
│                                │  ┌──────┐   ┌──────┐    │───►│Consumer  │ │
│                                │  │P0,P2 │   │P1    │    │    │Group B   │ │
│                                │  │leader│   │leader│    │    │(all P)   │ │
│                                │  └──────┘   └──────┘    │    └──────────┘ │
│                                │                         │                  │
│                                │  Replication Factor = 2 │                  │
│                                └─────────────────────────┘                  │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Key Concepts:                                                             │
│   • Topic: categoria/feed di messaggi (come una tabella)                    │
│   • Partition: unità di parallelismo, messaggi ordinati per partition       │
│   • Offset: ID sequenziale del messaggio nella partition                    │
│   • Consumer Group: gruppo di consumer che si dividono le partition         │
│   • Replication: copie delle partition su broker diversi (fault tolerance)  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Kafka Producer</h3>

                <pre><code class="language-java">// Configurazione Spring Kafka Producer
@Configuration
public class KafkaProducerConfig {

    @Bean
    public ProducerFactory&lt;String, OrderEvent&gt; producerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);

        // Durability settings
        config.put(ProducerConfig.ACKS_CONFIG, "all");  // Aspetta ACK da tutti i replica
        config.put(ProducerConfig.RETRIES_CONFIG, 3);
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);  // Exactly-once

        return new DefaultKafkaProducerFactory&lt;&gt;(config);
    }

    @Bean
    public KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }
}

@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(
            order.getId(),
            OrderEventType.CREATED,
            order.getCustomerId(),
            order.getTotal(),
            Instant.now()
        );

        // Key = customerId per garantire ordine per cliente
        kafkaTemplate.send("orders", order.getCustomerId().toString(), event)
            .whenComplete((result, ex) -> {
                if (ex == null) {
                    log.info("Sent event to partition {} offset {}",
                        result.getRecordMetadata().partition(),
                        result.getRecordMetadata().offset());
                } else {
                    log.error("Failed to send event", ex);
                }
            });
    }
}</code></pre>

                <h3>Kafka Consumer</h3>

                <pre><code class="language-java">// Consumer configuration
@Configuration
@EnableKafka
public class KafkaConsumerConfig {

    @Bean
    public ConsumerFactory&lt;String, OrderEvent&gt; consumerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ConsumerConfig.GROUP_ID_CONFIG, "order-processor");
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);

        // Offset management
        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        config.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);  // Manual commit

        return new DefaultKafkaConsumerFactory&lt;&gt;(config);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt;
            kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);  // 3 consumer threads
        factory.getContainerProperties().setAckMode(AckMode.MANUAL_IMMEDIATE);
        return factory;
    }
}

@Service
@Slf4j
public class OrderEventConsumer {

    @KafkaListener(
        topics = "orders",
        groupId = "order-processor",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(
            @Payload OrderEvent event,
            @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
            @Header(KafkaHeaders.OFFSET) long offset,
            Acknowledgment ack) {

        try {
            log.info("Received event: {} from partition {} offset {}",
                event.getType(), partition, offset);

            processEvent(event);

            // Manual acknowledgment dopo processing riuscito
            ack.acknowledge();

        } catch (Exception e) {
            log.error("Error processing event, will retry", e);
            // Non fare ack - il messaggio verrà ri-processato
            // Oppure invia a Dead Letter Topic
        }
    }

    // Batch consumer per high throughput
    @KafkaListener(topics = "events", groupId = "batch-processor", batch = "true")
    public void consumeBatch(List&lt;ConsumerRecord&lt;String, Event&gt;&gt; records, Acknowledgment ack) {
        log.info("Received batch of {} records", records.size());

        records.forEach(record -> processEvent(record.value()));

        ack.acknowledge();  // Commit dell'intero batch
    }
}</code></pre>

                <h3>Exactly-Once Semantics</h3>

                <div class="info-box">
                    <h4>Delivery Guarantees</h4>
                    <ul>
                        <li><strong>At-most-once:</strong> Messaggi possono essere persi, mai duplicati (fire-and-forget)</li>
                        <li><strong>At-least-once:</strong> Messaggi mai persi, possibili duplicati (default Kafka)</li>
                        <li><strong>Exactly-once:</strong> Ogni messaggio processato esattamente una volta (richiede configurazione specifica)</li>
                    </ul>
                </div>

                <pre><code class="language-java">// Exactly-once con Transactional Producer + Consumer
@Configuration
public class ExactlyOnceConfig {

    @Bean
    public ProducerFactory&lt;String, Event&gt; transactionalProducerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
        config.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "tx-producer-1");
        // ...serializers

        DefaultKafkaProducerFactory&lt;String, Event&gt; factory =
            new DefaultKafkaProducerFactory&lt;&gt;(config);
        factory.setTransactionIdPrefix("tx-");
        return factory;
    }

    @Bean
    public KafkaTransactionManager&lt;String, Event&gt; kafkaTransactionManager() {
        return new KafkaTransactionManager&lt;&gt;(transactionalProducerFactory());
    }
}

@Service
public class TransactionalProcessor {

    private final KafkaTemplate&lt;String, Event&gt; kafkaTemplate;

    @Transactional("kafkaTransactionManager")
    public void processAndPublish(Event input) {
        // Read-Process-Write in una transazione Kafka
        Event processed = process(input);
        kafkaTemplate.send("output-topic", processed);
        // Se fallisce, tutto viene rollbackato
    }
}</code></pre>

                <h3>Partitioning Strategy</h3>

                <pre><code class="language-java">// Custom partitioner per controllo distribuzione
public class CustomerPartitioner implements Partitioner {

    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                         Object value, byte[] valueBytes, Cluster cluster) {
        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);
        int numPartitions = partitions.size();

        if (key == null) {
            // Round-robin per messaggi senza key
            return ThreadLocalRandom.current().nextInt(numPartitions);
        }

        // Consistent hashing sul customer ID
        // Tutti gli ordini dello stesso cliente vanno alla stessa partition
        // → Garantisce ordine per cliente
        return Math.abs(key.hashCode()) % numPartitions;
    }

    @Override
    public void close() {}

    @Override
    public void configure(Map&lt;String, ?&gt; configs) {}
}</code></pre>
            </section>

            <!-- RabbitMQ Section -->
            <section class="section" id="modulo4-rabbitmq">
                <h2>RabbitMQ - Message Broker</h2>

                <p><strong>RabbitMQ</strong> è un message broker che implementa il protocollo AMQP (Advanced Message Queuing Protocol). È progettato per scenari di messaging tradizionale con routing flessibile e garanzie di delivery.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        RABBITMQ ARCHITECTURE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producer                    RabbitMQ Broker                   Consumer    │
│   ────────                    ───────────────                   ────────    │
│                                                                             │
│   ┌─────────┐     ┌─────────────────────────────────────────┐              │
│   │Publisher│────►│  Exchange                               │              │
│   └─────────┘     │  ┌─────────────────────────────────┐    │              │
│                   │  │  Routing Logic                   │    │              │
│                   │  │  (type: direct/fanout/topic/    │    │              │
│                   │  │   headers)                       │    │              │
│                   │  └───────────┬─────────────────────┘    │              │
│                   │              │                           │              │
│                   │              │ Bindings                  │              │
│                   │              │ (routing rules)           │              │
│                   │              │                           │              │
│                   │  ┌───────────▼───────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.created              │──┼─►│Consumer ││
│                   │  │  [msg1][msg2][msg3]               │  │  │   A     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   │  ┌───────────────────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.shipped              │──┼─►│Consumer ││
│                   │  │  [msg4][msg5]                     │  │  │   B     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   └─────────────────────────────────────────┘              │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Exchange Types:                                                           │
│   • Direct:  routing key esatto (1:1)                                       │
│   • Fanout:  broadcast a tutte le queue (1:N)                               │
│   • Topic:   pattern matching con wildcard (*.orders.#)                     │
│   • Headers: routing basato su header attributes                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Exchange Types in dettaglio</h3>

                <pre><code class="language-java">@Configuration
public class RabbitMQConfig {

    // ═══════════════════════════════════════════════════════════════════════
    // DIRECT EXCHANGE - Routing esatto per key
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange("order.exchange");
    }

    @Bean
    public Queue orderCreatedQueue() {
        return QueueBuilder.durable("order.created")
            .withArgument("x-dead-letter-exchange", "dlx.exchange")
            .withArgument("x-dead-letter-routing-key", "order.created.dlq")
            .build();
    }

    @Bean
    public Binding orderCreatedBinding() {
        return BindingBuilder
            .bind(orderCreatedQueue())
            .to(orderExchange())
            .with("order.created");  // Routing key esatto
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FANOUT EXCHANGE - Broadcast a tutte le queue
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public FanoutExchange notificationExchange() {
        return new FanoutExchange("notification.fanout");
    }

    @Bean
    public Queue emailQueue() {
        return new Queue("notification.email");
    }

    @Bean
    public Queue smsQueue() {
        return new Queue("notification.sms");
    }

    @Bean
    public Queue pushQueue() {
        return new Queue("notification.push");
    }

    @Bean
    public Binding emailBinding() {
        return BindingBuilder.bind(emailQueue()).to(notificationExchange());
        // Nessun routing key - riceve TUTTO
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOPIC EXCHANGE - Pattern matching
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public TopicExchange eventExchange() {
        return new TopicExchange("event.topic");
    }

    @Bean
    public Queue allOrderEventsQueue() {
        return new Queue("events.orders.all");
    }

    @Bean
    public Queue europeanEventsQueue() {
        return new Queue("events.europe");
    }

    @Bean
    public Binding allOrdersBinding() {
        return BindingBuilder
            .bind(allOrderEventsQueue())
            .to(eventExchange())
            .with("order.*");  // order.created, order.shipped, order.cancelled
    }

    @Bean
    public Binding europeanBinding() {
        return BindingBuilder
            .bind(europeanEventsQueue())
            .to(eventExchange())
            .with("*.*.europe.#");  // user.created.europe, order.shipped.europe.italy
    }
    // Pattern: * = una parola, # = zero o più parole
}</code></pre>

                <h3>Producer e Consumer</h3>

                <pre><code class="language-java">// Producer
@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final RabbitTemplate rabbitTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(order.getId(), "CREATED", Instant.now());

        rabbitTemplate.convertAndSend(
            "order.exchange",      // Exchange
            "order.created",       // Routing key
            event,
            message -> {
                // Headers per tracing
                message.getMessageProperties().setCorrelationId(UUID.randomUUID().toString());
                message.getMessageProperties().setContentType("application/json");
                return message;
            }
        );
    }

    // Con conferma di pubblicazione
    public void publishWithConfirmation(OrderEvent event) {
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());

        rabbitTemplate.convertAndSend("order.exchange", "order.created", event, correlationData);

        correlationData.getFuture().whenComplete((confirm, ex) -> {
            if (confirm != null && confirm.isAck()) {
                log.info("Message confirmed by broker");
            } else {
                log.error("Message not confirmed: {}", confirm != null ? confirm.getReason() : ex);
                // Retry o salva per riprocessamento
            }
        });
    }
}

// Consumer
@Service
@Slf4j
public class OrderEventConsumer {

    @RabbitListener(queues = "order.created")
    public void handleOrderCreated(
            OrderEvent event,
            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag,
            Channel channel) throws IOException {

        try {
            log.info("Processing order event: {}", event.getOrderId());

            processOrder(event);

            // Manual ACK
            channel.basicAck(deliveryTag, false);

        } catch (RecoverableException e) {
            // Requeue per retry
            channel.basicNack(deliveryTag, false, true);

        } catch (Exception e) {
            // Non recuperabile - invia a DLQ (reject senza requeue)
            channel.basicNack(deliveryTag, false, false);
        }
    }

    // Con retry automatico
    @RabbitListener(queues = "order.created", containerFactory = "retryContainerFactory")
    public void handleWithRetry(OrderEvent event) {
        processOrder(event);  // Eccezioni causano retry automatico
    }
}

// Retry configuration
@Bean
public SimpleRabbitListenerContainerFactory retryContainerFactory(
        ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setAcknowledgeMode(AcknowledgeMode.AUTO);

    factory.setAdviceChain(RetryInterceptorBuilder.stateless()
        .maxAttempts(3)
        .backOffOptions(1000, 2.0, 10000)  // 1s, 2s, 4s, max 10s
        .recoverer(new RejectAndDontRequeueRecoverer())  // Dopo 3 tentativi → DLQ
        .build());

    return factory;
}</code></pre>

                <div class="info-box warning">
                    <h4>Dead Letter Queue (DLQ)</h4>
                    <p>I messaggi finiscono in DLQ quando: (1) vengono rejected senza requeue, (2) TTL scade, (3) queue overflow. Configura sempre DLQ per non perdere messaggi problematici e poterli analizzare/riprocessare.</p>
                </div>
            </section>

            <!-- Kafka vs RabbitMQ Section -->
            <section class="section" id="modulo4-comparison">
                <h2>Kafka vs RabbitMQ</h2>

                <p>Kafka e RabbitMQ risolvono problemi diversi. Capire le differenze è fondamentale per scegliere lo strumento giusto.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Apache Kafka</th>
                            <th>RabbitMQ</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Modello</strong></td>
                            <td>Event streaming / Log distribuito</td>
                            <td>Message broker tradizionale</td>
                        </tr>
                        <tr>
                            <td><strong>Persistenza</strong></td>
                            <td>Messaggi persistiti per retention period (giorni/settimane)</td>
                            <td>Messaggi rimossi dopo ACK</td>
                        </tr>
                        <tr>
                            <td><strong>Replay</strong></td>
                            <td>Sì - consumer può rileggere da qualsiasi offset</td>
                            <td>No - messaggio consumato è perso</td>
                        </tr>
                        <tr>
                            <td><strong>Throughput</strong></td>
                            <td>Molto alto (milioni msg/sec)</td>
                            <td>Alto (decine di migliaia msg/sec)</td>
                        </tr>
                        <tr>
                            <td><strong>Latenza</strong></td>
                            <td>Più alta (batching)</td>
                            <td>Più bassa (singoli messaggi)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Semplice (topic/partition)</td>
                            <td>Complesso (exchange types, binding keys)</td>
                        </tr>
                        <tr>
                            <td><strong>Ordine messaggi</strong></td>
                            <td>Garantito per partition</td>
                            <td>Garantito per queue (single consumer)</td>
                        </tr>
                        <tr>
                            <td><strong>Consumer groups</strong></td>
                            <td>Built-in, scalabile</td>
                            <td>Competing consumers (più limitato)</td>
                        </tr>
                        <tr>
                            <td><strong>Protocollo</strong></td>
                            <td>Proprietario (TCP binary)</td>
                            <td>AMQP (standard), MQTT, STOMP</td>
                        </tr>
                    </tbody>
                </table>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      WHEN TO USE WHAT                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   USE KAFKA WHEN:                      USE RABBITMQ WHEN:                   │
│   ───────────────                      ─────────────────                    │
│                                                                             │
│   ✓ Event sourcing                     ✓ Task queues / job distribution    │
│   ✓ Log aggregation                    ✓ Complex routing requirements       │
│   ✓ Stream processing                  ✓ Request/reply pattern              │
│   ✓ Replay di eventi necessario        ✓ Messaggi transitori                │
│   ✓ Alto throughput (>100k msg/sec)    ✓ Bassa latenza critica              │
│   ✓ Multiple consumer groups           ✓ Priorità messaggi                  │
│   ✓ Data pipeline / ETL                ✓ Integrazione legacy (AMQP)         │
│   ✓ Audit trail / compliance           ✓ RPC asincrono                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   EXAMPLE USE CASES:                                                        │
│                                                                             │
│   KAFKA:                               RABBITMQ:                            │
│   • Real-time analytics                • Email sending queue                │
│   • User activity tracking             • Order processing                   │
│   • CDC (Change Data Capture)          • Notification distribution          │
│   • Metrics collection                 • Background job processing          │
│   • Event-driven microservices         • API rate limiting                  │
│   • Machine learning pipelines         • IoT command distribution           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Coesistenza in architetture reali</h3>

                <pre><code class="language-java">// Molte architetture usano ENTRAMBI per scopi diversi

@Service
public class OrderService {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;
    private final RabbitTemplate rabbitTemplate;

    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(buildOrder(request));

        // KAFKA: Event sourcing - traccia TUTTO ciò che succede
        // I consumer possono rileggere, fare analytics, audit
        kafkaTemplate.send("order-events", order.getId().toString(),
            new OrderEvent(order, OrderEventType.CREATED));

        // RABBITMQ: Task queue - invia email di conferma
        // Non serve persistenza, serve routing a worker specifici
        rabbitTemplate.convertAndSend("notifications", "email.order.confirmation",
            new EmailNotification(order.getCustomerEmail(), "Order confirmed"));

        return order;
    }
}

// Kafka consumer per analytics (può rileggere lo storico)
@KafkaListener(topics = "order-events", groupId = "analytics")
public void trackForAnalytics(OrderEvent event) {
    analyticsService.track(event);
}

// Kafka consumer per search indexing (consumer group diverso)
@KafkaListener(topics = "order-events", groupId = "search-indexer")
public void indexForSearch(OrderEvent event) {
    elasticsearchService.index(event);
}

// RabbitMQ consumer per email (task queue, rimuove dopo processing)
@RabbitListener(queues = "email.order.confirmation")
public void sendConfirmationEmail(EmailNotification notification) {
    emailService.send(notification);
}</code></pre>

                <div class="info-box success">
                    <h4>Regola pratica</h4>
                    <p><strong>Kafka</strong>: "Cosa è successo?" (event log, audit, analytics, replay)<br>
                    <strong>RabbitMQ</strong>: "Cosa devo fare?" (task distribution, commands, notifications)</p>
                </div>
            </section>

            <!-- Quiz Section Module 4 -->
            <section class="quiz-section" id="modulo4-quiz">
                <h2>Interactive Challenge Quiz - Database & Messaging</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di database e sistemi di messaging.</p>

                <!-- Question 16 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> In Kafka, se hai un topic con 6 partizioni e un consumer group con 8 consumer, cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q16" id="q16a" value="a">
                            <label for="q16a">Kafka crea automaticamente 2 partizioni aggiuntive</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q16" id="q16b" value="b">
                            <label for="q16b">2 consumer resteranno idle senza partizioni assegnate</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q16" id="q16c" value="c">
                            <label for="q16c">I messaggi vengono distribuiti round-robin tra tutti gli 8 consumer</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q16" id="q16d" value="d">
                            <label for="q16d">Kafka lancia un'eccezione e rifiuta i consumer in eccesso</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q16')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q16"></div>
                </div>

                <!-- Question 17 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q2.</span> Quale tipo di Exchange RabbitMQ useresti per implementare un sistema di notifiche dove ogni evento deve essere ricevuto da TUTTI i subscriber (email, SMS, push)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q17" id="q17a" value="a">
                            <label for="q17a">Direct Exchange con lo stesso routing key per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q17" id="q17b" value="b">
                            <label for="q17b">Topic Exchange con pattern # per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q17" id="q17c" value="c">
                            <label for="q17c">Headers Exchange con match policy "any"</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q17" id="q17d" value="d">
                            <label for="q17d">Fanout Exchange</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q17')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q17"></div>
                </div>

                <!-- Question 18 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q3.</span> Un sistema necessita di: (1) rileggere eventi passati per debug, (2) multiple applicazioni che processano gli stessi eventi indipendentemente, (3) ordine garantito per chiave. Quale soluzione è più adatta?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q18" id="q18a" value="a">
                            <label for="q18a">RabbitMQ con Durable Queues e message TTL lungo</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q18" id="q18b" value="b">
                            <label for="q18b">RabbitMQ con Topic Exchange e multiple queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q18" id="q18c" value="c">
                            <label for="q18c">Kafka con consumer groups separati e partitioning per key</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q18" id="q18d" value="d">
                            <label for="q18d">Redis Pub/Sub con persistenza attiva</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q18')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q18"></div>
                </div>

                <!-- Question 19 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In un sistema e-commerce, quale database type è più adatto per il CATALOGO PRODOTTI con attributi variabili (laptop ha CPU/RAM, vestiti hanno taglia/colore)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q19" id="q19a" value="a">
                            <label for="q19a">Document DB (MongoDB) per schema flessibile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q19" id="q19b" value="b">
                            <label for="q19b">SQL con Entity-Attribute-Value (EAV) pattern</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q19" id="q19c" value="c">
                            <label for="q19c">Graph DB per le relazioni tra prodotti</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q19" id="q19d" value="d">
                            <label for="q19d">Key-Value store (Redis) per performance</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q19')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q19"></div>
                </div>

                <!-- Question 20 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Qual è la principale differenza tra <code>acks=1</code> e <code>acks=all</code> nella configurazione di un Kafka Producer?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q20" id="q20a" value="a">
                            <label for="q20a"><code>acks=all</code> invia il messaggio a tutti i consumer, <code>acks=1</code> solo a uno</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q20" id="q20b" value="b">
                            <label for="q20b"><code>acks=1</code> attende conferma solo dal leader, <code>acks=all</code> attende che tutti i replica abbiano scritto</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q20" id="q20c" value="c">
                            <label for="q20c"><code>acks=all</code> abilita la compressione, <code>acks=1</code> la disabilita</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q20" id="q20d" value="d">
                            <label for="q20d"><code>acks=1</code> è per messaggi transazionali, <code>acks=all</code> per messaggi normali</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q20')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q20"></div>
                </div>
            </section>

        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script>
        // Quiz feedback explanations
        const explanations = {
            q1: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è il classico problema della self-invocation. Quando methodA() chiama methodB() internamente, la chiamata NON passa attraverso il proxy Spring, quindi l\'annotazione @Transactional(REQUIRES_NEW) viene completamente ignorata. Entrambe le operazioni avvengono nella stessa transazione, e quando l\'eccezione viene lanciata, tutta la transazione fa rollback.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa risposta sarebbe corretta SE la chiamata passasse attraverso il proxy, ma qui c\'è il problema della self-invocation. Quando un metodo chiama un altro metodo della stessa classe con this.methodB() (anche implicito), bypassa il proxy Spring. REQUIRES_NEW non ha alcun effetto.',
                    b: '❌ Parzialmente corretto sul risultato, ma per il motivo sbagliato. Entrambi fanno rollback, vero, ma non semplicemente perché l\'eccezione si propaga. Il punto chiave è che REQUIRES_NEW NON funziona a causa della self-invocation. Senza questo concetto, non avresti dimostrato la comprensione del proxy pattern.',
                    d: '❌ Sbagliato. Il codice compila perfettamente. Puoi avere quanti @Transactional vuoi nello stesso service. Il problema è che le annotazioni sui metodi interni vengono ignorate quando chiamati internamente (self-invocation).'
                }
            },
            q2: {
                correct: 'b',
                correctText: '✅ Corretto! L\'affermazione B è FALSA. Con RS256 (algoritmo asimmetrico), il JWT viene FIRMATO con la chiave privata ma può essere VALIDATO da chiunque possieda la chiave pubblica. Questo è proprio il vantaggio: puoi distribuire la chiave pubblica a tutti i microservizi che devono validare i token, senza esporre la chiave privata.',
                incorrectText: {
                    a: '❌ Questa affermazione è VERA. Il payload JWT è solo Base64 encoded, non encrypted. Chiunque può decodificarlo con un semplice base64 decode. Per questo non dovresti MAI inserire dati sensibili nel payload.',
                    c: '❌ Questa affermazione è VERA. I JWT sono stateless by design. Una volta emesso un token, rimane valido fino alla scadenza. Per revocare un JWT hai bisogno di meccanismi aggiuntivi come una blacklist di token o short-lived tokens con refresh token rotation.',
                    d: '❌ Questa affermazione è VERA. La signature è calcolata sull\'header e payload. Se qualcuno modifica il payload, la signature non corrisponderà più e il token verrà rifiutato durante la validazione.'
                }
            },
            q3: {
                correct: 'd',
                correctText: '✅ Corretto! Con due collection di tipo List, un singolo JOIN FETCH o EntityGraph causerebbe un MultipleBagFetchException (o peggio, un Cartesian Product con risultati duplicati). Le soluzioni valide sono: (1) cambiare una delle collection in Set, permettendo così il JOIN FETCH di entrambe, oppure (2) usare due query separate con @BatchSize per ottimizzare il lazy loading.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa query causerebbe un MultipleBagFetchException! Hibernate non permette di fare JOIN FETCH di due "bag" (List non ordinate) contemporaneamente perché non può distinguere i duplicati nel Cartesian Product risultante.',
                    b: '❌ Sbagliato e pericoloso! FetchType.EAGER è quasi sempre una cattiva idea. Caricheresti sempre entrambe le collection anche quando non servono, e potresti comunque incorrere nel problema del Cartesian Product con query inefficienti.',
                    c: '❌ Sbagliato. @EntityGraph con due collection List ha lo stesso problema del JOIN FETCH: MultipleBagFetchException. EntityGraph è solo zucchero sintattico sopra JOIN FETCH.'
                }
            },
            q4: {
                correct: 'a',
                correctText: '✅ Corretto! I proxy AOP vengono creati durante postProcessAfterInitialization(). A questo punto il bean è stato completamente inizializzato (@PostConstruct già eseguito), e il BeanPostProcessor può sostituire il bean originale con un proxy che lo avvolge. Questo è il motivo per cui @PostConstruct viene eseguito sulla classe reale, non sul proxy.',
                incorrectText: {
                    b: '❌ Sbagliato. Durante l\'instantiation (fase 1), Spring crea semplicemente l\'istanza del bean usando il costruttore. Il proxy viene creato molto dopo, quando il bean è completamente configurato.',
                    c: '❌ Sbagliato. @PostConstruct viene eseguito PRIMA della creazione del proxy. Infatti, @PostConstruct viene chiamato sulla classe reale, ed è per questo che all\'interno di @PostConstruct non puoi fare self-invocation con aspetti che funzionino.',
                    d: '❌ Sbagliato. postProcessBeforeInitialization() viene eseguito PRIMA di @PostConstruct e dell\'initialization. Il proxy viene creato DOPO, in postProcessAfterInitialization().'
                }
            },
            q5: {
                correct: 'c',
                correctText: '✅ Corretto! I livelli di isolamento sono gerarchici. Phantom Reads sono l\'anomalia "più difficile" da prevenire, e per prevenirla devi prima prevenire tutte le anomalie più "leggere" (Dirty Reads e Non-Repeatable Reads). Non esiste un livello che prevenga i Phantom ma permetta i Non-Repeatable. L\'ordine è: READ_UNCOMMITTED < READ_COMMITTED < REPEATABLE_READ < SERIALIZABLE.',
                incorrectText: {
                    a: '❌ Sbagliato. READ_COMMITTED previene solo i Dirty Reads. Sia Non-Repeatable Reads che Phantom Reads sono ancora possibili.',
                    b: '❌ Sbagliato. REPEATABLE_READ previene Dirty Reads e Non-Repeatable Reads, ma permette ancora Phantom Reads (in alcuni database). È l\'opposto di quello che chiede la domanda.',
                    d: '❌ Sbagliato. SERIALIZABLE previene TUTTE le anomalie (Dirty, Non-Repeatable, e Phantom). Non permette nessuna delle due.'
                }
            },
            // Modulo 2 - Testing
            q6: {
                correct: 'b',
                correctText: '✅ Corretto! Qui stiamo verificando un SIDE-EFFECT: l\'invio di un\'email. Non ci interessa il valore di ritorno, ma verificare CHE l\'email venga inviata e CON QUALI parametri. Questo è esattamente il caso d\'uso di un Mock con behavior verification (verify()).',
                incorrectText: {
                    a: '❌ Sbagliato. Uno Stub fornisce risposte predefinite, ma non verifica che il metodo sia stato chiamato. Se EmailService.send() non venisse mai chiamato, il test passerebbe comunque! Non stiamo testando un valore di ritorno, ma un side-effect.',
                    c: '❌ Non è sbagliato in assoluto, ma non è l\'approccio migliore. Un Fake è utile per Integration Test o quando hai bisogno di un\'implementazione funzionante. Per un Unit Test dove vuoi verificare l\'interazione, un Mock è più diretto e leggibile.',
                    d: '❌ Sbagliato. Uno Spy avvolge un oggetto REALE. Non vuoi che il test invii email vere! Inoltre, lo Spy è utile quando hai bisogno del comportamento reale di alcuni metodi, non quando vuoi sostituire completamente la dipendenza.'
                }
            },
            q7: {
                correct: 'c',
                correctText: '✅ Corretto! I test E2E sono intrinsecamente più "flaky" perché dipendono da molti fattori: network latency, database state, external services availability, browser rendering timing, ecc. Un fallimento può essere causato da qualsiasi componente del sistema, non necessariamente dal codice modificato.',
                incorrectText: {
                    a: '❌ Sbagliato. La Test Pyramid suggerisce esattamente l\'opposto: i test E2E dovrebbero essere il 5-10% del totale. Il 70-80% dovrebbe essere coperto da Unit Test, che sono più veloci, economici e affidabili.',
                    b: '❌ Sbagliato. "Affidabile" qui è ambiguo. Gli Integration Test possono avere falsi positivi (test che passano ma il codice ha bug) o falsi negativi (test che falliscono per ragioni esterne come database non disponibile). Gli Unit Test con mock corretti sono più deterministici.',
                    d: '❌ Sbagliato. Il "test-first" approach significa scrivere test prima del codice, non tutti i test insieme in anticipo. Ogni test guida l\'implementazione incrementale.'
                }
            },
            q9: {
                correct: 'a',
                correctText: '✅ Corretto! Questo è un caso perfetto per un Mock con behavior verification. Puoi configurare il mock per fallire le prime N chiamate (thenThrow().thenThrow().thenReturn()), e poi verificare con verify(mock, times(3)) che il retry sia avvenuto. È veloce, deterministico, e testa esattamente la logica di retry.',
                incorrectText: {
                    b: '❌ Sbagliato. Un test E2E con gateway di staging è lento, costoso, e difficile da rendere deterministico. Come simuli esattamente 2 fallimenti seguiti da un successo? Inoltre, dipendi dalla disponibilità del servizio esterno.',
                    c: '❌ Sbagliato. Uno Stub che ritorna sempre successo non ti permette di testare la retry logic! Non saprai mai se il retry viene effettivamente eseguito quando il gateway fallisce.',
                    d: '❌ Sbagliato. La retry logic è logica di business che può (e deve) essere testata in isolamento. Anzi, gli Unit Test sono ideali per questo caso perché puoi controllare esattamente quando il mock fallisce e quando succede.'
                }
            },
            q10: {
                correct: 'b',
                correctText: '✅ Corretto! Test B usa await() con timeout per aspettare eventual consistency. Questo tipo di test è notoriamente flaky perché: (1) il timing può variare in base al carico del sistema, (2) 5 secondi potrebbero non bastare in CI con risorse limitate, (3) race condition tra indexing e query. I test che dipendono da timing/async sono la fonte principale di flakiness.',
                incorrectText: {
                    a: '❌ Sbagliato. Test A è un Unit Test puro con mock deterministico. Non c\'è nulla di flaky: il mock ritorna sempre lo stesso valore, il test passerà sempre (o fallirà sempre se c\'è un bug).',
                    c: '❌ Sbagliato. Test C testa una somma di interi. Non ci sono problemi di floating point con int (quelli si verificano con float/double). Questo test è completamente deterministico.',
                    d: '❌ Sbagliato. Test D è un Integration Test standard con DB. Con @Transactional e rollback automatico (o DB in-memory pulito), non ci sono collisioni di ID. Il test è deterministico.'
                }
            },
            // Modulo 3 - Architettura & Scalabilità
            q11: {
                correct: 'c',
                correctText: '✅ Corretto! Quando un Circuit Breaker è in HALF-OPEN, sta "testando" se il servizio downstream è tornato sano. Se la richiesta di test fallisce, significa che il servizio non si è ancora ripreso, quindi il breaker torna in OPEN e ricomincia il timer di attesa. Solo se la richiesta ha successo torna in CLOSED.',
                incorrectText: {
                    a: '❌ Sbagliato. Lo stato HALF-OPEN permette un numero limitato di richieste di test (configurabile, spesso 1). Se fallisce, non continua a testare ma torna in OPEN per proteggere il sistema.',
                    b: '❌ Sbagliato. CLOSED significa "tutto ok, lascia passare tutte le richieste". Un fallimento in HALF-OPEN indica che il servizio NON è tornato sano, quindi tornare in CLOSED sarebbe pericoloso.',
                    d: '❌ Sbagliato. Non esiste uno stato DISABLED nel pattern standard del Circuit Breaker. Il ciclo è sempre: CLOSED ↔ OPEN ↔ HALF-OPEN.'
                }
            },
            q12: {
                correct: 'b',
                correctText: '✅ Corretto! Un sistema AP (Availability over Consistency) durante una partition continua a rispondere alle richieste anche se non può garantire che tutti i nodi abbiano gli stessi dati. Questo significa che utenti diversi potrebbero vedere versioni diverse dei dati (stale reads) o che scritture su nodi diversi potrebbero divergere. Sistemi come Cassandra e DynamoDB seguono questo modello.',
                incorrectText: {
                    a: '❌ Sbagliato. Rifiutare le scritture ma permettere le letture è un compromesso, ma non è la definizione di AP. Un sistema AP cerca di mantenere availability per TUTTE le operazioni.',
                    c: '❌ Sbagliato. Bloccare tutte le richieste è esattamente l\'opposto di Availability. Questa sarebbe la scelta di un sistema CP (Consistency over Availability).',
                    d: '❌ Sbagliato. L\'elezione di un leader è una tecnica per mantenere consistency (sistemi CP come MongoDB). Durante una partition, se non c\'è quorum, un sistema CP rifiuta le richieste piuttosto che rischiare inconsistenza.'
                }
            },
            q13: {
                correct: 'a',
                correctText: '✅ Corretto! Write-Behind (o Write-Back) scrive prima in cache e poi asincronamente (in batch) al database. Questo minimizza la latenza di scrittura perché l\'applicazione non deve aspettare la persistenza su DB. Il trade-off è che se la cache crasha prima del flush, i dati non ancora persistiti vanno persi. È ideale per scenari come analytics, logging, o contatori dove la perdita occasionale è accettabile.',
                incorrectText: {
                    b: '❌ Sbagliato. Write-Through scrive SINCRONAMENTE sia in cache che in DB. La latenza di scrittura è ALTA (somma di entrambe le scritture), non bassa. È il pattern giusto quando la consistency è prioritaria.',
                    c: '❌ Sbagliato. Cache-Aside (Lazy Loading) riguarda principalmente le LETTURE. Per le scritture, tipicamente si scrive direttamente al DB e si invalida/aggiorna la cache. Non ottimizza la latenza di scrittura.',
                    d: '❌ Sbagliato. Read-Through è un pattern di LETTURA: la cache carica automaticamente dal DB quando c\'è un miss. Non riguarda le scritture.'
                }
            },
            q14: {
                correct: 'd',
                correctText: '✅ Corretto! Con hash modulo N, se aggiungi o rimuovi un server (N cambia), TUTTE le chiavi vengono rimappate (k mod N diverso da k mod N±1). Con Consistent Hashing, solo le chiavi che "appartengono" al nodo aggiunto/rimosso vengono spostate (circa 1/N del totale). Questo è cruciale per cache distribuite dove rimappare tutto significherebbe cache miss massivi.',
                incorrectText: {
                    a: '❌ Sbagliato. Il Consistent Hashing è leggermente PIÙ costoso da calcolare (richiede trovare il nodo successivo sul ring). Il vantaggio non è la velocità di calcolo.',
                    b: '❌ Sbagliato. Il Consistent Hashing base NON garantisce distribuzione uniforme - alcuni nodi potrebbero avere più chiavi di altri. Si usano "virtual nodes" per migliorare la distribuzione, ma non è perfetta.',
                    c: '❌ Sbagliato. Entrambi gli approcci usano funzioni hash standard e supportano gli stessi tipi di chiavi. La differenza è come viene usato il risultato dell\'hash, non l\'input.'
                }
            },
            q15: {
                correct: 'c',
                correctText: '✅ Corretto! Quando il dominio di business non è ancora ben definito, i boundaries dei microservizi sono difficili da tracciare correttamente. Sbagliare i boundaries porta a "distributed monolith" - tutti gli svantaggi di entrambi gli approcci. Un monolite permette di refactorare facilmente mentre si impara il dominio, e si può sempre estrarre microservizi dopo quando i boundaries sono chiari (Monolith First approach di Martin Fowler).',
                incorrectText: {
                    a: '❌ Sbagliato. Il numero di utenti non determina l\'architettura. Monoliti ben progettati possono scalare a milioni di utenti (vedi Stack Overflow). La questione è se hai bisogno di scaling DIVERSO per parti diverse del sistema.',
                    b: '❌ Sbagliato. Avere esperienza con Kubernetes può facilitare i microservizi, ma non è un motivo per sceglierli. La scelta architetturale deve essere guidata dai requisiti di business e team, non dalla tecnologia che conosci.',
                    d: '❌ Sbagliato. Requisiti di scaling molto diversi tra componenti sono effettivamente un buon motivo per considerare i microservizi (puoi scalare indipendentemente). Questo è un fattore PRO microservizi, non pro monolite.'
                }
            },
            // Modulo 4 - Database & Messaging
            q16: {
                correct: 'b',
                correctText: '✅ Corretto! In Kafka, ogni partition può essere assegnata a UN SOLO consumer per consumer group. Con 6 partizioni e 8 consumer, solo 6 consumer riceveranno una partition ciascuno. I 2 consumer extra resteranno idle in standby, pronti a subentrare se uno degli altri fallisce (failover automatico).',
                incorrectText: {
                    a: '❌ Sbagliato. Kafka NON crea partizioni automaticamente in base ai consumer. Il numero di partizioni è definito alla creazione del topic (o modificato manualmente). È il contrario: devi dimensionare le partizioni in base al parallelismo desiderato.',
                    c: '❌ Sbagliato. Il round-robin avviene a livello di PARTIZIONE, non di consumer. Un messaggio va sempre alla stessa partition (basato su key o round-robin del producer), e quella partition è assegnata a un solo consumer del gruppo.',
                    d: '❌ Sbagliato. Kafka non rifiuta i consumer in eccesso. Li tiene nel gruppo come "idle" pronti per il failover. Questo è utile per high availability.'
                }
            },
            q17: {
                correct: 'd',
                correctText: '✅ Corretto! Fanout Exchange è progettato esattamente per questo use case: ignora completamente il routing key e inoltra ogni messaggio a TUTTE le queue collegate. È il pattern publish-subscribe puro. Ogni subscriber (email, SMS, push) ha la propria queue collegata al fanout, e tutti ricevono ogni messaggio.',
                incorrectText: {
                    a: '❌ Funzionerebbe, ma è over-engineered. Direct Exchange con lo stesso routing key richiede di mantenere la stessa key su tutti i binding. Fanout è più semanticamente corretto e più semplice.',
                    b: '❌ Funzionerebbe con pattern #, ma Topic Exchange è progettato per routing selettivo basato su pattern. Usarlo per broadcast è come usare una regex quando basta un semplice match.',
                    c: '❌ Headers Exchange è il più complesso, usato per routing basato su attributi multipli. Overkill per un semplice broadcast.'
                }
            },
            q18: {
                correct: 'c',
                correctText: '✅ Corretto! Kafka soddisfa tutti e 3 i requisiti: (1) I messaggi sono persistiti e rileggibi da qualsiasi offset (replay per debug). (2) Consumer groups diversi processano indipendentemente gli stessi messaggi. (3) Messaggi con la stessa key vanno sempre alla stessa partition, dove l\'ordine è garantito. RabbitMQ non supporta il replay nativamente.',
                incorrectText: {
                    a: '❌ Sbagliato. RabbitMQ rimuove i messaggi dopo l\'ACK, anche con TTL lungo. Non puoi rileggere messaggi già consumati. Il TTL ritarda solo la scadenza di messaggi NON consumati.',
                    b: '❌ Sbagliato. Multiple queue con Topic Exchange permettono a più consumer di ricevere gli stessi messaggi, ma (1) niente replay dopo consumo, (2) nessuna garanzia di ordine attraverso multiple queue.',
                    d: '❌ Sbagliato. Redis Pub/Sub è fire-and-forget: se il subscriber non è connesso, perde il messaggio. Non c\'è persistenza né replay. Redis Streams è diverso e più simile a Kafka, ma non è Pub/Sub.'
                }
            },
            q19: {
                correct: 'a',
                correctText: '✅ Corretto! Un Document DB come MongoDB è ideale per prodotti con attributi variabili. Ogni documento può avere campi diversi (laptop.cpu, tshirt.size) senza modifiche allo schema. Il pattern EAV in SQL è un anti-pattern noto per complessità delle query e pessime performance. Graph DB è per relazioni, Key-Value non supporta query sugli attributi.',
                incorrectText: {
                    b: '❌ Sbagliato. EAV (Entity-Attribute-Value) è considerato un anti-pattern SQL. Query come "trova laptop con RAM > 16GB" diventano JOIN complessi e lentissimi. È difficile da indicizzare e le query sono illeggibili.',
                    c: '❌ Sbagliato. Graph DB eccelle per relazioni (social network, raccomandazioni), non per dati con attributi variabili. Per "prodotti simili" potrebbe essere utile, ma non per il catalogo base.',
                    d: '❌ Sbagliato. Key-Value store (Redis) è ottimo per cache, ma non puoi fare query come "tutti i laptop rossi con prezzo < 1000€". Supporta solo lookup per key esatta.'
                }
            },
            q20: {
                correct: 'b',
                correctText: '✅ Corretto! acks controlla quante repliche devono confermare la scrittura prima che il producer consideri il messaggio "committed". acks=1: solo il leader conferma (veloce, ma rischio perdita se leader crasha prima della replica). acks=all: tutte le repliche in-sync devono confermare (più lento, ma massima durabilità). acks=0: fire-and-forget, nessuna conferma.',
                incorrectText: {
                    a: '❌ Sbagliato. acks non riguarda i consumer, ma la REPLICAZIONE tra broker. I consumer non sono coinvolti nel processo di ack del producer.',
                    c: '❌ Sbagliato. La compressione è configurata separatamente (compression.type). acks riguarda solo la conferma di scrittura.',
                    d: '❌ Sbagliato. Le transazioni Kafka si abilitano con transactional.id e enable.idempotence. acks=all è necessario per exactly-once, ma da solo non abilita le transazioni.'
                }
            }
        };

        function checkAnswer(questionId) {
            const questionEl = document.querySelector(`[data-correct]#feedback-${questionId}`)?.closest('.quiz-question')
                || document.querySelector(`.quiz-question:has(#feedback-${questionId})`);

            if (!questionEl) return;

            const correctAnswer = questionEl.dataset.correct;
            const selectedOption = questionEl.querySelector(`input[name="${questionId}"]:checked`);

            if (!selectedOption) {
                alert('Seleziona una risposta prima di verificare!');
                return;
            }

            const selectedValue = selectedOption.value;
            const feedbackEl = document.getElementById(`feedback-${questionId}`);
            const allOptions = questionEl.querySelectorAll('.quiz-option');

            // Reset previous states
            allOptions.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });

            // Mark correct and incorrect
            allOptions.forEach(opt => {
                const optValue = opt.dataset.value;
                if (optValue === correctAnswer) {
                    opt.classList.add('correct');
                } else if (optValue === selectedValue) {
                    opt.classList.add('incorrect');
                }
            });

            // Show feedback
            const explanation = explanations[questionId];
            if (selectedValue === correctAnswer) {
                feedbackEl.className = 'feedback correct';
                feedbackEl.innerHTML = `<strong>Esatto!</strong>${explanation.correctText}`;
            } else {
                feedbackEl.className = 'feedback incorrect';
                feedbackEl.innerHTML = `<strong>Risposta errata</strong>${explanation.incorrectText[selectedValue]}<br><br><em>La risposta corretta era l'opzione ${correctAnswer.toUpperCase()}:</em> ${explanation.correctText.replace('✅ Corretto! ', '')}`;
            }

            // Disable further changes
            questionEl.querySelectorAll('input').forEach(input => input.disabled = true);
            questionEl.querySelector('.check-btn').disabled = true;
        }

        // Smooth scrolling for sidebar links
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }

                    // Update active state
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                }
            });
        });

        // Update active nav on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section[id], header[id]');
            let current = '';

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (scrollY >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
